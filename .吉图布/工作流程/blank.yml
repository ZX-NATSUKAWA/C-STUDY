# This is a basic workflow to help you get started with Actions

name: CI

# Controls when the workflow will run
on:
  # Triggers the workflow on push or pull request events but only for the main branch
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

  # Allows you to run this workflow manually from the Actions tab
  workflow_dispatch:

# A workflow run is made up of one or more jobs that can run sequentially or in parallel
jobs:
  # This workflow contains a single job called "build"
  build:
    # The type of runner that the job will run on
    runs-on: ubuntu-latest

    # Steps represent a sequence of tasks that will be executed as part of the job
    steps:
      # Checks-out your repository under $GITHUB_WORKSPACE, so your job can access it
      - uses: actions/checkout@v2

      # Runs a single command using the runners shell
      - name: Run a one-line script
        run: echo Hello, world!

      # Runs a set of commands using the runners shell
      - name: Run a multi-line script
        run: |
          echo Add other actions to build,
          echo test, and deploy your project.


struct Book
{
  char name[20];
  short price; // 55
};
int main()
{
  sreuct Book bl ={"C语言真难",55};
  printf("书名:%s\n",bl,name);
  printf("价格:%d\n",bl,price);
  return 0;
}

//分支语句和循环语句
//C语言是一门结构化的程序设计语言（顺序结构、选择结构、循环结构）
// 选择结构——分支语句
int main()
{
	int a = 0; // ;表示一条语句结束了
	; // 空语句
	return 0;
}
int main()
{
	int age = 10;
	if (age < 18)
		printf("未成年\n");  //到这一步是单分支
	else
		printf("成年\n");    //双分支
	return 0;
}
int main()
{
	int age = 21;
	if (age < 18)
	{
  printf("未成年\n");
  }
  else
  {
  if (age >= 18 && age < 28)
		printf("青年\n");
	else if (age >= 28 && age < 50)
		printf("壮年\n");
	else if (age >= 50 && age < 90)
		printf("老年\n");
	else
		printf("仙人\n");
   }
	return 0;
}
int main()
{
	int a = 0;
	int b = 2;
	if (a == 1)
	{
		if (b == 2)
			printf("hehe\n");
	}
	else
		    printf("haha\n");
	return 0;
}
//比较奇数
int main()
{
	int a = 4;
	if (a % 2 == 0)
		printf("偶数\n");
	else
		printf("奇数\n");
	return 0;
}
int main()
{
	int i = 1;
	while (i <= 100)
	{
		if (i % 2 == 1)
			printf(" % d", i);
		i++;
	}
	return 0;
}
int main()
{
	int i = 1;
	while (i <= 100)
	{
		if (i % 2 != 0)
			printf("%d", i);
		i+=2;
	}
	return 0;
}
int main()
{
	int day = 0;
	scanf("%d", &day);
	switch (day)
	{
		case 1:
			if (1 == day)
				printf("周末综合征\n");
		case 2:
		case 3:
		case 4:
		case 5:
			printf("工作日\n");
			break;
		case 6:
		case 7:
			printf("休息日\n");
			break; //最后一句加上break防止后续加代码，case7执行时把后面的也执行了。
		case 8:
			break;
		default:
			printf("输入错误\n");
			break;
	}
	return 0;
}
int main()
{
	int n = 1;
	int m = 2;
	switch (n)
	{ 
	case 1:m++;
	case 2:n++;
	case 3:
		switch(n) //switch允许嵌套使用
		{
	    case 1:n++;
		case 2:m++; n++;
			break;//用于跳出case3内的分支，进入原来的分支。
		}
	case 4:m++;
		break;
	default:
		break;
	}
	printf("m=%d,n=%d\n", m, n); // m=5 n=3
	return 0;
} 
 循环结构——循环语句
int main()
{
	while (1)
		printf("hehe\n"); //无限循环打印hehe
	return 0;
}
int main()
{
	int i = 1;
	while (i <= 10)
	{
		if (5 == i)
			break; //打破循环
		printf(" %d",i);
		i++;
	}
	return 0;
}
int main()
{
	int i = 0;
	while (i <= 10)
	{
		//if (5 == i)
		//	continue; // continue后的不执行，返回while的判断。此处进入死循环
		i++;
		if (5 == i)
			continue;
		printf(" %d", i);
	}
	return 0;
}

int main()
{
	int ch = getchar();
	putchar(ch); //相当于printf("%c\n",ch);
	printf("%c\n", ch);
	return 0;
}
#define _CRT_SECURE_NO_WARNING 1
int main()
{
	int ch = 0;
	//输入ctrl+z此时getchar获取EOF结束循环
	while ((ch = getchar()) != EOF)  //EOF=end of file文件结束标志
	{
		putchar(ch);
	}
	return 0;
}
int main()
{
	int ret = 0;
	int ch =0;
	char password[20] = { 0 };
	printf("请输入密码：>");
	scanf("%s", password);  //输入缓冲区123456\n→输入函数123456
	printf("请确认（Y/N):>");
	while((ch = getchar()) != '\n')
	{
	  ;
	}
	ret = getchar();
	if (ret == 'Y')
	{
		printf("确认成功\n");
	}
	else
	{
		printf("放弃确认\n");
	}
	return 0;
}
int main()
{
	int i = 0;
	for (i = 1; i <= 10; i++) //将三个步骤放在了一起
	{
		printf("%d ", i);
	}
	return 0;
 }
int main()                      //计算阶乘求和
{
	int i = 0;
	int n = 0;
	int ret = 1;
	int sum = 0;
	int k = 0;
	scanf("%d", &k);
	for (n = 1; n <= k; n++)
	{
		ret = 1;
		for(i=1;i<=n;i++)
		{
			ret = ret * i;
		}
		sum = sum + ret;
	}
	printf("sum=%d\n", sum);
	return 0;
}
5
int main()
{
	int i = 0;
	char password[20] = { 0 };
	for (i = 0; i < 3; i++)
	{

		printf("请输入密码:>");
		scanf("%s", password);
		if (strcmp(password, "1210") == 0)  //等号不能用来比较两个字符串是否相等，应该使用一个库函数-strcmp
		{
			printf("登录成功\n");
			break;
		}
		else
			printf("密码错误\n");
	}
	if (3 == i)
		printf("三次密码均错误，退出程序\n");
	return 0;
}
6     //输入三个值排序，按从大到小输出
int main()                           
{
	int a = 0;
	int b = 0;
	int c = 0;
	scanf("%d%d%d", &a, &b, &c);
	if (a < b)
	{
		int tmp = a;
		a = b;
		b = tmp;
	}
	if (a < c)
	{
		int tmp = a;
		a = c;
		c = tmp;
	}
	if (b < c)
	{
		int tmp = b;
		b = c;
		c = tmp;
	}
	printf("%d %d %d\n", a, b, c);
	return 0;
}
7     //打印1-100之间的所有3的倍数
int main()
{
	int i = 0;
	for(i = 1;i < 100; i++)
	{
		if (i % 3 == 0)
			printf("%d ", i);
	}
	return 0;
}
8      //给两个数，求最大公约数
int main()
{
	int a = 0;
	int b = 0;
	scanf("%d%d", &a, &b);
	int r = 0;
	while (a % b)  //辗转相除法
	{
		r = a % b;
		a = b;
		b = r;
	}
	printf("%d\n", b);
	return 0l;
}
8          //打印闰年
int main()
{
	int year = 0;
	int count = 0;
	for (year = 1000; year <= 2000; year++)
	{
		if (year % 4 == 0 && year % 100 != 0)
		{
			printf("%d ", year);
			count++;
		}
		else if (year % 400 == 0)
		{
			printf("%d ", year);
			count++;
		}
	}
	printf("\ncount =%d\n", count);
	return 0;
}
int main()
{
	int year = 0;
	int count = 0;
	for (year = 1000; year <= 2000; year++)
	{
		if (((year % 4 == 0) && (year % 100 != 0)) || (year % 400 == 0))
		{
			printf("%d ", year);
			count++;
		}
	}
	printf("\ncount =%d\n", count);
	return 0;
}
9     //打印素数
int main()
{
	int i = 0;
	int count = 0;
	for (i = 100; i <= 200; i++)  //试除法
	{
		int j = 0;
		for (j = 2; j < i; j++)
		{
			if (i % j == 0)
			{
				break;
			}
		}
		if (j == i)
		{
			count++;
			printf("%d ", i);
		}
	}
	printf("\ncount =%d\n", count);
	return 0;
}
1  //数9的个数
int main()
{
	int i = 0;
	int count = 0;
	for (i = 1; i <= 100; i++)
	{
		if (i % 10 == 9)
			count++;
		if (i / 10 == 9)
			count++;
	}
	printf("count = %d\n", count);
	return 0;
}
2    //分数求和
int main()
{
	int i = 0;
	double sum = 0.0;
	int flag = 1;
	for (i = 1; i <= 100; i++)
	{
		sum += flag*1.0 / i;
		flag = -flag;
	}
	printf("%lf\n", sum);
	return 0;
}
3       //十个数找最大值
int main()
{
	int arr[] = { 1,2,3,4,5,6,7,8,9,10 };
	int max = arr[0];
	int i = 0;
	int sz = sizeof(arr) / sizeof(arr[0]);
	for (i = 0; i < sz; i++)
	{
		if (arr[i] > max)
		{
			max = arr[i];
		}
	}
	printf("max =%d\n", max);
	return 0;
}
4     //屏幕上输出99乘法表
int main()
{
	int i = 0;
	for (i = 1; i <= 9; i++)
	{
		int j = 1;
		for (j = 1; j <= i; j++)
		{
			printf("%d*%d=%-2d ", i, j, i * j);  //%2d表示打印两位，不够自动右对齐；%-2d自动左对齐
		}
		printf("\n");
	}
	return 0;
}
void menu()
{
	printf("猜数字\n");
	printf("***  1.play  0.exit  ***\n");
}
void game()
{
	
	int ret = 0;   
	int guess = 0;
	ret = rand()%100+1;   // 伪随机函数rand 生成0到7FFFH之间的一个任意整数。可以通过取模限定范围
	//printf("%d\n", ret);
	while (1)
	{
		printf("请猜数字：>");
		scanf("%d", &guess);
		if (guess > ret)
		{
			printf("猜大了\n");
		}
		else if (guess < ret)
		{
			printf("猜小了\n");
		}
		else
		{
			printf("猜对了\n");
			break;
		}
	}
}
int main()
{
	int input = 0;
	srand((unsigned int)time(NULL)); // 时间戳 当前时间和计算机起始时间（1970.01.01 00：00）的差值——一直在变化
	do
	{

		menu();
		printf("请选择>:");
		scanf("%d", &input);
		switch (input)
		{
		case 1:
			game();
			break;
		case 0:
			printf("退出游戏\n");
			break;
		default:
			printf("选择错误\n");
			break;
		}
	} while (input);
	return 0;
}
函数
  函数是什么：大型程序的部分代码，解决特定问题，相对独立。 分为库函数和自定义函数
int Add(int x, int y)
{
	int z = 0;
	z = x + y;
	return z;
}
int main()
{
	int a = 20;
	int b = 10;
	int sum = Add(a, b);
	printf("%d\n", sum);
	return 0;
}
  库函数：现成函数，引用头文件就能使用
具体有：IO函数、字符串操作函数、字符操作函数、内存操作函数、时间/日期函数、数学函数、其他库函数。
int main()
{
	char arr1[] = "bit";
	char arr2[20] = "#####";
	strcpy(arr2, arr1);
	printf("%s\n", arr2);
	return 0;
}
int main()
{
	char arr[] = "hehe haha";
	memset(arr, '*', 5);        //memset 内存设置
	printf("%s\n", arr);
	return 0;
}

  自定义函数：自己设计函数
ret_type fun_name(para1, *)  //类型 函数名+格式
{
	statement; //语句项，交代函数如何实现
}
int get_max(int x, int y)
{
	int z = 0;
    if (x > y)
       return x;
    else
       return y;
}
int main()
{
	int a = 10;
	int b = 20;
	int max = get_max (a, b);
	printf("max=%d\n", max);
	return 0;
}
void Swap(int* pa, int* pb)  // void代表没有返回值
{
	int tmp = 0;
	tmp = *pa;
	*pa = *pb;
	*pb = tmp;
}
int main()
{
	int a = 10;
	int* pa = &a;  //pa指针变量，用来存放a的地址
	*pa;//解引用操作，通过pa找到里面存的内容
	int b = 30;
	printf("a=%d b=%d\n", a, b);
	Swap(&a, &b);
	printf("a=%d b=%d\n", a, b);
	return 0;
}
  函数参数：形参、实参
  函数调用:函数与函数间有机组合。
  函数的嵌套调用和链式访问
 嵌套：函数里面套函数。
  链式访问：将一个函数的返回值作为下一函数的参数
int main()
{
	int len = 0;
	len = strlen("abc");
	printf("%d\n", len);
	printf("%d\n", strlen("abc")); // 链式访问
	return 0;
}
int main()
{
	printf("%d", printf("%d", printf("%d", 43))); //printf的返回值是打印在屏幕上字符的个数
	return 0;
}
  函数的声明和定义
 #include"函数.h"  //函数声明
int main()
{
	int a = 10;
	int b = 20;
	int sum = 0;
	sum = Add(a, b);
	printf("%d\n", sum);
	return 0;
}
  函数递归:程序调用自身的编程技巧。将一个大型复杂问题转化为一个与原问题相似的规模较小的问题来求解。
  必要条件：存在限制条件，达到限制条件后停止递归。  每次递归越来越逼近限制条件。
int main()
{
	printf("hrhr\n");
	main();              // main函数套main函数
	return 0;            //递归常见错误：栈溢出
}
void print(int n)
{
	if (n > 9)
	{
		print(n / 10);
	}
	printf("%d ", n % 10);
}
int main()
{
	unsigned int num = 0;
	scanf("%d", &num);
	print(num);
	return 0;
}
int my_strlen(char* str)    //利用循环模拟strlen函数
{
	int count = 0;            // 创建了临时变量count
	while (*str != '\0')
	{
		count++;
		str++;
	}
	return count;
}
int main()
{
	char arr[] = "bit";
	/*int len = strlen(arr);*/
	int len = my_strlen(arr);  //数组传参，传的是首元素地址
	printf("%d\n", len);
	return 0;
}
int my_strlen(char* str)     //利用递归模拟strlen函数
{
	if (*str != '\0')        //无临时变量
		return 1 + my_strlen(str + 1);
	else
		return 0;
}
int main()
{
	char arr[] = "bit";
	int len = my_strlen(arr);
	printf("%d\n", len);
	return 0;
}
递归与迭代
int FAC1(int n)
{
	/*int i = 0;                //循环方式
	int ret = 1;
	for (i = 1; i <= n; i++)
	{
		ret *= i;
	}
	return ret;*/
	if (n <= 1)                 //递归方式
		return 1;
	else
		return n * FAC1(n - 1);
}
int main()  //求n的阶乘
{
	int n = 0;
	int ret = 0;
	scanf("%d", &n);
	ret = FAC1(n);
	printf("%d\n", ret);
	return 0;
}
//数组
// 一维数组的创建和初始化
// 数组是一组相同元素的集合。创建方式：type_t是指数组的元素类型，const_n是一个常量表达式，用来指定数组的大小。
int main()
{
	int arr[10] = { 1，2，3 };  //不完全初始化，剩下的元素初始化默认0
	char arr2[5] = { 'a','b' };
	char arr3[5] = "ab";
	/*int n = 5;*/
	/*char ch[n]; */   //报错，[]中只能使用常量，不能变量。
	return 0;
}
 一维数组的使用
int main()
{
	char arr[] = "asdfg";
	int i = 0;
	for (i = 0; i < strlen(arr); i++)
	{
		printf("%c ", arr[i]);
	}
	return 0;
}
int main()
{
	int arr[] = { 1,2,3,4,5,6,7,8,9,0 };
	int sz = sizeof(arr) / sizeof(arr[0]);
	int i = 0;
	for (i = 0; i < sz; i++)
	{
		printf("%d ", arr[i]);              //利用下标访问数组
	}
	return 0;
}

 一维数组在内存中的存储
int main()
{
	int arr[] = { 1,2,3,4,5,6,7 };
	int sz = sizeof(arr) / sizeof(arr[0]);
	int i = 0;
	for (i = 0; i < sz; i++)
	{
		printf("&arr[%d]=%p\n", i, &arr[i]);
	}
	return 0;
}
 二维数组的创建和初始化
int main()
{
	int arr[3][4] = { 1,2,3,4,5 };
	int arr1[3][4] = { {1,2,3},{4,5} };
	int arr2[][] = { 1,2,3,4,5,6,7,8 };     //报错
	int arr3[][] = { {1,2,3,4},{5,6,7,8} }; //也不行
	int arr4[3][]= { {1,2,3,4},{5,6,7,8} }; //列不能省略
	int arr4[][4] = { {1,2,3,4},{5,6,7,8} };//可以省略行
	return 0;
}
 二维数组的使用
int main()
{
	int arr[3][4] = { {1,2,3},{4,5,6} };
	int i = 0;
	for (i = 0; i < 3; i++)
	{
		int j = 0;
		for (j = 0; j < 4; j++)
		{
			printf("%d ", arr[i][j]);
		}
		printf("\n");
	}
	return 0;
}
 二维数组在内存中的存储
int main()
{
	int arr[3][4] = { {1,2,3},{4,5,6} };
	int i = 0;
	for (i = 0; i < 3; i++)
	{
		int j = 0;
		for (j = 0; j < 4; j++)
		{
			printf("&arr[%d][%d]=%p\n",i,j,&arr[i][j]);
		}
		printf("\n");
	}
	return 0;
}
 数组作为函数参数
void bubble_sort(int arr[],int sz)
{
	int i = 0;
	for (i = 0; i < sz - 1; i++)
	{
		int j = 0;
		for (j = 0; j < sz-1-i; j++)
		{
			if (arr[j] > arr[j + 1]);
			{
				int tmp = arr[j];
				arr[j] = arr[j + 1];
				arr[j + 1] = tmp;
			}
		}
	}
}
void bubble_sort1(int arr[], int sz)    //优化版
{
	int i = 0;
	for (i = 0; i < sz - 1; i++)
	{
		int flag = 1;                   //假设已经有序
		int j = 0;
		for (j = 0; j < sz - 1 - i; j++)
		{
			if (arr[j] > arr[j + 1]);
			{
				int tmp = arr[j];
				arr[j] = arr[j + 1];
				arr[j + 1] = tmp;
				flag = 0;                //本次数组不完全有序
			}
		}
		if (flag == 1)                   //利用flag判断是否已经排序完成
		{
			break;
		}
	}
}
int main()
{
	int arr[] = { 9,8,7,6,5,4,3,2,1,0 }; //将arr排成升序
	int i = 0;
	int sz = sizeof(arr) / sizeof(arr[0]);
	bubble_sort(arr,sz); //冒泡排序函数
	for (i = 0; i < sz; i++)
	{
		printf("%d ", arr[i]);
	}
	return 0;
}
int main()                             //数组名
{
	int arr[] = { 1,2,3,4,5,6,7,8,9 };
	printf("%p\n", arr);
	printf("%p\n", &arr[0]);
	printf("%d\n", *arr);                   //数组名通常就是首元素地址
	int sz = sizeof(arr) / sizeof(arr[0]);  //例外1 sizeof(数组名)，计算的是整个数组的大小，单位是字节。
	printf("%p\n", arr);                    //例外2 取地址 &数组名，代表的是整个数组的地址。
	printf("%p\n", arr+1);                  // 加一后是数组中第二个元素的地址
	printf("%p\n", &arr[0]);
	printf("%p\n", &arr[0]+1);
	printf("%p\n", &arr);                   //看似一样，实际是整个数组地址。加一后的地址是整个数组之后的地址
	printf("%p\n", &arr+1);
	return 0;

//测试 三子棋 游戏
#pragma once
#include<stdlib.h>
#include<time.h>
#include <stdio.h>
#define ROW 3
#define COL 3

void InitBoard(char board[ROW][COL], int row, int col);//函数声明
void DisplayBoard(char board[ROW][COL], int row, int col);
void Playermove(char board[ROW][COL],int row,int col);
void Computermove(char board[ROW][COL], int row, int col);
char Iswin(char board[ROW][COL], int row, int col);


#include "game.h"
#define _CRT_SECURE_NO_WARNINGS 1

void InitBoard(char board[ROW][COL], int row, int col) 
{
	int i = 0;
	int j = 0;
	for (i = 0; i < row; i++)
	{
		for (j = 0; j < col; j++)
		{
			board[i][j] = ' ';
		}
	}
}

void DisplayBoard(char board[ROW][COL], int row, int col)
{
	printf("\n");
	int i = 0;
	for (i = 0; i < row; i++)
	{
		int j = 0;
		for (j = 0; j < col; j++)
		{
			printf(" %c ", board[i][j]);
			if (j < col - 1)
				printf("|");
		}
		printf("\n");
		if (i < row - 1)
		{
			int j = 0;
			for (j = 0; j < col; j++)
			{
				printf("---");
				if (j < col - 1)
					printf("|");
			}
			printf("\n");
		}
	}
}

void Playermove(char board[ROW][COL], int row, int col)
{
	int x = 0;
	int y = 0;
	printf("玩家下：>\n");
	while (1)
	{
		printf("请输入要下的坐标：>");
		scanf_s("%d%d", &x, &y);
		if (x >= 1 && x <= row && y >= 1 && y <= col)
		{
			if (board[x - 1][y - 1] == ' ')
			{
				board[x - 1][y - 1] = '*';
				break;
			}
			else
				printf("该坐标被占用\n");
		}
		else
		{
			printf("坐标非法，请重新输入！\n");
		}
	}
}

void Computermove(char board[ROW][COL], int row, int col)
{
	int x = 0;
	int y = 0;
	printf("电脑下：>");
	while (1)
	{
		x = rand() % row;
		y = rand() % col;
		if (board[x][y] == ' ')
		{
			board[x][y] = '#';
			break;
		}
	}
}

int IsFull(char board[ROW][COL], int row, int col)
{
	int i = 0;
	int j = 0;
	for (i = 0; i < row; i++)
	{
		for (j = 0; j < col; j++)
		{
			if (board[i][j] == ' ')
			{
				return 0;
			}
		}
	}
}
 
char Iswin(char board[ROW][COL], int row, int col) //判断输赢
{
	int i = 0;
	for (i = 0; i < row; i++)  //横三行判断
	{
		if (board[i][0] == board[i][1] && board[i][1] == board[i][2] && board[i][1] != ' ')
		{
			return board[i][0];
		}
	}
	for (i = 0; i < col; i++) //竖三列判断
	{
		if (board[0][i] == board[1][i] && board[1][i] == board[2][i] && board[2][i] != ' ')
		{
			return board[0][i];
		}
	}
	if (board[0][0] == board[1][1] && board[1][1] == board[2][2] && board[1][1] != ' ')  //对角线判断
		return board[1][1];
	if (board[2][0] == board[1][1] && board[1][1] == board[0][2] && board[1][1] != ' ')
		return board[1][1];
	if (1 == IsFull(board, ROW, COL))
	{
		return 'Q';
	}
	return 'c';
}


#define _CRT_SECURE_NO_WARNINGS 1
#include <stdio.h>
#include "game.h"

void menu()
{
	printf("**** 1.play  0.exit ****\n");
}

void game()
{
	char ret = 0;
	char board[ROW][COL] = {0};
	InitBoard(board, ROW, COL);
	DisplayBoard(board,ROW,COL);
	while (1)
	{
		Playermove(board,ROW,COL);     //玩家下棋
		DisplayBoard(board, ROW, COL); //显示棋盘
		ret = Iswin(board,ROW,COL);             //判断输赢
		if(ret != 'c')
		{
			break;
		}
		Computermove(board, ROW, COL);
		DisplayBoard(board, ROW, COL);
		ret = Iswin(board, ROW, COL);
		if (ret != 'c')
		{
			break;
		}
	}
	if (ret == '*')
	{
		printf("玩家赢\n");
	}
	else if (ret == '#')
	{
		printf("电脑赢\n");
	}
	else
	{
		printf("平局\n");
	}
}

void test()
{
	int input = 0;
	srand( (unsigned int) time(NULL) );
	do
	{
		menu();
		printf("请选择：");
		scanf("%d", &input);
		switch (input)
		{
		case 1:
			game();
			break;
		case 0:
			printf("退出游戏\n");
			break;
		default:
			printf("选择错误，重新选择：");
			break;
		}
	} while (input);
}




find· fish·
#pragma once
#include<stdio.h>
#define ROW 9
#define COL 9

#define ROWS ROW+2
#define COLS COL+2

#define EASY_COUNT 10

#include<stdlib.h>
#include<time.h>

void Initboard(char board[ROWS][COLS], int rows, int cols, char set);
void DisplayBoard(char board[ROWS][COLS], int row,int col);
void Setmine(char board[ROWS][COLS], int row, int col);
void Findmine(char mine[ROWS][COLS], char show[ROWS][COLS], int row, int col);
#define _CRT_SECURE_NO_WARNINGS 1
#include "game.h"


#define _CRT_SECURE_NO_WARNINGS 1
#include "game.h"

//初始化
void Initboard(char board[ROWS][COLS], int rows, int cols, char set)
{
	int i = 0;
	int j = 0;
	for (i = 0; i < rows; i++)
	{
		for (j = 0; j < cols; j++)
		{
			board[i][j] = set;
		}
	}
}

//打印棋盘
void DisplayBoard(char board[ROWS][COLS], int row, int col)
{
	int i = 0;
	int j = 0;
	for (i = 0; i <= col; i++) //打印列号
	{
		printf("%d ", i);
	}
	printf("\n");              //打印换行
	for (i = 1; i <= col; i++) //打印分割线
	{
		printf("~~");
	}
	printf("\n");
	for (i = 1; i <= row; i++)
	{
		printf("%d ", i);
		printf("|");
		for (j = 1; j <= col; j++)
		{
			printf("%c ", board[i][j]);
		}
		printf("\n");
	}
}

//放鱼(王老师）入塘
void Setmine(char board[ROWS][COLS], int row, int col)
{
	int count = EASY_COUNT;
	while (count)
	{
		int x = rand() % row + 1;
		int y = rand() % col + 1;
		if (board[x][y] == '0')
		{
			board[x][y] = '1';
			count--;
		}
	}
}

int get_mine_count(char mine[ROWS][COLS], int x, int y)
{
	//''里面是ASCII码，有'1'-'0'=1.利用该方法把字符1转换为数字1.
	return  mine[x - 1][y] +
			mine[x - 1][y - 1] +
			mine[x][y - 1] +
			mine[x + 1][y - 1] +
			mine[x + 1][y] +
			mine[x + 1][y + 1] +
			mine[x][y + 1] +
			mine[x - 1][y + 1] - 8 * '0';
}
void Findmine(char mine[ROWS][COLS], char show[ROWS][COLS], int row, int col)
{
	int x = 0;
	int y = 0;
	int win = 0;
	while (win<row*col - EASY_COUNT)
	{
		printf("请输入找鱼的坐标：（如1 1）");
		scanf_s("%d%d", &x, &y);
		if (x >= 1 && x <= 9 && y >= 1 && y <= 9)
		{
			//坐标合法
			if (mine[x][y] == '1')                  //只掉到一条
			{
				printf("很遗憾，其他鱼被吓跑了\n");
				DisplayBoard(mine, row, col);
				break;
			}
			else                                    //统计周围几条鱼,继续钓
			{
				int count = get_mine_count(mine, x, y);
				show[x][y] = count + '0';
				DisplayBoard(show, row, col);
				win++;
			}
		}
		else
		{
			printf("输入坐标错误，请重新输入！\n");
		}
	}
	if (win == row * col - EASY_COUNT)
	{
		printf("姜太公大获全胜！\n");
	}
}
void menu()
{
	printf("      find fish     \n");
	printf("找到鱼的位置并钓起它\n");
	printf("你是贪婪的姜太公，想要一次性钓走整个鱼塘的鱼\n");
	printf("拥有特殊技能的你，可以放下鱼竿并感知周围鱼的尾数\n");
	printf("如果鱼竿直接钓到鱼会吓跑其他鱼\n");
	printf("********************\n");
	printf("*****   1.play    **\n");
	printf("*****   0.exit    **\n");
	printf("********************\n");
}

void game()
{
	char mine[ROWS][COLS] = { 0 }; //11*11
	char show[ROWS][COLS] = { 0 };
	Initboard(mine, ROWS, COLS,'0');
	Initboard(show, ROWS, COLS,'*');
	DisplayBoard(show, ROW, COL);
	Setmine(mine, ROW, COL);
	//DisplayBoard(mine, ROW, COL);
	Findmine(mine, show, ROW, COL);
	printf("\n");
}

void test()
{
	int input = 0;
	srand((unsigned)time(NULL));
	do
	{
		menu();
		printf("请选择：");
		scanf_s("%d", &input);
		switch (input)
		{
		case 1:
			game();
			break;
		case 0:
			printf("退出游戏\n");
			break;
		default:
			printf("选择错误，重新选择\n");
			break;
		}
	} while (input);
}
int main()
{
	test();
	return 0;
}


操作符
算术操作符
int main()
{
	int a = 5 / 2; // 商二余一
	printf(" a = %d\n", a);
	return 0;
}

移位操作符
int main()
{
	int a = 16;
	a >> 1;           //算术右移操作符 0000000000010000(16位二进制数） 变成0000000000001000 右丢左补原符号位
	int b = a >> 1;   //逻辑右移。右丢左补0
	printf("%d\n", b);
	return 0;
}
int main()
{
	int a = -1;
	int b = a >> 2;
	printf("%d\n", b);  //整数存到内存中的是补码
	printf("%d\n", &a); //移位操作符不能移负数
	return 0;
}

位操作符
int main()
{
	int a = 3; //00000000000000000000000000000011
	int b = 5; //00000000000000000000000000000101
	int c = a & b; //00000000000000000000000000000001 按位与
	printf("%d\n", c);
	int d = 3;
	int f = 5;
	int e = d | f; //00000000000000000000000000000111 按位或
	printf("%d\n", e);
	int g = 3;
	int h = 5;
	int q = a ^ b; //00000000000000000000000000000110 按位异或
	printf("%d\n", q);
	return 0;
}

变态面试题：交换两个变量值不使用第三个变量。
int main()
{
	int a = 3;  //00000000000000000000000000000011
	int b = -4; //10000000000000000000000000000100
	//加减法（有缺陷，int范围内可能还行，遇到大数会溢出）
	a = a + b;  //a=-1
	b = a - b;  //b=3
	a = a - b;  //a=-4  实现交换   
	//异或法（不溢出）
	a = a ^ b;  //10000000000000000000000000000111
	b = a ^ b;  //00000000000000000000000000000011
	a = a ^ b;  //10000000000000000000000000000100 (a^b)^a=(a'b+ab')a'+(a'b+ab')'a=a'b+ab=b 实现交换
	return 0;
}

求一个整数存储在内存中的二进制中的二进制数中的个数
int main()                 //只能算正数
{
	int num = 0;
	int count = 0;
	scanf("%d", &num);
	while (num)
	{
		if (num % 2 == 1)
			count++;
		num = num / 2;
	}
	printf("%d\n", count);
	return 0;
}
int main()
{
	int num = 0;
	int count = 0;
	scanf_s("%d", &num);
	int i = 0;
	for (i = 0; i < 32; i++)
	{
		if (1 == ((num >> i) & 1))
			count++;
	}
	printf("%d\n", count);
	return 0;
}

赋值操作符
 = 赋值 可连续赋值但不推荐   ==是判断相等
复合赋值符
int main()
{
	int a = 10;
	a = a + 2;
	a += 2;

	a = a >> 1;
	a >>= 1;

	a = a & 1;
	a &= 1;
	return 0;
}

单目操作符
int main()
{
	int a = 10;
	if (a)
	{
		printf("哈哈\n");
	}
	if (!a)
	{
		printf("呵呵\n");
	}
	printf("%d\n", !a);    // !逻辑取反
	return 0;
}
int main()
{
	int a = 10;
	int*p=&a; //取地址操作符
	*p = 20;  //解引用操作符，指向地址内容
	return 0;
}
int main()
{
	int a = 10;
	char c = 'r';
	char* p = &c;
	int arr[10] = { 0 };
	printf("%d\n", sizeof(a));    //4
	printf("%d\n", sizeof(int));  //4
	printf("%d\n", sizeof(c));    //1
	printf("%d\n", sizeof(char)); //1
	printf("%d\n", sizeof(p));    //4
	printf("%d\n", sizeof(char*));//4
	printf("%d\n", sizeof(arr));  //40
	printf("%d\n", sizeof(int[10]));//40
	return 0;
}
int main()
{
	short s = 0;
	int a = 10;
	printf("%d\n", sizeof(s = a + 5));  //2
	printf("%d\n", s);                  //0
	return 0;
//}
int main()
{
	int a = 0;
	printf("%d\n",~a); //pirntf打印原码，按二进制位取反得到补码存在内存
	int b = 11;
	b = b | (1 << 2);  //按位或
	printf("%d\n", b);
	int c = 1;
	c = c & (~(1 << 2));
	printf("%d\n", a);
	return 0;
}
void test1(int arr[])
{
	printf("%d\n", sizeof(arr));
}
void test2(char ch[])
{
	printf("%d\n", sizeof(ch));
}
int main()
{
	int arr[10] = { 0 };
	char ch[10] = { 0 };
	printf("%d\n", sizeof(arr)); //40
	printf("%d\n", sizeof(ch)); //10
	test1(arr); //4
	test2(ch); //4  传的是指针，所以是数组首元素指针地址大小
	return 0;
}

逻辑操作符
int main()
{
	int i = 0, a = 0, b = 2, c = 3, d = 4;
	//i = a++ && ++b && d++;   // 逻辑短路，一旦第一个为假，后面都不执行。
	i = a++ || ++b || d++;     // 逻辑短路，第一个一旦为真，后面都不执行。
	printf("a=%d\n b=%d\n c=%d\n d=%d\n", a, b, c, d);
	return 0;
}

条件操作符
int main()
{
	int a = 0;
	int b = 0;
	if (a > 5)
		b = 3;
	else
		b = -3;
	b = (a > 5 ? 3 : -3); //三目操作符
	return 0;
}
int main()
{
	int a = 10;
	int b = 20;
	int max = 0;
	max = (a > b ? a : b); //选最大值
	return 0;
}

逗号表达式
int main()
{
	int a = 1;
	int b = 2;
	int c = (a > b, a = b + 10, a, b = a + 1); //从左向右依次执行,最后一个逗号表达式结果是整个的结果
	printf("%d\n", c);
	return 0;
}

下标引用操作符
int main()
{
	int a[10] = { 0 };
	a[4] = 10;
	1 + 2;
	return 0;
}

函数调用操作符()
int get_max(int x, int y)
{
	return (x > y ? x : y);
}
int main()
{
	int a = 0;
	int b = 20;
	int max = get_max(a, b); //操作数： 函数名+（参数）
	printf("max=%d\n", max);
	return 0;
}

结构体操作符
struct Stu
{
	char name[20];
	int age;
	char id[20];
};
int main()
{
	int a = 20;
	struct Stu s1 = { "张夏",20,"20211116" }; //用这个类型创建了一个学生对象，并初始化
	struct Stu* ps = &s1;
	printf("%s\n", (*ps).name);
	printf("%d\n", (*ps).age);
	printf("%s\n", s1.name);
	printf("%d\n", s1.age);
	printf("%s\n", s1.id);    //结构体变量.成员名
	printf("%s\n", ps->name); //结构体指针->成员名
	return 0;
}

表达式求值
隐式类型转换：C的整型算术运算总是以缺省整型类型的精度来进行。为了获得该精度，表达式中的字符和短整型操作数在使用之前被转换为普通整型（整型提升）
int main()
{
	char a = 3;         //00000000000000000000000000000011 a=00000011
	char b = 127;       //00000000000000000000000001111111 b=01111111
	char c = a + b;     //00000000000000000000000010000010 整型提升：按照变量数据类型的符号位提升，再相加。 
	printf("%d\n", c);  //截断后c=100000010 c的符号位变成1（负数） 补成11111111111111111111111110000010(补码） 输出原码10000000000000000000000001111110 -126
	return 0;
}
int main()
{
	char a = 0xb6;      //只能放一个字节，但是里面10110110
	short b = 0xb600;   //b理由类上
	int c = 0xb6000000;
	if (a == 0xb6)      //a整型提升，首位是1，提升后数与原值不符
		printf("a");
	if (b == 0xb600)
		printf("b");
	if (c == 0xb6000000)
		printf("c");
	return 0;
}
int main()
{
	char c = 1;
	printf("u\n", sizeof(c));   //1
	printf("%u\n", sizeof(+c)); //4 进行运算了，计算的是整型大小
	printf("%u\n", sizeof(!c)); //1
	return 0;
}

算术转换：操作符的各操作数属于不同类型，将占空间小的类型转换成大的进行运算。
操作符属性：优先级、结合性、是否控制求值顺序
int main()
{
	int a = 10;
	int b = 20;
	int c = b + a + 3;  //加号从左向右计算
	return 0;
}
逻辑与、逻辑或、逗号表达式、条件操作符会控制求值顺序！
歧义表达式：c + --c 导致左操作数的获取在右操作数之后，结果无法确定
非法表达式
int main()
{
	int i = 10;
	i = i-- - --i * (i = -3) * i++ + ++i; //不同编译器计算路径不同，结果不确定
	printf("i=%d\n", i);
	return 0;
int fun()
{
	static int count = 1;
	return ++count;
}
int main()
{
	int answer;
	answer = fun() - fun() * fun(); //先调用哪个fun函数不确定，调用顺序不同fun值不同
	printf("%d\n", answer);
	return 0;
}
int main()
{
	int i = 1;
	int a = (++i) + (++i) + (++i);
	printf("a = %d\n", a);
	return 0;
}
指针：编程语言中的一个对象，利用地址，它的值直接指向存在带闹闹存储器中另一个地方的值。将地址指向变量单元形象化为指针。
int main()
{
	int a = 0;   //在内存中开辟一块空间
	int* p = &a;  //取出变量a的地址，将其存放在指针变量p中。 指针变量中的值作为地址编号
	return 0;
}
int main() //指针类型，指针进行解引用操作的时候，能够访问空间大小。
{
	int a = 0x11223344;
	int c = 0x11223344;
	int* pa = &a;
	char* pc = &c;      //char不能放int的地址，报错。
	printf("%p\n", pa);
	*pa = 0; //4个都改变，int是四个字节
	*pc = 0; //只改变了一个，因为char是一个字节
	printf("%p\n", pc);
	return 0;
}
int main()   //指针类型决定了指针一步走多远
{
	int a = 0x11223344;
	int* pa = &a;
	char* pc = &a;
	printf("%p\n", pa);
	printf("%p\n", pa + 1); //4个字节
	printf("%p\n", pc);     
	printf("%p\n", pc + 1); //1个字节
	return 0;
}
int main()
{
	int arr[10] = { 0 };
	int* p = arr;
	char* p = arr;
	int i = 0;
	for (i = 0; i < 10; i++)
	{
		*(p + i) = 1;
	}
	return 0;
}

野指针：指针指向位置不可知
指针未初始化   ——要初始化
int main()
{
	int a;    //局部变量不初始化，默认随机值
	int* p;   //局部指针变量被初始化为随机值
	*p = 2;   //内存随机一个被初始化为2
	return 0;
}
 指针访问越界  ——小心越界
int main()
{
	int arr[10] = { 0 };
	int* p = arr;
	int i = 0;
	for (i + 0; i < 12; i++) //指针指向范围超出数组范围，p变成野指针。
	{
		*(p++)=i;
	}
	return 0;
}
 指针指向空间被释放  ——指向空间释放即使之置NULL 使用之前检查有效性
int* test()
{
	int a = 20;
	return &a;
}
int main()
{
	int* p=test(); //test中，指针指向的空间被释放了
	*p = 20;
	return 0;
}
int main()
{
	int a = 10;
	int* pa = &a;
	int* p = NULL;//空指针
	if (pa != NULL)
	{
		//指针使用
	}
	else
	{
		pa = NULL; //指针停用
	}
	return 0;
}

指针运算
指针+-整数
int main()
{
	int arr[10] = { 1,2,3,4,5,6,7,8,9,10 };
	int i = 0;
	int c = 0;
	int sz = sizeof(arr) / sizeof(arr[0]);
	int* p = arr;
	for (i = 0; i < 10; i++)
	{
		printf("%d ", *p);
		p = p + 1;  //可以等效为 p++；
	}
	for (c = 0; c < 5; c++)  //注意修改条件，不然发生越界
	{
		printf("%d ", *p);
		p = p += 2;  //1 3 5 7 9
	}
	return 0;
}
指针-指针
int main()
{
	int arr[10] = { 1,2,3,4,5,6,7,8,9,10 };
	printf("%d\n",& arr[9] - &arr[0]);  //大地址指针-小地址指针得到元素个数
	return 0;
}

int my_strlen(char* str)
{
	char* start = str;
	char* end = str;
	while (*end != '\0')
	{
		end++;
	}
	return end - start;
}
int main()  //模拟strlen函数
{
	char arr[] = "bit";
	int len = my_strlen(arr);
	printf("%d\n", len);
	return 0;
}

指针关系运算
#define N_VALUES 5
float values[N_VALUES];
float* vp;
   //允许指向数组元素的指针与指向数组最后一个元素后面的那个内存位置的指针比较，但不允许与指向第一个元素之前的那个内存位置的指针进行比较
for (vp = &values[N_VALUES]; vp > &values[0];)  
{
	*--vp = 0;
}

int main()
{
	int arr[10] = { 0 };
	printf("%p\n",arr);
	printf("%p\n", arr + 1); // +4

	printf("%p\n", &arr[0]); //数组地址——首元素地址
	printf("%p\n", &arr[0] + 1); // +4

	printf("%p\n", &arr);    //&arr-&数组名 数组名不是首元素地址，而是整个数组地址
	printf("%p\n", &arr + 1);  // +40
	//sizeof（arr）数组名表示整个数组，sizeof计算整个数组大小
	return 0;
}
int main()
{
	int arr[10] = { 0 };
	int* p = arr;
	int i = 0;
	for (i = 0; i < 10; i++)
	{
		printf("%d ", *(p + i) = i);
		//printf("%p ====== %p\n", p + i, &arr[i]); //指针形式打印数组
	}
	return 0;
}

二级指针
int main()
{
	int a = 10;
	int* pa = &a;
	int** ppa = &pa; // 此处ppa就是二级指针，存放指针的指针
	int*** pppa = &ppa; //pppa就是三级指针
	**ppa = 20;
	printf("%d\n", **ppa);
	printf("%d\n", a);
	printf("%p\n", &pppa);
	return 0;
}

指针数组 -数组
数组指针 -指针
int main()
{
	int a = 10;
	int b = 20;
	int c = 30;
	int* arr[3]={&a,&b,&c}; //指针数组
	int i = 0;
	for (i = 0; i < 3; i++)
	{
		printf("%d ", *(arr[i]));
	}
	return 0;
}

//创建一个数组，用函数初始化使其全0，打印数组每个元素
void init(int arr[], int sz)
{
	int i = 0;
	for (i = 0; i < sz; i++)
	{
		arr[i] = i+1;
	}
}
void print(int arr[], int sz)
{
	int i = 0;
	for (i = 0; i < sz; i++)
	{
		printf("%d ", arr[i]);
	}
	printf("\n");
}
void reverse(int arr[],int sz)
{
	int left = 0;
	int right = sz - 1;
	while (left < right)
	{
		int tmp = arr[left];
		arr[left] = arr[right];
		arr[right] = tmp;
		left++;
		right--;
	}
}
int main()
{
	int arr[10] = { 1,2,3,4,5,6,7,8,9,10 };
	int sz = sizeof(arr) / sizeof(arr[0]);
	init(arr, sz);
	print(arr, sz);
	reverse(arr, sz);
	print(arr,sz);
	return 0;
}
交换两个数组内的元素
void print(int arr[], int sz)
{
	int i = 0;
	for (i = 0; i < sz; i++)
	{
		printf("%d ", arr[i]);
	}
	printf("\n");
}
int main()
{
	int arr1[] = { 1,3,5,7,9 };
	int arr2[] = { 2,4,6,8,0 };
	int tmp = 0;
	int i = 0;
	int sz = sizeof(arr1) / sizeof(arr1[0]);
	for (i = 0; i < sz; i++)
	{
		tmp = arr1[i];
		arr1[i] = arr2[i];
		arr2[i] = tmp;
	}
	print(arr1, sz);
	print(arr2, sz);
	return 0;
}

int i; //全局变量不初始化，默认0
int main()
{
	i--;
	if (i > sizeof(i)) // sizeof计算变量/类型所占内存大小，是无符号数 -1变成2^32-1
	{
		printf(">\n");
	}
	else
	{
		printf("<\n");
	}
	return 0;
}

求二进制中不同位的个数
int main()
{

	return 0;
}

求二进制中1的个数
int count_bit_one(unsigned int n) //把有符号数转换成无符号数，就可以算负数了
{
	int count = 0;
	while (n)           //不能算负数
	{
		if (n % 2 == 1)
		{
			count++;
		}
		n = n / 2;
	}
	return count;
}
int count_bit_one(int n) //移位，按位与1
{
	int count = 0;
	int i = 0;
	for (i = 0; i < 32; i++)
	{
		if ((n >> i) & 1 == 1)
		{
			count++;
		}
	}
	return count;
}
打印二进制奇数位和偶数位
void print(int m)
{
	int i = 0;
	printf("奇数位: \n");
	for (i = 30; i >= 0; i -= 2)
	{
		printf("%d", (m >> i) & 1);
	}
	printf("\n");
	printf("偶数位: \n");
	for (i = 31; i >= 1; i -= 2)
	{
		printf("%d", (m >> i) & 1);
	}
	printf("\n");
}
int main()
{
	int m = 0;
	scanf("%d", &m);
	print(m);
	return 0;
}

用指针打印数组内容
void print(int* p, int sz)
{
	int i = 0;
	for (i = 0; i < sz; i++)
	{
		printf("%d", *(p + i));
	}
}
int main()
{
	int arr[] = { 1,2,3,4,5,6,7,8,9 };
	int sz = sizeof(arr) / sizeof(arr[0]);
	print(arr, sz);
	return 0;
}

nn乘法表
void print(int n)
{
	int i = 0;
	for (i = 0; i <= n; i++)
	{
		int j = 0;
		for (j = 0; j <= n; j++)
		{
			printf("%d x %d=%-3d ", i, j, i * j);
		}
		printf("\n");
	}
}
int main()
{
	int n = 0;
	scanf_s("%d", &n);
	print(n);
	return 0;
}
递归实现字符串逆序(不能使用库函数）
int my_strlen(char* str)  //替代库函数strlen
{
	int count = 0;
	while (*str != '\0')
	{
		count++;
		str++;
	}
	return count;
}
循环方式实现
void reverse_string(char arr[])
{
	int left = 0;
	int right = my_strlen(arr) - 1;  
	while (left < right)
	{
		int tmp = arr[left];
		arr[left] = arr[right];
		arr[right] = tmp;
		left++;
		right--;
	}
}
void reverse_string(char* arr)
{
	char tmp = arr[0];
	int len = my_strlen(arr);  
	arr[0] = arr[len - 1];
	arr[len - 1] = '\0';
	if (my_strlen(arr+1) >= 2)
		reverse_string(arr + 1);
	arr[len - 1] = tmp;
}
int main()
{
	char arr[] = "abcdef";
	reverse_string(arr);
	printf("%s\n", arr);
	return 0;
}

计算一个数的每位之和（递归）
int DigitSum(unsigned int num)
{
	if (num > 9)
	{
		return DigitSum(num/10) + num % 10;
	}
	else
	{
		return num;
	}
}
int main()
{
	unsigned int num = 0;
	scanf_s("%d", &num);
	int ret = DigitSum(num);
	printf("ret = %d\n", ret);
	return 0;
}

计算n^k的值
double Pow(int n,int k)
{
	if (k < 0)
		return (1 / (Pow(n, -k)));
	else if (k == 0)
		return 1;
	else
		return n * Pow(n, k - 1);
}
int main()
{
	int n = 0;
	int k = 0;
	scanf_s("%d%d", &n, &k);
	double ret = Pow(n,k);
	printf("ret = %lf\n", ret);
}
c语言调试
bug 臭虫，导致计算机出错。
调试Debug：除错，即找bug的过程。所有的bug都有迹可循，调试就是顺藤摸瓜。
基本步骤：
发现程序错误的存在    （程序员）bug写的少  （软件测试人员）bug找到的多    用户发现bug（代价巨大）
以隔离、消除等方式对错误进行定位
确定错误产生的原因
提出错误解决办法
对程序错误予以改正、重新测试
int main()                      //debug:调试版本  可以调试的
{                               //release：发布版本。有优化，体积小、运行速度快。测试测该版本
	int i = 0;
	for (i = 0; i < 100; i++)
	{
		printf("%d", i);
	}
	system("pause");
	return 0;
}
 F5启动调试
int main()
{
	int i = 0;
	int arr[10] = { 1,2,3,4,5,6,7,8,9,10 };  //debug版本： 死循环
	for (i = 0; i <= 12; i++)                //release版本： 13个hehe
	{
		printf("hehe\n");
		arr[i] = 0;
	}
	system("pause");
	return 0;
}
 F9断点，切换断点  
int main()
{
	int i = 0;
	for (i = 0; i < 100; i++)
	{
		printf("%d ", i);
	} 
	// 断点和F5：快速跳到要调试的部分。 F5跳到逻辑上遇到的下一个断点，再F10一步一步调试
	for (i = 0; i < 100; i++)
	{
		printf("%d ", 10 - i);
	}
	return 0;
}
 F11逐语句：不放过细节
int add(int x, int y)
{
	return x + y;      //看完了，shift F11跳出函数
}
int main()
{
	printf("hehe\n");
	int a = 10;
	int b = 20;
	int c = add(a, b);
}

int main()
{
	{
		int tmp = 0;
		printf("tmp=%d\n", tmp);
	}
	int arr[10] = { 0 };
	int i = 0;
	for (i = 0; i < 10; i++)
	{
		arr[i] = i;
	}

	return 0;
}
void test2()
{
	printf("hehe\n");
}
void test1()
{
	test2();
}
void test()
{
	test1();
}
int main()
{
	test();
	return 0;
}

实例1：求1！+2！+……+n！
int main()
{
	int i = 0;
	int sum = 0;
	int n = 0;
	int ret = 1;
	scanf_s("%d", &n);
	for (i = 1; i <= n; i++)
	{
		int j = 0;
		for (j = 1; j <= i; j++)
		{
			ret *= j;
		}
		sum += ret;
		ret = 1;
	}
	printf("%d\n", sum);
	return 0;
}

实例2 为啥死循环
int main()
{
	int i = 0;
	int arr[10] = { 1,2,3,4,5,6,7,8,9,10 };
	for (i = 0; i <= 12; i++)               //第一次循环结束后，i从12又变回0，重复变成死循环
	{                                       //改变arr[12]时，i变成0、 arr[12]与i是同一地址
		printf("hehe\n");                   //i，arr都属于局部变量放在栈区。栈区：先使用高地址空间，再使用低地址空间；数组随着下标增长，地址由低到高。
		arr[i] = 0;							//数组越界过程中，遇到了i的地址，并把它改成了0，从而重置了循环
	}										//vs中<=12 就死循环;但i如果创建在arr下面就不会死循环，但会报错。
	system("pause");
	return 0;
}

优秀代码
 运行正常、bug少、效率高、可读性高、可维护性高、注释清晰、文档齐全
技巧：使用assert、尽量用const、良好编码风格、必要注释、避免编码陷阱
范例：模拟库函数strcpy(字符串拷贝)
#include<assert.h> //断言：会报错
void my_strcpy(char* dest, const char* src)
{
	assert(dest != NULL);
	assert(src != NULL);
	while (*dest++ = *src++;)
	{
		;
	}
	*dest = *src;
}
int main()
{
	char arr1[] = "##########";
	char arr2[] = "bit";
	my_strcpy(arr1, arr2);
	printf("%s\n",arr1);
	return 0;
}
int main()
{
	const int num = 10;
	const int* p = &num;
	*p = 20; // error 放在指针变量左边时，修饰的是*p 不能通过p去修改num了。
	printf("%d\n", num);
}

 数据的存储
重点 ：数据类型、整型在内存中的存储、大小端字节序介绍及判断、浮点型在内存中的存储解析

1 数据类型详细介绍
 内置类型：系统自带的
char        //字符数据类型
short		//短整型
int			//整型
long		//长整型
long long   //更长的整型
float		//单精度浮点数
double		//双精度浮点数
 自定义类型（构造类型）
意义：类型决定开辟内存空间的大小，大小决定了适用范围。
int main()
{
	int a = 10;     //4字节
	float f = 10.0; //4字节
	return 0;
}
内置类型：
整型家族： 
char （unsigned char ,signed char)
short (unsigned short[int] ,signed short[int])
int   (unsigned int,signed int)
long  (unsigned long[int].signed long[int])
浮点型家族：
float  
double

构造类型：
数组类型
结构体类型 struct
枚举类型   enum
联合类型   union

指针类型
int*pi;
char*pc;
float*pf;
void*pv;  

空类型:无类型、无返回。通常应用于函数返回类型、函数参数、指针类型

整型在内存中的存储
int main()
{
	int a = 20;
	//00000000000000000000000000010100 原码 0x00000014 (0x表示十六进制)
	//正数三码合一
	int b = -10;
	//10000000000000000000000000001010 原码 
	//11111111111111111111111111110101 反码
	//11111111111111111111111111110110 补码 0xFFFFFFF6
	//内存中从右往左存补码 即F6 FF FF FF
	return 0;
}
原码、反码、补码
整型采用，无符号数三码相同
计算机系统中，数值一律用补码来表示和存储。原因：使用补码，可以将符号位和数值域统一处理；加法和减法也可以统一处理。此外，补码原码相互转换不需额外硬件电路。
int main()
{
	1 - 1;
	//1 + (-1)
	return 0;
}

大端小端：多个字节安排问题
大端（存储）模式：数据低位保存在内存高位，数据高位存在内存低位
小端（存储）模式：数据高位保存在内存高位，数据低位存在内存低位
简述大端字节序和小端字节序的概念，并设计小程序来判断当前机器进行的字节序
int check_sys()
{
	int a = 1;
	return *(char*)&a;   //返回1小端，返回0大端
}
int main()
{
	int ret = check_sys();
	if (*p == 1)
	{
		printf("小端\n");
	}
	else
	{
		printf("大端\n");
	}
	return 0;
}
int main()
{
	char a = -1;         //-1
	signed char b = -1;  //-1
	unsigned char c = -1;//255
	printf("a=%d b=%d c=%d", a, b, c);
	char d = -128;     //整型提升后11111111111111111111111110000000（补码） 无符号数三码合一
	printf("%u\n", d); // %u打印十进制无符号数
	return 0;
}
 10000000 = -128
有符号char 范围： -128——127
无符号char 范围： 0——255
int main()
{
	char a = 128; //相当于127+1 变回 -128 输出结果同char a =-128
	return 0;
}

int main()
{
	int i = -20;            //10000000 00000000 00000000 00010100原码
	unsigned int j = 10;    //00000000 00000000 00000000 00001010原码
	printf("%d\n", i + j);  //11111111 11111111 11111111 11110101补码  -10
	return 0;
}
#include<windows.h>
int main()
{
	unsigned int i;          // i永远大于等于0
	for (i = 9; i >= 0; i--) //死循环
	{
		printf("%u\n", i);
		Sleep(100);
	}
	return 0;
}
int main()
{
	char a[1000]; //char类型的数组，有1000个元素
	int i;
	for (i = 0; i < 1000; i++)
	{
		a[i] = -1 - i;
	}
	printf("%d", strlen(a));
	return 0;
}
unsigned char i = 0;
int main()
{
	for (i = 0; i <= 255; i++)
	{
		printf("hello world\n");
	}
	return 0;
}
浮点型在内存的存储
int main()
{
	int n = 9; //0000000 000000000 00000000 00001001
	float* pFloat = (float*)&n;
	printf("n的值：%d\n", n);
	printf("*pFloat的值：%f\n", *pFloat); //0 00000000 000000000001001 e=00000000 所以（-1）^0*0.000000000001001*2^-126
	*pFloat = 9.0; //1001.0  =(-1)^S*M*2^E = (-1)^1.001*2^3   0 10000010 00100000000000000000000
 //内存中：SEM 1+8+23（32bit)  1+11+52(64bit)
	printf("n的值：%d\n", n);  //01000001 00010000 00000000 00000000
	printf("*pFloat的值：%f\n", *pFloat);
	return 0;
}
int main()
{
	float f = 5.5; //101.1 = (-1)^0*2^2     s=0,m=1.011,e=2  0 10000001 01100000000000000000000=0x40b00000=00 00 b0 40
	return 0;
}

指针详解
void test(int arr[]) //首元素地址传过去了
{
	int xz = sizeof(arr) / sizeof(arr[0]);
	printf("%d\n", xz);  //2  指针大小/单个元素大小 8/4

}
int main()
{
	int arr[10] = { 0 };
	test(arr);
	return 0;
}
int main()
{
	char ch = 'w';
	char* pc = &ch;
	return 0;
}
int main()
{
	char arr[] = "abcdef";
	char* pc = arr;
	printf("%s\n", arr);
	printf("%s\n", pc);
	return 0;
}
int main()
{
	const char* p = "abcdef"; //"abcdef"是个常量字符串，将a的地址赋给p
	//printf("%c\n", p);
	//printf("%s\n", p);
	//*p = 'w'; // error *p是常量，不能修改
	//printf("%s\n", p);
	return 0;
}

字符指针
 int main()
{
char arr1[] = "abcdef";
char arr2[] = "abcdef";
const char* p1 = "abcdef"; //为了节省空间，无法修改的"abcdef"在内存中只有一个。所以p1，p2都指向同一地址
const char* p2 = "abcdef";
if (arr1 == arr2)
{
	printf("hehe\n");
}
else
{
	printf("haha\n");
}
if (p1 == p2)
{
	printf("hehe\n");
}
else
{
	printf("haha\n");
}
return 0;
}
 
 数组指针 是数组
int main()
{
	int arr[10] = { 0 }; //整型数组
	char ch[5] = { 0 };  //字符数组
	int* parr[4]; //存放整型指针的数组
	char* pch[5]; //存放字符指针的数组
	return 0;
}
int main()
{
	int a = 10;
	int b = 20;
	int c = 30;
	int d = 40;
	int* arr[4] = { &a,&b,&c,&d };
	int i = 0;
	for (i = 0; i < 4; i++)
	{
		printf("%d", *(arr[i]));
	}
	return 0;
}
int main()
{
	int arr1[] = { 1,2,3,4,5 };
	int arr2[] = { 2,3,4,5,6 };
	int arr3[] = { 3,4,5,6,7 };
	int* parr[3] = { arr1,arr2,arr3 };
	int i = 0;
	for (i = 0; i < 3; i++)
	{
		int j = 0;
		for (j = 0; j < 5; j++)
		{
			printf("%d ", *(parr[i] + j));
		}
		printf("\n");
	}
	return 0;
}

 数组指针 是指针
int main()
{
	int* p = NULL; //整型指针——指向整型的指针
	char* pc = NULL; //字符指针 —— 指向字符的指针
	// 数组指针 —— 指向数组的指针，存放数组的地址
	int arr[10] = { 1,2,3,4,5,6,7,8,9,10 };
	int (* p)[10] = &arr; //数组地址存起来 *p就是一个数组指针
	return 0;
}
int main()
{
	char* arr[5];
	char*(*pa)[5] = &arr; //数组类型+指针变量+数组元素个数 = &数组名（表示数组地址而不是首元素地址）；
	return 0;
}
int main()
{
	int arr[10] = { 1,2,3,4,5,6,7,8,9,10 };
	int(*pa)[10] = &arr;
	int i = 0;
	for (i = 0; i < 10; i++) //可以这么用，但不方便
	{
		printf("%d ", (*pa)[i]);
	}
	return 0;
}
void print1(int arr[3][5], int x, int y)
{
	int i = 0;
	int j = 0;
	for (i = 0; i < x; i++)
	{
		for (j = 0; j < y; j++)
		{
			printf("%d ", arr[i][j]);
		}
		printf("\n");
	}
}
void print2(int(*p)[5], int x, int y) //用数组指针传二维数组的第一行数组
{
	int i = 0;
	int j = 0;
	for (i = 0; i < x; i++)
	{
		for (j = 0; j < y; j++)
		{
			printf("%d ", *(*(p + i) + j)); //用指针（行地址+列地址）指向每个元素
			printf("%d ", p[i][j]); // 与上式等价
		}
		printf("\n");
	}
}
int main()
{
	int arr[3][5] = { {1,2,3,4,5},{2,3,4,5,6},{3,4,5,6,7} };
	print1(arr, 3, 5);
	print2(arr, 3, 5);
	return 0;
}
int main()
{
	int arr[10] = { 1,2,3,4,5,6,7,8,9,10 };
	int i = 0;
	int* p = arr;
	for (i = 0; i < 10; i++)
	{
		printf("%d ", *(p + i));
		printf("%d ", *(arr + i));
		printf("%d ", arr[i]);      // arr[i] == *(arr+i) == *(p+i) == p[i]
	}
}
小结
int main()
{
	char ch = 'w';
	char* p = &ch;
	const char* p2 = "abcdef";
	//指针数组 - 数组 - 存放指针的数组
	int* arr[10];
	char* ch[5];
	//数组指针
	//int* p3;   //整型指针
	//char* p4;  //字符指针
	int arr2[5]; //数组
	int(*pa)[5] = &arr2; 
	return 0;
}
  int* parr1 [10] //数组，有10个元素，每个元素是int类型的指针。 指针数组
  int  (*parr2) [10] //指针，指向了一个10元素数，每个元素类型是int. 数组指针
  int  (*parr3[10]) [5] //数组，数组有10个元素，每个元素是一个数组指针;指针指向5元素数组，每个元素是int。
 数组传参和指针传参
void test(int arr[]) // ok
{}
void test(int arr[10]) // ok
{}
void test(int* arr) // ok
{}
void test2(int*arr[20]) // ok 20可以省略
{}
void test2(int**arr) // ok
{}
int main()
{
	int arr[10] = { 0 };
	int* arr2[20] = { 0 };
	test(arr);
	test2(arr2);
}
void test(int arr[3][5])
{}
void test1(int arr[][5]) //不可以省略列
{}
void test2(int (*arr)[5])
{}
void test3(int*(*arr[5]))
{}
int main()
{
	int arr[3][5] = { 0 };
	test(arr); //二维数组传参
	return 0;
}

void print(int* p, int sz) //一级指针传参
{
	int i = 0;
	for (i = 0; i < sz; i++)
	{
		printf("%d\n", *(p + i));
	}
}
int main()
{
	int arr[10] = { 1,2,3,4,5,6,7,8,9 };
	int* p = arr;
	int sz = sizeof(arr) / sizeof(arr[0]);
	print(p, sz);
	return 0;
}
void test1(int* p)
{}
void test2(char*p)
{}
int mian()
{
	int a = 10;
	int* p1 = &a;
	test1(&a); // ok
	test1(p1); // ok
	char ch = 'w';
	char* pc = &ch;
	test2(&ch); //ok
	test2(pc); //ok
	return 0;
}
void test(int** ptr) //二级指针传参
{
	printf("num=%d\n", **ptr);
}
int mian()
{
	int n = 10;
	int* p = &n;
	int** pp = &p;
	test(pp);
	test(&p);
	return 0;
}
void test(int**p)
{}
int main()
{
	int* ptr;
	int** pp = &ptr;
	test(&ptr); //一级指针地址
	test(pp); // 二级指针本身
	int* arr[10];
	test(arr); //存放一级指针的数组
	return 0;
}

 函数指针：是指向函数的指针
int add(int x, int y)
{
	return x + y;
}
int main()
{
	int a = 0;
	int b = 10;
	int (* pa)(int,int) = add; //函数类型+指针变量+参数类型
	// &函数名和函数名 都是函数的地址
	printf("%d\n", add(a, b));
	printf("%p\n", &add);
	printf("%d\n", (*pa)(2, 3));
}
void print(const char* str)
{
	printf("%s\n", str);
}
int main()
{
	void (*p)(const char*)=print;
	(*p)("hello");
	return 0;
}
( *(void(*) () ) 0) ();
void (*signal( int, void(*)(int) )) (int);
typedef void(* pfun_t)(int); //函数声明
 pfun_t signal(int, pfun_t); //相当于1
 
 函数指针数组
int Add(int x, int y)
{
	return x + y;
}
int Sub(int x, int y)
{
	return x - y;
}
int Mul(int x, int y)
{
	return x * y;
}
int Div(int x, int y)
{
	return x / y;
}
int main()
{
	int* arr[5]; //指针数组
	int(*pa)(int, int) = Add;
	int(*parr[4])(int, int) = { Add,Sub,Mul,Div };
	int i = 0;
	for (i = 0; i < 4; i++)
	{
		printf("%d\n",parr[i](2, 3)); // 5 -1 6 0
	}
	return 0;
}
char* my_strcpy(char* dest, const char* src);
// 写一个函数指针pf，能够指向my_strcpy
char* (*pf)(char*, const char*);
// 写一个函数指针数组 pfArr，能够存放4个my_strcpy函数的地址
char* (*pfArr[4])(char*, const char*);
计算器
void menu()
{
	printf("******************\n");
	printf("**1.add    2.sub**\n");
	printf("**3.mul    4.div**\n");
	printf("**  0.退出程序  **\n");
	printf("******************\n");
}
int add(int x, int y)
{
	return x + y;
}
int sub(int x, int y)
{
	return x - y;
}
int mul(int x, int y)
{
	return x * y;
}
int div(int x, int y)
{
	return x / y;
}
int main()
{
	int input = 0;
	int x = 0;
	int y = 0;
	int(*pfArr[5])(int, int) = { 0,add,sub,mul,div }; // 用作转移表
	do
	{
		menu();
		printf("请选择：");
		scanf_s("%d", &input);
		if (input >= 1 && input <= 4)
		{
			printf("请输入两个操作数：");
			scanf_s("%d%d", &x, &y);
			int ret = pfArr[input](x, y);
			printf("%d\n", ret);
		}
		else if (input == 0)
		{
			printf("退出\n");
		}
		else
		{
			printf("选择错误！\n");
		}
	} while (input);
	return 0;
}

int main() //冗余
{
	int input = 0;
	int x = 0;
	int y = 0;
	do
	{
		menu();
		printf("请选择:\n");
		scanf_s("%d", &input);

		switch (input)
		{
		case 1:
			printf("%d\n", add(x, y));
			printf("请输入两个操作数:");
			scanf_s("%d%d", &x, &y);
			break;
		case 2:
			printf("%d\n", sub(x, y));
			printf("请输入两个操作数:");
			scanf_s("%d%d", &x, &y);
			break;
		case 3:
			printf("%d\n", mul(x, y));
			printf("请输入两个操作数:");
			scanf_s("%d%d", &x, &y);
			break;
		case 4:
			printf("%d\n", div(x, y));
			printf("请输入两个操作数:");
			scanf_s("%d%d", &x, &y);
			break;
		case 0:
			printf("请输入两个操作数:");
			scanf_s("%d%d", &x, &y);
			printf("退出\n");
			break;
		default:
			printf("输入错误，请重输！");
		}
	} while (input);
	return 0;
}
 指向函数指针数组的指针
int Add(int x, int y)
{
	return x + y;
}
int main()
{
	int arr[10] = { 0 };
	int(*p)[10] = &arr; //取出数组的地址
	int (*pfArr[4])(int, int); //指针数组
	int(*(*ppfArr)[4])(int, int) = &pfArr; //ppfArr是一个数组指针，指针指向的数组有4个元素。指向数组的元素类型是函数指针
	return 0;
}

 回调函数：通过函数指针调用的函数。
 回调函数不是由该函数的实现方直接调用，而是在特定事件或条件发生时由另外一方调用的，用于对该事件或条件进行响应。
void calc(int (*pf)(int, int))
{
	int x = 0;
	int y = 0;
    printf("请输入两个操作数:");
	scanf_s("%d%d", &x, &y);
	printf("%d\n", pf(x, y));
}
void print(const char* str)
{
	printf("hehe:%s", str);
}
void test(void(*p)(const char*))
{
	printf("test\n");
	p("bit");
}
int main()
{
	test(print);
	return 0;
}
void BubbleSort(int arr[], int sz)
{
	//冒泡排序函数，只能排整型数组
}
//qsort:可以排序任意类型的数据
//void qsort(void* base, size_t num, size_t width, int(*cmp)(const void* e1, const void* e2))
#include <stdlib.h>
int cmp_int (const void* e1,const void* e2) // void*类型的指针可以接受任意类型的地址
{
	return *(int*)e1 - *(int*)e2;
}
void test1()
{
	int arr[] = { 1,3,5,7,9,2,4,6,8,10 };
	int sz = sizeof(arr) / sizeof(arr[0]);
	qsort(arr, sz, sizeof(arr[0]), cmp_int);
	int i = 0;
	for (i = 0; i < sz; i++)
	{
		printf("%d ", arr[i]);
	}
}
int cmp_float(const void* e1, const void* e2) // void*类型的指针可以接受任意类型的地址
{
	return ((int)( * (float*)e1 - *(float*)e2));
}
void test2()
{
	float f[] = { 9.0, 8.0, 7.0, 5.0, 10.0 };
	int sz = sizeof(f) / sizeof(f[0]);
	qsort(f, sz, sizeof(f[0]), cmp_float);
	int j = 0;
	for (j = 0; j < sz; j++)
	{
		printf("%f ", f[j]);
	}
}
struct stu
{
	char name[20];
	int age;
};
int cmp_stu_by_age(const void* e1, const void* e2)
{
	return ((struct stu*)e1)->age - ((struct stu*)e2)->age;
}
#include<string.h>
int cmp_stu_by_name(const void* e1, const void* e2)
{
	return strcmp(((struct stu*)e1)->name, ((struct stu*)e1)->name);  //字符串比较不能直接用大于小于比较，应该用strcmp
}
void test3()
{
	struct stu s[3] = { {"zhangsan",20},{"lisi",30},{"wangwu",15} };
	int sz = sizeof(s) / sizeof(s[0]);
	qsort(s, sz, sizeof(s[0]), cmp_stu_by_age);
}
void test4()
{
	struct stu s[3] = { {"zhangsan",20},{"lisi",30},{"wangwu",15} };
	int sz = sizeof(s) / sizeof(s[0]);
	qsort(s, sz, sizeof(s[0]), cmp_stu_by_name);
}
void Swap(char* buf1, char* buf2, int width)
{
	int i = 0;
	for (i = 0; i < width; i++)
	{
		char tmp = *buf1;
		*buf1 = *buf2;
		*buf2 = tmp;
		buf1++;
		buf2++;
	}
}
void bubble_sort(void* base, int sz, int width,int (*cmp)(const void*e1,const void*e2))
{
	int i = 0;
	for (i = 0; i < sz - 1; i++)
	{
		int j = 0;
		for (j = 0; j < sz - 1 - i; j++)
		{
			if (cmp((char*)base + j * width, (char*)base + (j + 1) * width) > 0)
			{
				Swap((char*)base+j*width,(char*)base+(j+1)*width,width);
			}
		}
	}
}
void test5()
{
	int arr[10] = { 9,8,7,6,5,4,3,2,1,0 };
	int sz = sizeof(arr) / sizeof(arr[0]);
	bubble_sort(arr,sz,sizeof(arr[0]),cmp_int);
	int i = 0;
	for (i = 0; i < sz; i++)
	{
		printf("%d ", arr[i]);
	}
}
int main()
{
	test1();
	test2();
	test3();
	test5();
	//BubbleSort(arr, sz);
	return 0;
}
指针和数组面试题解析
int main()
{
	//int a[] = { 1,2,3,4 };
	//printf("%d\n", sizeof(a));      //16   数组
	//printf("%d\n", sizeof(a+0));	//4/8  此处a表示首元素地址，+0还是首元素地址
	//printf("%d\n", sizeof(*a));		//4    首元素
	//printf("%d\n", sizeof(a+1));	//4/8  第二个元素地址
	//printf("%d\n", sizeof(a[1]));	//4    第二个元素
	//printf("%d\n", sizeof(&a));		//4/8  取出的是数组的地址，地址大小还是4
	//printf("%d\n", sizeof(*&a));	//16   抵消，还是数组
	//printf("%d\n", sizeof(&a+1));	//4/8  虽然跳过整个数组，但还是地址
	//printf("%d\n", sizeof(&a[0]));	//4/8  第一个元素的地址
	//printf("%d\n", sizeof(&a[0]+1));//4/8  第二个元素地址

	//char arr[] = { 'a','b','c','d','e','f' };
	//printf("%d\n", sizeof(arr));        //6  6*1bit
	//printf("%d\n", sizeof(arr + 0));	//4/8 首元素地址
	//printf("%d\n", sizeof(*arr));		//1   首元素地址解引用，计算首元素大小
	//printf("%d\n", sizeof(arr[1]));	    //1   第二个元素
	//printf("%d\n", sizeof(&arr));		//4/8
	//printf("%d\n", sizeof(&arr + 1));	//4/8
	//printf("%d\n", sizeof(&arr[0] + 1));//4/8

	char arr[] = { 'a','b','c','d','e','f' };
	printf("%d\n", strlen(arr));       //随机值 strlen计算字符串长度，找到\0才停止
	printf("%d\n", strlen(arr+0));	   //随机值
	printf("%d\n", strlen(*arr));	   //error 将'a'转换成ASCII码 97 访问0x00000097地址
	printf("%d\n", strlen(arr[1]));    //error
	printf("%d\n", strlen(&arr));      //随机值
	printf("%d\n", strlen(&arr+1));    //随机值，与上一个随机值-6
	printf("%d\n", strlen(&arr[0]+1)); //随机值，与上一个随机值+5
	return 0;
}

int main()
{
	char arr[] = "abcdef";
	printf("%d\n", sizeof(arr));       //7   a b c d e f \0
	printf("%d\n", sizeof(arr+0));	   //4/8 首元素地址大小
	printf("%d\n", sizeof(*arr));	   //1   首元素大小
	printf("%d\n", sizeof(arr[1]));	   //1   第二元素大小
	printf("%d\n", sizeof(&arr));	   //4/8 数组地址大小
	printf("%d\n", sizeof(&arr+1));	   //4/8 跳过整个数组后的地址
	printf("%d\n", sizeof(&arr[0]+1)); //4/8 第二个元素地址

	printf("%d\n", strlen(arr));       //6   a b c d e f
	printf("%d\n", strlen(arr+0));	   //6   从首元素开始往后算，一共6个
	printf("%d\n", strlen(*arr));	   //error
	printf("%d\n", strlen(arr[1]));	   //error  把第二个字符的ASCII值当作地址，依然非法访问
	printf("%d\n", strlen(&arr));	   //6      数组起始地址往后计算字符长度
	printf("%d\n", strlen(&arr+1));	   //随机值 跳过整个数组后的地址
	printf("%d\n", strlen(&arr[0]+1)); //5      第二个元素地址开始往后计算              

	const char* p = "abcdef";
	printf("%d\n", sizeof(p));          //4/8  指针变量大小
	printf("%d\n", sizeof(p + 1));      //4/8  第二个字符的地址
	printf("%d\n", sizeof(*p));         //1    首字符大小
	printf("%d\n", sizeof(p[0]));       //1    p[0] == *(p+0) =='a'
	printf("%d\n", sizeof(&p));         //4/8  取地址，计算地址大小
	printf("%d\n", sizeof(&p + 1));     //4/8  还是地址
	printf("%d\n", sizeof(&p[0] + 1));  //4/8  取b的地址
	 
	printf("%d\n", strlen(p));          //6
	printf("%d\n", strlen(p + 1));      //5
	printf("%d\n", strlen(*p));         //error
	printf("%d\n", strlen(p[0]));       //error
	printf("%d\n", strlen(&p));         //6
	printf("%d\n", strlen(&p + 1));     //随机值
	printf("%d\n", strlen(&p[0] + 1));  //5
	return 0;
}

二维数组
int main()
{
	int a[3][4] = { 0 };
	printf("%d\n", sizeof(a));           //48   3*4*4
	printf("%d\n", sizeof(a[0][0]));     //4    首行首元素
	printf("%d\n", sizeof(a[0]));        //16   4*4 a[0]单独放入sizeof作为一维数组，计算第一行大小
	printf("%d\n", sizeof(a[0]+1));      //4/8  a[0]+1作为第一行第二个元素的地址。a[0]是第一行的数组名，放在表达式是代表首元素地址
	printf("%d\n", sizeof(*(a[0]+1)));   //4    第一行第二个元素的大小
	printf("%d\n", sizeof(a+1));         //4/8  第二行数组的地址，计算的是地址大小
	printf("%d\n", sizeof(*(a+1)));      //16   第二行数组的大小
	printf("%d\n", sizeof(&a[0]+1));     //4    第二行的地址
	printf("%d\n", sizeof(*(&a[0]+1)));  //16   计算第二行大小
	printf("%d\n", sizeof(*a));          //16   计算第一行大小
	printf("%d\n", sizeof(a[3]));        //16   计算第四行大小。 sizeof不访问数组内容，只计算数组大小
}

 test1
int main()
{
	int a[5] = { 1,2,3,4,5 };
	int* ptr = (int*)(&a + 1);
	printf("%d,%d\n", *(a + 1), *(ptr - 1)); // 2,5
	return 0;
}

 test2
假设p的值为0x100000,如下表达式的值分别为多少？
已知结构体类型变量大小是20个字节。
struct Test
{
	int Num;
	char* pcName;
	short sDate;
	char cha[2];
	short sBa[4];
}*p;
int main()
{
	p = (struct Test*) 0x100000;
	printf("%p\n", p + 0x1);                //0x100014 跳过一个结构体20个字节，十六进制就是14
	printf("%p\n", (unsigned long)p + 0x1); //0x100001 整数+1
	printf("%p\n", (unsigned int*)p + 0x1); //0x100004 地址+1
	return 0;
}

test3
int main()
{
	int a[4] = { 1,2,3,4 };
	int* ptr1 = (int*)(&a + 1);       //数组地址+1，再强行转换成整型地址
	int* ptr2 = (int*)((int)a + 1);   //首元素地址强行转换成整数，+4bit后强行转换成整型地址
	printf("%x,%x", ptr1[-1], *ptr2); //ptr1[1] == *(ptr1+(-1)) , 小端存储后移一位再还原回去 
	return 0;
}

test4
int main()
{
	int a[3][2] = { (0,1),(2,3),(4,5) }; //(,)逗号表达式，数组里实际是{1,3,5}
	int* p;
	p = a[0];
	printf("%d", p[0]);
	return 0;
}

test5
int main()
{
	int a[5][5]; //二维数组
	int(*p)[4];  //数组指针，指向四个整型元素的数组
	p = (int(*)[4])a; //将a强制转换为p的类型
	printf("%p,%d\n", &p[4][2] - &a[4][2], &p[4][2] - &a[4][2]);
	return 0;
}

test6
int main()
{
	int aa[2][5] = { 1,2,3,4,5,6,7,8,9,10 };
	int* ptr1 = (int*)(&aa + 1);
	int* ptr2 = (int*)(*(aa + 1));
	printf("%d,%d\n", *(ptr1 - 1), *(ptr2 - 1)); //
	return 0;
}

test7
int main()
{
	const char* a[] = { "work","at","alibaba" }; // {char* w,char*a,char*a}
	const char** pa = a;                         // char*(*pa) = char*a (char*w)
	pa++;                                        //指向char*a
	printf("%s\n", *pa); //at                    
	return 0;
}

test8
int main()
{
	const char* c[] = { "ENTER", "NEW", "POINT", "FIRST" };  // {char*E,char*N,char*P,char*F}
	const char** cp[] = { c + 3,c + 2,c + 1,c };             // {char*F,char*P,char*N,char*E}
	const char*** cpp = cp;                                  // char*(**cpp) = char** cp的首元素 （char*F)
	printf("%s\n", **++cpp);       // 同优先级，右到左。 **（++cpp)  point  注意：++会保留计算结果
	printf("%s\n", *--*++cpp+3);   // *(--(*(++cpp))) +3  从c+1开始 ++ 到c+2指向NEW --z指向 ENTER +3到ER
	printf("%s\n", *cpp[-2]+3);    // 从c+2开始 -2指向FIRST +3到ST
	printf("%s\n", cpp[-1][-1]+1); // 从c+2开始  *(*（cpp-1)-1) = NEW   +1到EW 
	return 0;
}
指针
  1
int main()
{
	unsigned long pulArray[] = { 6,7,8,9,10 };
	unsigned long* pulPtr;
	pulPtr = pulArray;
	*(pulPtr + 3) += 3; //指向9，再加上3，得12
	printf("%d,%d", *pulPtr, *(pulPtr + 3));
	return 0;
}
 2 写一个函数，可以逆序字符串内容
void reverse(char* str)
{
	assert(str);
	int len = strlen(str);
	char* left = str;
	char* right = str + len - 1;
	while (left < right)
	{
		char tmp = *left;
		*left = *right;
		*right = tmp;
		left++;
		right--;
	}
}
int main()
{
	char arr[256] = { 0 };
	scanf_s("%s", arr); //遇到空格会停止
	//gets(arr); //读取一行
	reverse(arr);
	printf("%s\n", arr);
	return 0;
}

 3 
 int main()
{
	int a = 0;
	int n = 0;
	scanf_s("%d%d", &a, &n);
	int sum = 0;
	int ret = 0;
	int i = 0;
	for (i = 0; i < n; i++)
	{
		ret = ret * 10 + a;
		sum += ret;
	}
	printf("%d", sum);
	return 0;
}
 4 水仙花数
int main()
{
	int i = 0;
	for (i = 0; i <= 100000; i++)
	{
		//计算i的位数
		int n = 1;
		int tmp = i;
		int sum = 0;
		while (tmp /= 10)
		{
			n++;
		}
		//计算每一位的n次方和
		tmp = i;
		while (tmp)
		{
			sum += (int)pow(tmp % 10, n);
			tmp /= 10;
		}
		//比较i ==sum
		if(i == sum)
		{
			printf("%d ",i);
		}
	}
	return 0;
}

 5 打印菱形
int main()
{
	int line = 0;
	//int k = 0;
	scanf_s("%d", &line);//奇数
	//if (line % 2 != 0)
	//{
	//	int k = line;
	//}
	//else
	//{
	//	printf("输入错误，请输入奇数");
	//}
	int i = 0;
	//打印上半部分
	for (i = 0; i < line; i++)
	{
		int j = 0;
		for (j = 0; j < line - 1 - i; j++)
		{
			printf(" ");
		}
		for (j = 0; j < 2 * i + 1; j++)  
		{
			printf("*");
		}
		printf("\n");
	}
	//打印下半部分
	for (i = 0; i < line; i++)
	{
		int j = 0;
		for (j = 0; j <= i; j++)
		{
			printf(" ");
		}
		for (j = 0; j < 2 * (line - 1 - i) - 1; j++)
		{
			printf("*");
		}
		printf("\n");
	}
	return 0;
}
结构体
 1  喝汽水，1瓶1元，两个空瓶换一瓶，20元喝几瓶?
int main()
{
	int money = 0;
	int total = 0;
	int empty = 0;
	scanf_s("%d", &money);
	//买回的汽水喝掉
	total = money;
	empty = money;
	//换回汽水
	while (empty >= 2)
	{
		total += empty / 2;
		empty = empty / 2 + empty % 2;
	}
	printf("%d\n", total);
	return 0;
}

调试
 1 奇偶交换顺序
void print(int arr[], int sz)
{
	int i = 0;
	for (i = 0; i < sz; i++)
	{
		printf("%d ", arr[i]);
	}
	printf("\n");
}
void move(int arr[], int sz)
{
	int left = 0;
	int right = sz - 1;
	while (left<right) 
	{
		while ((left < right) && arr[left] % 2 == 1) //从左找偶数
		{
			left++;
		}
		while ((left < right) && arr[right % 2 == 0])//从右找奇数
		{
			right--;
		}
		if (left = right)
		{
			int tmp = arr[left];
			arr[left] = arr[right];
			arr[right] = tmp;
		}
	}

}
int main()
{
	int arr[] = { 1,2,3,4,5,6,7,8,9,10 };
	int sz = sizeof(arr) / sizeof(arr[0]);
	move(arr,sz);
	print(arr, sz);
	return 0;
}

 数据存储
 1
int main()
{
	unsigned char a = 200; //能放0-255
	unsigned char b = 100;
	unsigned char c = 0;
	c = a + b; //放不下300，溢出300 -（255+1）=44
	printf("%d %d", a + b, c);
	return 0;
}

 2 打印杨辉三角
int main()
{
	int arr[10][10] = { 0 };
	int i = 0;
	int j = 0;
	for (i = 0; i < 10; i++)
	{
		for (j = 0; j < 10; j++)
		{
			if (j == 0)
			{
				arr[i][j] = 1;
			}
			if (i == j)
			{
				arr[i][j] = 1;
			}
			if (i >= 2 && j >= 1)
			{
				arr[i][j] = arr[i - 1][j] + arr[i - 1][j - 1];
			}
		}
	}
	for (i = 0; i < 10; i++)
	{
		for (j = 0; j <= i; j++)
		{
			printf("%d ", arr[i][j]);
		}
		printf("\n");
	}
	return 0;
}

 3 判案，四个人里面找凶手
int main()
{
	int killer = 0;
	for (killer = 'a'; killer <= 'd'; killer++)
	{
		if ((killer != 'a') + (killer == 'c') + (killer == 'd') + (killer != 'd') == 3)
		{
			printf("killer =%c\n", killer);
		}
	}
	return 0;
}

 4 赛马问题：36匹马，6个跑道。没有计时器，赛马确定，36匹马中的前三名，最少比赛几次. 8
 5烧香问题：一根香，材质不均，但是烧完正好是一个小时。现有两根香，如何确定一刻钟。 第一根两头烧，同时第二根点燃一端；第一根烧完时，点燃第二根的另一端。
 4 猜名次，5个跳水运动员猜名次
int main()
{
	int a = 0;
	int b = 0;
	int c = 0;
	int d = 0;
	int e = 0;
	for (a = 1; a <= 5; a++)
	{
		for (b = 1; b <= 5; b++)
		{
			for (c = 1; c <= 5; c++)
			{
				for (d = 1; d <= 5; d++)
				{
					for (e = 1; e <= 5; e++)
					{
						if (((b == 2) + (a == 3) == 1) &&
							((b == 2) + (e == 4) == 1) &&
							((c == 1) + (d == 2) == 1) &&
							((c == 5) + (d == 3) == 1) &&
							((e == 4) + (a == 1) == 1))
						{
							if(a*b*c*d*e == 120)
							printf("a=%d b=%d c=%d d=%d e=%d\n", a, b, c, d, e);
						}
					}
				}
			}
		}
	}
	return 0;
}

字符指针
 1 
#include<stdlib.h>
int main()
{
	int* p = (int*)malloc(10 * sizeof(int)); //申请内存空间
	free(p); //释放空间
	p = NULL;
	return 0;
}

 2 三步翻转法
void reverse(char* left,char* right)
{
	assert(left != NULL);
	assert(right != NULL);
	while (left<right)
	{
		char tmp = *left;
		*left = *right;
		*right = tmp;
		left++;
		right--;
	}
}
void left_move(char* arr, int k)
{
	assert(arr);
	int len = strlen(arr);
	assert(k <= len);
	reverse(arr,arr+k-1); //逆序左边
	reverse(arr+k,arr+len-1); //逆序右边
	reverse(arr,arr+len-1); //逆序整体
}
int main()
{
	char arr[] = "abcdef";
	left_move(arr,2);
	printf("%s\n", arr);
	return 0;
}

int is_left_move(char* s1, char* s2)
{
	int len = strlen(s1);
	int i = 0;
	for (i = 0; i < len; i++)
	{
		left_move(s1, i);
		int ret = strcmp(s1, s2);
		if (ret == 0)
		{
			return 1;
		}
	}
	return 0;
}
int main()
{
	char arr1[] = "abcdef";
	char arr2[] = "cdefab";
	int ret = is_left_move(arr1, arr2);
	if (ret == 1)
	{
		printf("yes\n");
	}
	else
	{
		printf("no\n");
	}
	return 0;
}
 解法2
int is_left_move(char* str1, char* str2)
{
	int len1 = strlen(str1);
	int len2 = strlen(str2);
	if (len1 != len2)
		return 0;
	//strcat(str1, str1); //自己给自己追加会无限追加
	strncat(str1, str1, 6);
	char*ret = strstr(str1, str2); //找str1里面有没有str2
	if (ret == NULL)
	{
		return 0;
	}
	else
	{
		return 1;
	}
}
int main()
{
	char arr1[] = "abcdef";
	char arr2[] = "cdefab";
	int ret = is_left_move(arr1, arr2);
	if (ret == 1)
	{
		printf("yes\n");
	}
	else
	{
		printf("no\n");
	}
	return 0;
}

 3 矩阵找数，时间复杂度小于O(N)
int FindNum(int arr[3][3], int k, int* px, int* py)
{
	int x = 0;
	int y = *py - 1;
	while (x <= *px - 1 && y >= 0)
	{
		if (arr[x][y] > k)
		{
			y--;
		}
		else if (arr[x][y] < k)
		{
			x++;
		}
		else
		{
			*px = x;
			*py = y;
			return 1;
		}
	}
}
int main()
{
	int arr[3][3] = { {1,2,3},{4,5,6},{7,8,9} };
	int k = 7;
	int x = 3;
	int y = 3;
	int ret = FindNum(arr, k, &x, &y);
	if (ret == 1)
	{
		printf("找到了\n");
		printf("(%d,%d)\n", x, y);
	}
	else
	{
		printf("没找到\n");
	}
	return 0;
}
 字符串函数的使用和剖析
 前言： c语言对字符和字符串函数的处理很频繁，但没有字符串类型。通常是放在 常量字符串或字符数组 中。 字符串常量适合对它不做修改的字符串函数

求字符串长度
int my_strlen(const char* str)
{
	assert(str != NULL);
	int count = 0;
	while (*str != '\0')
	{
		count++;
		str++;
	}
	return count;
}
// 如何不创建临时变量来实现my_strlen? 递归写法
int main()
{
	int len = strlen("abcdef");
	char arr[] = { 'a', 'b', 'c', 'd', 'e', 'f' }; // 缺少\0
	int len1 = my_strlen(arr);
	printf("%d\n", len);
	printf("%d\n", len1);
	if (strlen("abc") - strlen("abcdef") > 0)
	{
		printf("hehe\n"); // strlen的返回类型是size_t，而不是int。 size_t本质就是unsigned int。
	}
	else
	{
		printf("haha\n");
	}
	return 0;
}

长度不受限制的字符串函数
 strcpy
char* my_strcpy(char* dest, char* src)
{
	assert(dest != NULL);
	assert(src != NULL);
	char* ret = dest; //拷贝目标空间的起始地址
	while (*dest++ = *src++) // 拷贝src指向的字符串到dest指向的空间，包含'\0'
	{
		;
	}
	return ret; //返回起始地址
}
int main()
{
	char arr1[] = "abcdefghi";
	char arr2[] = "bit";
	//strcpy(arr1, arr2); // strcpy(目标数组，源数组)
	my_strcpy(arr1, arr2);
	printf("%s\n", arr1);
	return 0;
}
 strcat
char* my_strcat(char* dest,const char* src)
{
	assert(dest != NULL);
	assert(src != NULL);
	char* ret = dest;
	while (*dest != '\0')
	{
		dest++;
	}
	while (*dest++ = *src++)
	{
		;
	}
	return ret;
}
int main()
{
	//char arr1[] = "hello"; //空间不够放bit
	char arr1[30] = "hello\0xxxx"; //arr2从\0开始往后追加
	char arr2[] = "bit";
	strcat_s(arr1, arr2); // 将arr2的内容追加到arr1的后面
	printf("%s\n", arr1);
	return 0;
}
 strcmp
int main()
{
	const char* p1 = "abcdef";
	const char* p2 = "sqwer";
	int ret = strcmp(p1, p2); //从首字符开始比较对应字符的ASCII码大小 ，相等时输出0
	if (ret > 0)
	{
		printf("p1>p2\n");
	}
	else if (ret == 0)
	{
		printf("p1=p2\n");
	}
	else
	{
		printf("p1<p2\n");
	}
	printf("%d\n", ret);
	return 0;
}
int my_strcmp(const char* str1, const char* str2)
{
	assert(str1 && str2 != NULL);
	while (*str1 == *str2)
	{
		if (*str1 == '\0') //比较到字符串结尾了，说明字符串相等
		{
			return 0;
		}
		str1++;
		str2++;
	}
	if (*str1 > *str2)
	{
		return 1;
	}
	else
	{
		return -1;
	}
	// return (*str1 - *str2）;
}
int main()
{
	const char* p1 = "abcdef";
	const char* p2 = "abqwe";
	int ret = my_strcmp(p1, p2);
	printf("%d\n", ret);
	return 0;
}
 容易变得不安全(越界、目标空间放不下等问题）
// 字符串查找
const char* my_strstr(const char* p1,const char* p2)
{
	assert(p1 != NULL);
	assert(p2 != NULL);
	char* s1 = NULL;
	char* s2 = NULL;
	char* cur = (char*) p1;
	if (*p2 == '\0')
	{
		return p1;
	}
	while (*cur)
	{
		s1 = cur;
		s2 = (char*)p2;
		while (*s1 && *s2 && (*s1 - *s2))
		{
			s1++;
			s2++;
		}
		if (*s2 == '\0')
		{
			return cur;
		}
		cur++;
	}
	return NULL; // 找不到子串
}
int main()
{
	const char* p1 = "abcdefghi";
	const char* p2 = "defq";
	const char* ret = strstr(p1, p2);
	if (ret == NULL)
	{
		printf("子串不存在\n");
	}
	else
	{
		printf("%s\n", ret);
	}
	return 0;
}
int main()
{
	char arr[] = "365206624@qq.com";
	char* next_token = NULL;
	const char* p = "@.";

	char buf[1024] = { 0 };
	strcpy_s(buf, arr);
	// 切割buf中的字符串
	char* ret = NULL;
	for (ret = strtok_s(arr, p, &next_token); ret != NULL; ret = strtok_s(NULL, p,&next_token))
	{
		printf("%s\n", ret);
	}
	//char*ret = strtok_s(arr, p, &next_token);
	//printf("%s\n", ret);

	//ret = strtok_s(NULL, p, &next_token);
	//printf("%s\n", ret);

	//ret = strtok_s(NULL, p, &next_token);
	//printf("%s\n", ret);
	return 0;
}

 错误信息报告
 strerror 把错误码翻译成对应的错误信息
#include<errno.h>
int main()
{
	char arr[1024] = { 0 };
    char* buf = arr;
	rsize_t bufsz = sizeof(arr);
	//errno_t str = strerror_s(buf,bufsz,errno);
	//// errno是一个全局错误码变量。
	//// 当c语言库函数执行中发生错误，就会把对应的错误码，赋值到errno中。
	//printf("%s\n", (char*)str);

	// 打开文件
	FILE* pf;
	const char* filename = "test.txt";
	const char* mode = "r";
	errno_t error = fopen_s(&pf,filename, mode);
	if (error == 0)
	{
		printf("%s\n", strerror_s(buf, bufsz,errno));
	}
	else
	{
		printf("success\n");
	}
	return 0;
}

 字符操作
#include<ctype.h>
 字符分类函数
int main()
{
	char ch = 'w';
	int ret = islower(ch);
	printf("%d\n", ret);

	char ch1 = '2';
	int ret1 = isdigit(ch1);
	printf("%d\n", ret1);
	return 0;
}
 字符转换函数
int main()
{
	char ch = tolower('Q');
	putchar(ch);

	printf("\n");

	char ch1 = toupper('q');
	putchar(ch1);
	return 0;
}
int main()
{
	char arr[] = "I Am A Student";
	int i = 0;
	while (arr[i])
	{
		if (isupper(arr[i]))
		{
			arr[i] = tolower(arr[i]);
		}
		i++;
	}
	printf("%s\n", arr);
	return 0;
}
内存操作函数
  memcpy
void* my_memcpy(void* dest, const void* src, size_t num)
{
	void* ret = dest;
	assert(dest && src != NULL);
	while (num--)
	{
		++* (char*)dest = ++ * (char*)src;
	}
	return ret;
}
struct s
{
	char name[20];
	int age;
};
int main()
{
	int arr1[] = { 1,2,3,4,5 };
	int arr2[5] = { 0 };
	memcpy(arr2, arr1, sizeof(arr1));
	struct s arr3[] = { {"张三",20},("李四",30) };
	struct s arr4[3] = { 0 };
	my_memcpy(arr4, arr3, sizeof(arr3));
	// void* 通用类型指针
	return 0;
}
数据类型：内置类型，自定义类型
自定义类型包括：结构体、枚举、联合体

结构体：结构是一些值的集合，这些值成为成员变量。结构的每个成员可以是不同类型的变量。
 结构体的声明
struct stu
{
	// 声明一个学生类型，是通过学生类型来创建学生对象/变量
	// 描述学生属性
	char name[20];
	char tele[12];
	char sex[10];
	int age;
}s4,s5,s6;// 全局结构体变量

int main()
{
	struct stu s1; // 局部结构体变量
	struct stu s2;
	return 0;
}
struct      // 匿名创建（省略结构体标签）
{
	int a;
	char c;
}sa;       // 这边补一下

struct
{
	int a;
	char c;
}*psa;    // 匿名结构体指针类型。 不能存放sa的地址
int main()
{
	psa = &sa; // error
	return 0;
}

 结构体自引用
 数据结构：数据在内存中存储的结构
struct node
{
	int data;
	struct node* next; 
	//struct node n; // 无限套
};

int main()
{
	sizeof(struct node);
	return 0;
}
typedef struct node  // 不可以匿名
{
	int data;
	struct node* next; 
	//struct node n; // 无限套
}node;

int main()
{
	struct node n1;
	node n2;
	return 0;
}

 结构体变量的定义和初始化
struct t
{
	double weight;
	int age;
};
struct s            // 声明同时定义
{
	char c;
	int a;
	double d;
	char arr[20];
	struct t st;
};
int main()
{
	//struct s s = { 'c',100,3.14,"hello bit" }; // 初始化
	//printf("%c %d %lf %s\n", s.c, s.a, s.d, s.arr);
	struct s s = { 'c',100,3.14,"hello bit",{55.6,30} };
	printf("%lf\n", s.st.weight);
	return 0;
}
 结构体内存对齐
 第一个成员在结构体变量偏移量为0的地址处
 其他成员变量要对齐到某个数字（对齐数）的整数倍的地址处
 对齐数=编译器默认的一个对齐数 与 该成员大小的 较小值
 结构体总大小是最大对齐数（每个变量都有一个对齐数，包括嵌套结构体）的整数倍
struct s1
{
	char c1;
	int a;
	char c2;
};
struct s2
{
	char c1;
	char c2;
	int a;
};
int main()
{
	struct s1 s1 = { 0 };
	printf("%d\n", sizeof(s1)); // 12
	struct s2 s2 = { 0 };
	printf("%d\n", sizeof(s2)); // 8
	return 0;
}

 如果嵌套结构体，则对齐数是嵌套结构体的最大对齐数、
 设置默认对齐数
#pragma pack(4)
struct a
{
	char c1;
	double d;
};

int main()
{
	struct a s;
	printf("%d\n", sizeof(a));
	return 0;
}
#pragma pack() // 取消设置
#include<stddef.h>
struct s
{
	char c;
	int i;
	double d;
};

int main()
{
	printf("%d\n", offsetof(struct s, c)); // offsetof 是个宏
	printf("%d\n", offsetof(struct s, i));
	printf("%d\n", offsetof(struct s, d));
	return 0;
}
 结构体实现位段（位段的填充、可移植性）
 位段的声明和结构体类似，两个不同：位段成员必须是：int，unsigned int或signed int（int型就行）;位段成员名后边有一个冒号和一个数字。
struct S      // 为了节省空间
{
	int a: 2; //2bit表达4种状态
	int b: 5;
	int c: 10;
	int d: 30; // 按整型开辟空间。不能大于32，一个最多32bit对应数字32。
};
int main()
{
	struct S s;
	printf("%d\n", sizeof(s));  // 8bit
	return 0;
}
struct S
{
	char a : 3;
	char b : 4;
	char c : 5;
	char d : 4;
};
int main()
{
	struct S s = { 0 };
	printf("%d\n", sizeof(s));
	s.a = 10;
	s.b = 20;
	s.c = 3;
	s.d = 4;
	printf("%d\n", sizeof(s));
	return 0;
}
 位段跨平台问题：
int 位段被当成有符号数还是无符号数；
位段最大位数目不定（16位机最多16）；
从左还是从右分配；
一个结构包含两个位段，一个比较大是丢弃剩下bit还是利用不确定

枚举
 枚举类型的定义
#define RED 0
#define GREEN 1
#define  BLUE 2
enum Sex
{
	MALE = 2,
	FEMAL,
	SECRET
};
//enum Color
//{
//	RED,
//	GREEN,
//	BLUE
//};
int main()
{
	//const int num = 100; //赋初值
	//enum Sex s = MALE;
	//enum Color c = 2; // error
	//printf("%d %d %d\n", RED, GREEN, BLUE); // 0 1 2
	//printf("%d %d %d\n", MALE, FEMAL, SECRET); // 0 1 2 依次往后赋值
	return 0;
}

 枚举的优点：比定义更容易理解，可维护，有类型更严谨，定义便捷，防止命名污染，便于调试

 枚举的使用
enum color
{
	RED=1,
	GREEN=2,
	BLUE=4
};
int main()
{
	enum color clr = GREEN; // 只能拿枚举常量给枚举变量赋值，否则会出现类型差异
	clr = 5; // error
	return 0;
}
enum Sex
{
	male,
    female,
	secret
};
int main()
{
	enum Sex s = male;
	printf("%d\n", sizeof(s));
	return 0;
}
联合-联合体-共用体
 联合类型的定义
 包含一系列成员，共用空间
union Un  // 联合体变量大小，至少是最大成员的大小。
{
	char c;
	int i;
};
int main()
{
	union Un u;
	printf("%d\n", sizeof(u)); // 4
	printf("%p\n", &(u.c));
	printf("%p\n", &(u.i));
	printf("%p\n", &u);
	return 0;
}
#define _CRT_SECURE_NO_WARNINGS 1
#include "contact.h"


void InitContact(struct Contact* ps)
{
	ps->data = (struct PeoInfo*)malloc(DEFAULT_SZ * sizeof(PeoInfo));
	if (ps->data == NULL)
	{
		return;
	}
	ps->size = 0;
	ps->capacity = DEFAULT_SZ;
}

void CheckCapacity(struct Contact* ps)
{
	if (ps->size == ps->capacity)
	{
		struct PeoInfo* ptr =(struct PeoInfo*)realloc(ps->data, (ps->capacity + 2) * sizeof(PeoInfo));
		if (ptr != NULL)
		{
			ps->data = ptr;
			ps->capacity += 2;
			printf("扩容成功\n");
		}
		else
		{
			printf("扩容失败\n");
		}
	}
}
void AddContact(struct Contact* ps)
{
	if (ps->size == MAX)
	{
		printf("通讯录已满,无法增加");
	}
	else
	{
		printf("请输入名字：");
		scanf("%s", ps->data[ps->size].name);
		printf("请输入年龄：");
		scanf("%s", &(ps->data[ps->size].age));
		printf("请输入性别：");
		scanf("%s", ps->data[ps->size].sex);
		printf("请输入电话：");
		scanf("%s", ps->data[ps->size].tele);
		printf("请输入地址：");
		scanf("%s", ps->data[ps->size].addr);
		ps->size++;
		printf("添加成功\n");
	}
}


void ShowContact(const struct Contact* ps)
{
	if (ps->size == 0)
	{
		printf("通讯录为空\n");
	}
	else
	{
		int i = 0;
		printf("%-20s\t%-4s\t%-5s\t%-12s\t%-20s\n", "名字", "年龄", "性别", "电话", "地址"); // 打印标题
		for (i = 0; i < ps->size; i++) // 打印内容
		{
			printf("%-20s\t%-4s\t%-5s\t%-12s\t%-20s\n",
				ps->data[i].name,
				ps->data[i].age,
				ps->data[i].sex,
				ps->data[i].tele,
				ps->data[i].addr);
		}
	}
}


static int FindByName(struct Contact* ps,char name[MAX_NAME]) // 内部用
{
	int i = 0;
	for (i = 0; i < ps->size; i++)
	{
		if (0 == strcmp(ps->data[i].name, name))
		{
			return i;
		}
	}
	return -1;
}


void DelContact(struct Contact* ps)
{
	char name[MAX_NAME]={0};
	printf("请输入被删除者的姓名：");
	scanf("%s", &name);
	// 查找
	int pos = FindByName(ps, name); // 找到返回名字所在元素的下标，找不到返回-1
	
	// 删除
	if (pos == -1)
	{
		printf("目标不存在\n");
	}
	else
	{
		int j = 0;
		for (j = 0; j < ps->size-1; j++)
		{
			ps->data[j] = ps->data[j + 1];
		}
		ps->size--;
		printf("删除成功\n");
	}
}


void SearchContact(struct Contact* ps)
{
	char name[MAX_NAME];
	printf("请输入被查找者的名字：");
	scanf("%s", name);
	int pos = FindByName(ps, name);
	if (pos == -1)
	{
		printf("要查找者不存在\n");
	}
	else
	{
		printf("%-20s\t%-4s\t%-5s\t%-12s\t%-20s\n", "名字", "年龄", "性别", "电话", "地址"); 
		printf("%-20s\t%-4s\t%-5s\t%-12s\t%-20s\n",
				ps->data[pos].name,
				ps->data[pos].age,
				ps->data[pos].sex,
				ps->data[pos].tele,
				ps->data[pos].addr);
	}
}
// 动态内存分配
// 创建变量  栈区：局部变量、函数形式参数。  堆区：动态内存分配。  静态区：全局变量、静态变量
// 创建数组  栈区：局部数组。                                      静态区：全局数组。
//struct S
//{
//	char name[20];
//	int age;
//};
//int main()
//{
//	struct S arr[50]; // 50个struct S类型的数据
//	return 0; // 存在空间浪费
//}

// 存在意义：需要多少空间，开辟多少空间

// 动态内存函数介绍
int main()
{
	int*p = (int*)malloc(10 * sizeof(int)); // malloc 返回类型是void 需要强制转换. 
	if (p == NULL) //返回NULL，表示内存空间不够。
	{
		printf("%s\n", strerror(errno)); // 打印错误原因
	}
	else
	{
		int i = 0;
		for (i = 0; i < 10; i++)
		{
			printf("%d ", *(p + i));
		}
	}        // 动态空间使用完后，应还给程序。
	free(p); // 将动态空间还给系统，不能用来释放数组等。可以free空指针，等于没操作。
	p = NULL; // p虽然被释放了，但还是存在。 需要手动把他变成空指针。
	return 0;
}
int main()
{
	int* p = (int*) calloc(10, sizeof(int)); // 将动态空间初始化为0
	if (p == NULL)
	{
		printf("%s\n", strerror(errno));
	}
	else
	{
		int i = 0;
		for (i = 0; i < 10; i++)
		{
			printf("%d ", *(p + i));
		}
	}
	free(p);
	p = NULL;
	return 0; 
}
 realloc
int main()
{
	int* p = (int*)malloc(20);
	if (p == NULL)
	{
		printf("%s\n", strerror(errno));
	}
	else
	{
		int i = 0;
		for (i = 0; i < 5; i++)
		{
			*(p + i) = i;
		}
	} // 开辟了20个字节空间，现在需要40个，增加空间。
	int* ptr = (int*)realloc(p, 40); // realloc 扩大空间，p是目标空间的地址，40是新空间的大小。
	// p 后空间足够，在后面加上空间； p后空间不足，开辟足够的新空间，将原来内容拷贝过来，释放就空间，返回新空间地址。
	if (ptr != NULL) // 开辟成功把ptr赋给p，防止开辟失败直接把p变成空指针从而丢失原先开辟的空间。
	{
		p = ptr;
		int i = 0;
		for (i = 0; i < 5; i++)
		{
			*(p + i) = i;
		}
		for (i = 0; i < 10; i++)
		{
			printf("%d ", *(p + i));
		}
	}
	free(p);
	p = NULL;
	return 0;
}


 常见动态内存错误
1 对空指针解引用
int main()
{
	int* p = (int*)malloc(40); // 如果malloc失败，p变赋值为空指针，违法操作。
	*p = 0;
	return 0;
}
 2 对动态开辟空间的越界访问
int main()
{
	int* p = (int*)malloc(5 * sizeof(int));
	if (p == NULL)
	{
		return 0;
	}
	else
	{
		int i = 0;
		for (i = 0; i < 10; i++) // 越界访问
		{
			*(p + i) = i;
		}
	}
	free(p);
	p = NULL;
	return 0;
}
 3 对非动态开辟内存的free
int main()
{
	int a = 10;
	int* p = &a; 
	*p = 20;
	free(p); // 对非动态开辟内存的free
	p = NULL;
	return 0;
}
 4 使用free释放动态内存的一部分
int main()
{
	int* p = (int*)malloc(40);
	if (p == NULL)
	{
		return 0;
	}
	else
	{
		int i = 0;
		for (i = 0; i < 10; i++)
		{
			*p++ = i; // p发生了变化
		}
	}
	free(p); //只能从空间首地址开始释放空间
	p = NULL;
	return 0;
}
 5 对同一块动态内存的多次释放
int main()
{
	int* p = (int*)malloc(40);
	if (p == NULL)
	{
		return 0;
	}
	else
	{
		;
	}
	free(p);
	p = NULL; // 手动变p为空指针，防止多次释放报错。
	// 。。。
	free(p);
	return 0;
}
 6 忘记释放动态内存（内存泄露）
int main()
{
	while (1)
	{
		malloc(1);   // 只开辟，不回收。
		Sleep(1000);
	}
	return 0;
}


 经典题目
 1 Test执行结果？ error
void GetMemory(char* p)
{
	p = (char*)malloc(100);
}
void Test(void)
{
	char* str = NULL;
	GetMemory(str);
	strcpy(str, "hello world");
	printf(str);
}

void GetMemory(char** p) // 改版1
{
	*p = (char*)malloc(100);
}
void Test(void)
{
	char* str = NULL;
	GetMemory(&str);
	strcpy(str, "hello world");
	printf(str);
	free(str);
	str = NULL;
}

char* GetMemory(char** p) // 改版2
{
	*p = (char*)malloc(100);
	return p;
}
void Test(void)
{
	char* str = NULL;
	str = GetMemory(&str);
	strcpy(str, "hello world");
	printf(str);
	free(str);
	str = NULL;
}

int main()
{
	Test();
	return 0;
}
 2 test函数输出结果
char* GetMemory(void)
{
	char p[] = "hello world";
	return p;
}
void Test(void)
{
	char* str = NULL;
	str = GetMemory();
	printf(str);
}
 改版
int* Test()
{
	int* ptr = (int*)malloc(100);
	return ptr;
}
int main()
{
	int* p =Test();
	return 0;
}
 3 
void GetMemory(char** p, int num)
{
	*p = (char*)malloc(num);
}
void Test(void)
{
	char* str = NULL;
	GetMemory(&str, 100);
	strcpy(str, "hello");
	printf(str); // 忘记释放动态内存空间
}
void Test()
{
	char* str = (char*)malloc(100);
	strcpy_s(str, 6,"hello");
	free(str); //释放空间，但没有把str置NULL
	str = NULL;
	if (str != NULL)
	{
		strcpy_s(str,6, "world"); // 释放过的空间再次使用
		printf(str);
	}
}

int main()
{
	Test();
	return 0;
}
 柔性数组: c99中，结构中的最后一个元素允许是未知大小的数组，称为柔性数组成员。
struct S
{
	int n;
	int arr[]; // 数组大小可以调整
};
int main()
{
	//struct S s;
	//printf("%d\n", sizeof(s)); // 初始状态，柔性数组大小为0
	struct S* ps = (struct S*) malloc(sizeof(struct S)+ 5*sizeof(int)); // 内存连续，访问效率更高
	ps->n = 100;
	int i = 0;
	for (i = 0; i < 5; i++)
	{
		ps->arr[i] = i;
	}
	struct S* ptr = (struct S* ) realloc(ps, 44);
	if (ptr != NULL)
	{
		ps = ptr;
	}
	for (i = 5; i < 10; i++)
	{
		ps->arr[i] = i;
	}
	for (i = 0; i < 10; i++)
	{
		printf("%d ", ps->arr[i]);
	}
	free(ps);
	ps = NULL;
	return 0;
}

struct S
{
	int n;
	int* arr;
};
int main()
{
	struct S* ps = (struct S*)malloc(sizeof(struct S));
	ps->arr = (int*) malloc(5 * sizeof(int));
	int i = 0;
	for (i = 0; i < 5; i++)
	{
		ps->arr[i] = i;
	}
	for (i = 0; i < 5; i++)
	{
		printf("%d ", ps->arr[i]);
	}
	printf("\n");
	// 扩大空间
	int* ptr = (int*)realloc(ps->arr, 10 * sizeof(int));
	if (ps != NULL) // 检验是否成功扩容
	{
		ps->arr = ptr;
	}
	for (i = 5; i < 10; i++)
	{
		ps->arr[i] = i;
	}
	for (i = 0; i < 10; i++)
	{
		printf("%d ", ps->arr[i]);
	}
	// 释放内存
	free(ps->arr); // 多次malloc，free容易出错
	free(ps);
	ps->arr = NULL;
	ps = NULL;
	return 0;
}
 文件操作
 什么是文件：磁盘里存放数据的介质
 文件名：文件路径+文件名主干+文件后缀
 文件类型：根据数据的组织形式，数据文件被称为文本文件\二进制文件（以二进制存储，不加转换输出到外存）
int main()
{
	int a = 10000;
	FILE* pf = fopen("test.txt", "wb"); // 打开文件test.txt，不存在就创建
	fwrite(&a, 4, 1, pf); //以二进制形式写到文件中。 以a的地址，写一个四字节的到of中（其实就是把a的值写入文件）
	fclose(pf);
	pf = NULL;
	return 0;
}
 文件缓冲区
 ANSIC用缓冲文件系统，系统自动在内存中为程序中每一个正在使用的文件开辟一块文件缓冲区。
 内存向磁盘输出数据先放缓冲区，装满后统一送到磁盘。从磁盘读数据，先充满缓冲区，再从缓冲区中逐一送数据到程序数据区。

 文件指针:文件类型指针
 被使用文件在内存中开辟了一个相应的文件信息区，用来存放文件相关信息（名字、状态、当前位置等）。被保存在一个结构体变量中，名为FILE。
struct _iobuf {
	char* _ptr;
	int _cnt;
	char* _base;
	int _flag;
	int _file;
	int _charbuf;
	int _bufsiz;
	char* _tmpfname;
};
typedef struct _iobuf FILE;
 定义pf是一个指向FILE类型的指针变量，指向文件信息区，找到与之关联的文件。


 文件的打开和关闭
int main()
{
    // 相对路径写法中， .. 表示上一级路径  . 表示当前路径
	FILE* pf = fopen("../test.txt", "r"); // 打开文件名(相对路径）  打开方式（只读）
	if (pf == NULL)
	{
		printf("%s\n", strerror(errno));
	}
	//打开文件
	//读文件
	//关闭文件
	fclose(pf); // 让这个结构体关闭，释放内存空间，但pf没有变空指针
	pf = NULL;  // 手动将pf置空指针
	return 0;
}
int main()
{
	FILE* pfWrite = fopen("TEST.txt","w");
	if (pfWrite == NULL)
	{
		printf("%s\n", strerror(errno));
		return 0;
	}
	// 写文件
	fputc('b', pfWrite);
	fputc('i', pfWrite);
	fputc('t', pfWrite);
	// 关闭文件
	fclose(pfWrite);
	pfWrite = NULL;
}
int main()
{
	FILE* pfRead = fopen("TEST.txt", "r");
	if (pfRead == NULL)
	{
		printf("%s\n", strerror(errno));
		return 0;
	}
	// 写文件
	printf("%c ", fgetc(pfRead));
	printf("%c ", fgetc(pfRead));
	printf("%c ", fgetc(pfRead));
	// 关闭文件
	fclose(pfRead);
	pfRead = NULL;
}

 从键盘输入  （键盘：标准输入设备）stdin
 输出到屏幕  （屏幕：标准输出设备）stdout
 键盘和屏幕都是外设 （程序默认打开的两个流设备） （默认打开3个 分别为是stdin FILE*，stdout FILE*，stderr FILE*
int main()
{
	int ch = fgetc(stdin); // 读一个字符
	fputc(ch, stdout);     // 输出一个字符到屏幕
	return 0;
}
 读取或输出一个字符串 
int main()
{
	char buf[1024] = { 0 };
	FILE* pf = fopen("test.txt", "r");
	if (pf == NULL)
	{
		return 0;
	}
	fgets(buf, 1024, pf);
	printf("%s\n", buf);
	// outs(buf);
	fclose(pf);
	pf = NULL;
	return 0;
}
int main()
{
	char buf[1024] = { 0 };
	FILE* pf = fopen("test.txt", "w");
	if (pf == NULL)
	{
		return 0;
	}
	fputs("hello", pf);
	fputs("world", pf);
	fclose(pf);
	pf = NULL;
	return 0;
}

 读取或输出一行 
int main()
{
	char buf[1024] = { 0 };
	//fgets(buf,1024,stdin); // 从标准输入读，放到buf里面
	//fputs(buf, stdout);    // 从buf输出到标准输出
	gets(buf);
	puts(buf);
	return 0;
}
 格式化输入或输出函数
struct S
{
	int n;
	float score;
	char arr[10];
};

int main()
{
	struct S s = { 100,3.14f,"bit" };
	FILE* pf = fopen("test.txt", "w");
	if (pf == NULL)
	{
		return 0;
	}
	//格式化形式写文件
	fprintf(pf, "%d %f %s", s.n, s.score, s.arr);

	fclose(pf);
	pf = NULL;
	return 0;
}
int main()
{
	struct S s = {0};
	FILE* pf = fopen("test.txt", "r");
	if (pf == NULL)
	{
		return 0;
	}
	//格式化输入数据
	fscanf(pf, "%d %f %s", &(s.n), &(s.score), s.arr);
	printf("%d %f %s\n", s.n, s.score, s.arr);
	//fscanf(stdin, "%d %f %s", &(s.n), &(s.score), s.arr);
	//printf(stdout,"%d %.2f %s\n", s.n, s.score, s.arr);
	fclose(pf);
	pf = NULL;
	return 0;
}
int main()
{
	struct S s = { 100,3.14f,"abcd" };
	struct S tmp = { 0 };
	char buf[1024] = { 0 };
	sprintf(buf, "%d %f %s", s.n, s.score, s.arr);
	printf("%s\n", buf); // 将结构体转换成字符串
	scanf(buf, "%d %f %s", &(tmp.n), &(tmp.score), tmp.arr);
	printf("%d %f %s\n", tmp.n, tmp.score, tmp.arr);
	return 0;
}

 二进制读写
struct S
{
	char name[1024];
	int age;
	float weight;
};
int main()
{
	//struct S s = { "张三",20,55.6 };
	struct  S tmp = { 0 };
	FILE* pf = fopen("test.txt", "wb");
	if (pf == NULL)
	{
		return 0;
	}
	//fwrite(&s, sizeof(struct S), 1, pf); // 写
	fread(&tmp, sizeof(struct S), 1, pf);  // 读
	printf("%s %d %lf\n", tmp.name, tmp.age, tmp.weight);
	fclose(pf);
	pf = NULL;
	return 0;
}
 文件的随机读写 
int main()
{
	FILE* pf = fopen("test.txt", "r");
	if (pf == NULL)
	{
		return 0;
	}
	fseek(pf, 2, SEEK_CUR); // 偏移量不能超出文本范围
	int ch = fgetc(pf);
	printf("%c\n", ch);
	fclose(pf);
	pf = NULL;
	return 0;
}
int main()
{
	FILE* pf = fopen("test.txt", "r");
	if (pf == NULL)
	{
		return 0;
	}
	fseek(pf, -2, SEEK_END); // 偏移量不能超出文本范围
	//int pos = ftell(pf);   // ftell 返回文件指针相对起始位置的偏移量
	//printf("%c\n", pos);
	rewind(pf);              // rewind返回起始位置

	fclose(pf);
	pf = NULL;
	return 0;
}

 文件结束的判定
int main()
{
	FILE* pf = fopen("text.txt", "r");
	if (pf == NULL)
	{
		return 0;
	}
	int ch = fgetc(pf);
	printf("%d\n", ch);
	feof(); // EOF文件结束标志，feof用于当文件读取结束时，判断是读取失败结束，还是遇到文件尾结束。
	fclose(pf);
	pf = NULL;
	return 0;
} 
int main()
{
	FILE* pf = fopen("test.txt", "r");
	if (pf == NULL)
	{
		perror("open file test,txt");  // 报错函数
	}
	int ch = 0;
	while ((ch = fgetc(pf)) != EOF)
	{
		putchar(ch);
	}
	if (ferror(pf))
	{
		printf("error\n");
	}
	else if (feof(pf))
	{
		printf("end of file\n");
	}
	fclose(pf);
	pf = NULL;
	return 0;
}
struct A
{
	int a;
	short b;
	int c;
	short d;
};
struct B
{
	int a;
	short b;
	char c;
	int d;
};
 c语言预处理
 程序的翻译环境：翻译+链接
 将.c文件翻译成.exe文件
extern int Add(int x, int y); // 生成外部文件
int main()
{
	int arr[10] = { 0 };
	int i = 0;
	for (i = 0; i < 10; i++)
	{
		arr[i] = i;
	}
	for (i = 0; i < 10; i++)
	{
		printf("%d ", i);
	}
	return 0;
}
 源文件 经编译器 生成目标文件（.obj）  到链接器+链接库 生成可执行程序
 翻译：预处理 编译 汇编
 预处理（文本操作）： 头文件包含（#include）、删除注释、完成预处理指令（#define）
 编译：把c代码翻译成汇编代码
 汇编：将汇编代码转换成二进制指令。
 链接：合并段表，符号表的合并和重定位。



int main()
{
int a,b,c,max;
printf("please input a,b,c:\n");
scanf("%d,%d,%d",&a,&b,&c);
max=a;
if(max<b)
  max=b;
if(max<c)
  max=c;
printf("max=%d\n",max);
return 0;
}

int main()
{float p,r,n;
 r=0.07;
 n=10;
 p=pow(1+r,n);
 printf("p=%f\n",p);
 return 0;
 }

int main()
{
float d=300000,p=6000,r=0.01,m;
m=lg10(p/(p-d*r))/lg10(1+r);
printf("m=%6.1f\n",m);
return 0;
}

int main()
{char c1,c2;
c1=97;
c2=98;
printf("c1=%c,c2=%c\n",c1,c2);
printf("c1=%d,c2=%d\n",c1,c2);
return 0;
}
