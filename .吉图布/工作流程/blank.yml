# This is a basic workflow to help you get started with Actions

name: CI

# Controls when the workflow will run
on:
  # Triggers the workflow on push or pull request events but only for the main branch
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

  # Allows you to run this workflow manually from the Actions tab
  workflow_dispatch:

# A workflow run is made up of one or more jobs that can run sequentially or in parallel
jobs:
  # This workflow contains a single job called "build"
  build:
    # The type of runner that the job will run on
    runs-on: ubuntu-latest

    # Steps represent a sequence of tasks that will be executed as part of the job
    steps:
      # Checks-out your repository under $GITHUB_WORKSPACE, so your job can access it
      - uses: actions/checkout@v2

      # Runs a single command using the runners shell
      - name: Run a one-line script
        run: echo Hello, world!

      # Runs a set of commands using the runners shell
      - name: Run a multi-line script
        run: |
          echo Add other actions to build,
          echo test, and deploy your project.


struct Book
{
  char name[20];
  short price; // 55
};
int main()
{
  sreuct Book bl ={"C语言真难",55};
  printf("书名:%s\n",bl,name);
  printf("价格:%d\n",bl,price);
  return 0;
}

//分支语句和循环语句
//C语言是一门结构化的程序设计语言（顺序结构、选择结构、循环结构）
// 选择结构——分支语句
int main()
{
	int a = 0; // ;表示一条语句结束了
	; // 空语句
	return 0;
}
int main()
{
	int age = 10;
	if (age < 18)
		printf("未成年\n");  //到这一步是单分支
	else
		printf("成年\n");    //双分支
	return 0;
}
int main()
{
	int age = 21;
	if (age < 18)
	{
  printf("未成年\n");
  }
  else
  {
  if (age >= 18 && age < 28)
		printf("青年\n");
	else if (age >= 28 && age < 50)
		printf("壮年\n");
	else if (age >= 50 && age < 90)
		printf("老年\n");
	else
		printf("仙人\n");
   }
	return 0;
}
int main()
{
	int a = 0;
	int b = 2;
	if (a == 1)
	{
		if (b == 2)
			printf("hehe\n");
	}
	else
		    printf("haha\n");
	return 0;
}
//比较奇数
int main()
{
	int a = 4;
	if (a % 2 == 0)
		printf("偶数\n");
	else
		printf("奇数\n");
	return 0;
}
int main()
{
	int i = 1;
	while (i <= 100)
	{
		if (i % 2 == 1)
			printf(" % d", i);
		i++;
	}
	return 0;
}
int main()
{
	int i = 1;
	while (i <= 100)
	{
		if (i % 2 != 0)
			printf("%d", i);
		i+=2;
	}
	return 0;
}
int main()
{
	int day = 0;
	scanf("%d", &day);
	switch (day)
	{
		case 1:
			if (1 == day)
				printf("周末综合征\n");
		case 2:
		case 3:
		case 4:
		case 5:
			printf("工作日\n");
			break;
		case 6:
		case 7:
			printf("休息日\n");
			break; //最后一句加上break防止后续加代码，case7执行时把后面的也执行了。
		case 8:
			break;
		default:
			printf("输入错误\n");
			break;
	}
	return 0;
}
int main()
{
	int n = 1;
	int m = 2;
	switch (n)
	{ 
	case 1:m++;
	case 2:n++;
	case 3:
		switch(n) //switch允许嵌套使用
		{
	    case 1:n++;
		case 2:m++; n++;
			break;//用于跳出case3内的分支，进入原来的分支。
		}
	case 4:m++;
		break;
	default:
		break;
	}
	printf("m=%d,n=%d\n", m, n); // m=5 n=3
	return 0;
} 
 循环结构——循环语句
int main()
{
	while (1)
		printf("hehe\n"); //无限循环打印hehe
	return 0;
}
int main()
{
	int i = 1;
	while (i <= 10)
	{
		if (5 == i)
			break; //打破循环
		printf(" %d",i);
		i++;
	}
	return 0;
}
int main()
{
	int i = 0;
	while (i <= 10)
	{
		//if (5 == i)
		//	continue; // continue后的不执行，返回while的判断。此处进入死循环
		i++;
		if (5 == i)
			continue;
		printf(" %d", i);
	}
	return 0;
}

int main()
{
	int ch = getchar();
	putchar(ch); //相当于printf("%c\n",ch);
	printf("%c\n", ch);
	return 0;
}
#define _CRT_SECURE_NO_WARNING 1
int main()
{
	int ch = 0;
	//输入ctrl+z此时getchar获取EOF结束循环
	while ((ch = getchar()) != EOF)  //EOF=end of file文件结束标志
	{
		putchar(ch);
	}
	return 0;
}
int main()
{
	int ret = 0;
	int ch =0;
	char password[20] = { 0 };
	printf("请输入密码：>");
	scanf("%s", password);  //输入缓冲区123456\n→输入函数123456
	printf("请确认（Y/N):>");
	while((ch = getchar()) != '\n')
	{
	  ;
	}
	ret = getchar();
	if (ret == 'Y')
	{
		printf("确认成功\n");
	}
	else
	{
		printf("放弃确认\n");
	}
	return 0;
}
int main()
{
	int i = 0;
	for (i = 1; i <= 10; i++) //将三个步骤放在了一起
	{
		printf("%d ", i);
	}
	return 0;
 }
int main()                      //计算阶乘求和
{
	int i = 0;
	int n = 0;
	int ret = 1;
	int sum = 0;
	int k = 0;
	scanf("%d", &k);
	for (n = 1; n <= k; n++)
	{
		ret = 1;
		for(i=1;i<=n;i++)
		{
			ret = ret * i;
		}
		sum = sum + ret;
	}
	printf("sum=%d\n", sum);
	return 0;
}
5
int main()
{
	int i = 0;
	char password[20] = { 0 };
	for (i = 0; i < 3; i++)
	{

		printf("请输入密码:>");
		scanf("%s", password);
		if (strcmp(password, "1210") == 0)  //等号不能用来比较两个字符串是否相等，应该使用一个库函数-strcmp
		{
			printf("登录成功\n");
			break;
		}
		else
			printf("密码错误\n");
	}
	if (3 == i)
		printf("三次密码均错误，退出程序\n");
	return 0;
}
6     //输入三个值排序，按从大到小输出
int main()                           
{
	int a = 0;
	int b = 0;
	int c = 0;
	scanf("%d%d%d", &a, &b, &c);
	if (a < b)
	{
		int tmp = a;
		a = b;
		b = tmp;
	}
	if (a < c)
	{
		int tmp = a;
		a = c;
		c = tmp;
	}
	if (b < c)
	{
		int tmp = b;
		b = c;
		c = tmp;
	}
	printf("%d %d %d\n", a, b, c);
	return 0;
}
7     //打印1-100之间的所有3的倍数
int main()
{
	int i = 0;
	for(i = 1;i < 100; i++)
	{
		if (i % 3 == 0)
			printf("%d ", i);
	}
	return 0;
}
8      //给两个数，求最大公约数
int main()
{
	int a = 0;
	int b = 0;
	scanf("%d%d", &a, &b);
	int r = 0;
	while (a % b)  //辗转相除法
	{
		r = a % b;
		a = b;
		b = r;
	}
	printf("%d\n", b);
	return 0l;
}
8          //打印闰年
int main()
{
	int year = 0;
	int count = 0;
	for (year = 1000; year <= 2000; year++)
	{
		if (year % 4 == 0 && year % 100 != 0)
		{
			printf("%d ", year);
			count++;
		}
		else if (year % 400 == 0)
		{
			printf("%d ", year);
			count++;
		}
	}
	printf("\ncount =%d\n", count);
	return 0;
}
int main()
{
	int year = 0;
	int count = 0;
	for (year = 1000; year <= 2000; year++)
	{
		if (((year % 4 == 0) && (year % 100 != 0)) || (year % 400 == 0))
		{
			printf("%d ", year);
			count++;
		}
	}
	printf("\ncount =%d\n", count);
	return 0;
}
9     //打印素数
int main()
{
	int i = 0;
	int count = 0;
	for (i = 100; i <= 200; i++)  //试除法
	{
		int j = 0;
		for (j = 2; j < i; j++)
		{
			if (i % j == 0)
			{
				break;
			}
		}
		if (j == i)
		{
			count++;
			printf("%d ", i);
		}
	}
	printf("\ncount =%d\n", count);
	return 0;
}
1  //数9的个数
int main()
{
	int i = 0;
	int count = 0;
	for (i = 1; i <= 100; i++)
	{
		if (i % 10 == 9)
			count++;
		if (i / 10 == 9)
			count++;
	}
	printf("count = %d\n", count);
	return 0;
}
2    //分数求和
int main()
{
	int i = 0;
	double sum = 0.0;
	int flag = 1;
	for (i = 1; i <= 100; i++)
	{
		sum += flag*1.0 / i;
		flag = -flag;
	}
	printf("%lf\n", sum);
	return 0;
}
3       //十个数找最大值
int main()
{
	int arr[] = { 1,2,3,4,5,6,7,8,9,10 };
	int max = arr[0];
	int i = 0;
	int sz = sizeof(arr) / sizeof(arr[0]);
	for (i = 0; i < sz; i++)
	{
		if (arr[i] > max)
		{
			max = arr[i];
		}
	}
	printf("max =%d\n", max);
	return 0;
}
4     //屏幕上输出99乘法表
int main()
{
	int i = 0;
	for (i = 1; i <= 9; i++)
	{
		int j = 1;
		for (j = 1; j <= i; j++)
		{
			printf("%d*%d=%-2d ", i, j, i * j);  //%2d表示打印两位，不够自动右对齐；%-2d自动左对齐
		}
		printf("\n");
	}
	return 0;
}
void menu()
{
	printf("猜数字\n");
	printf("***  1.play  0.exit  ***\n");
}
void game()
{
	
	int ret = 0;   
	int guess = 0;
	ret = rand()%100+1;   // 伪随机函数rand 生成0到7FFFH之间的一个任意整数。可以通过取模限定范围
	//printf("%d\n", ret);
	while (1)
	{
		printf("请猜数字：>");
		scanf("%d", &guess);
		if (guess > ret)
		{
			printf("猜大了\n");
		}
		else if (guess < ret)
		{
			printf("猜小了\n");
		}
		else
		{
			printf("猜对了\n");
			break;
		}
	}
}
int main()
{
	int input = 0;
	srand((unsigned int)time(NULL)); // 时间戳 当前时间和计算机起始时间（1970.01.01 00：00）的差值——一直在变化
	do
	{

		menu();
		printf("请选择>:");
		scanf("%d", &input);
		switch (input)
		{
		case 1:
			game();
			break;
		case 0:
			printf("退出游戏\n");
			break;
		default:
			printf("选择错误\n");
			break;
		}
	} while (input);
	return 0;
}
函数
  函数是什么：大型程序的部分代码，解决特定问题，相对独立。 分为库函数和自定义函数
int Add(int x, int y)
{
	int z = 0;
	z = x + y;
	return z;
}
int main()
{
	int a = 20;
	int b = 10;
	int sum = Add(a, b);
	printf("%d\n", sum);
	return 0;
}
  库函数：现成函数，引用头文件就能使用
具体有：IO函数、字符串操作函数、字符操作函数、内存操作函数、时间/日期函数、数学函数、其他库函数。
int main()
{
	char arr1[] = "bit";
	char arr2[20] = "#####";
	strcpy(arr2, arr1);
	printf("%s\n", arr2);
	return 0;
}
int main()
{
	char arr[] = "hehe haha";
	memset(arr, '*', 5);        //memset 内存设置
	printf("%s\n", arr);
	return 0;
}

  自定义函数：自己设计函数
ret_type fun_name(para1, *)  //类型 函数名+格式
{
	statement; //语句项，交代函数如何实现
}
int get_max(int x, int y)
{
	int z = 0;
    if (x > y)
       return x;
    else
       return y;
}
int main()
{
	int a = 10;
	int b = 20;
	int max = get_max (a, b);
	printf("max=%d\n", max);
	return 0;
}
void Swap(int* pa, int* pb)  // void代表没有返回值
{
	int tmp = 0;
	tmp = *pa;
	*pa = *pb;
	*pb = tmp;
}
int main()
{
	int a = 10;
	int* pa = &a;  //pa指针变量，用来存放a的地址
	*pa;//解引用操作，通过pa找到里面存的内容
	int b = 30;
	printf("a=%d b=%d\n", a, b);
	Swap(&a, &b);
	printf("a=%d b=%d\n", a, b);
	return 0;
}
  函数参数：形参、实参
  函数调用:函数与函数间有机组合。
  函数的嵌套调用和链式访问
 嵌套：函数里面套函数。
  链式访问：将一个函数的返回值作为下一函数的参数
int main()
{
	int len = 0;
	len = strlen("abc");
	printf("%d\n", len);
	printf("%d\n", strlen("abc")); // 链式访问
	return 0;
}
int main()
{
	printf("%d", printf("%d", printf("%d", 43))); //printf的返回值是打印在屏幕上字符的个数
	return 0;
}
  函数的声明和定义
 #include"函数.h"  //函数声明
int main()
{
	int a = 10;
	int b = 20;
	int sum = 0;
	sum = Add(a, b);
	printf("%d\n", sum);
	return 0;
}
  函数递归:程序调用自身的编程技巧。将一个大型复杂问题转化为一个与原问题相似的规模较小的问题来求解。
  必要条件：存在限制条件，达到限制条件后停止递归。  每次递归越来越逼近限制条件。
int main()
{
	printf("hrhr\n");
	main();              // main函数套main函数
	return 0;            //递归常见错误：栈溢出
}
void print(int n)
{
	if (n > 9)
	{
		print(n / 10);
	}
	printf("%d ", n % 10);
}
int main()
{
	unsigned int num = 0;
	scanf("%d", &num);
	print(num);
	return 0;
}
int my_strlen(char* str)    //利用循环模拟strlen函数
{
	int count = 0;            // 创建了临时变量count
	while (*str != '\0')
	{
		count++;
		str++;
	}
	return count;
}
int main()
{
	char arr[] = "bit";
	/*int len = strlen(arr);*/
	int len = my_strlen(arr);  //数组传参，传的是首元素地址
	printf("%d\n", len);
	return 0;
}
int my_strlen(char* str)     //利用递归模拟strlen函数
{
	if (*str != '\0')        //无临时变量
		return 1 + my_strlen(str + 1);
	else
		return 0;
}
int main()
{
	char arr[] = "bit";
	int len = my_strlen(arr);
	printf("%d\n", len);
	return 0;
}
递归与迭代
int FAC1(int n)
{
	/*int i = 0;                //循环方式
	int ret = 1;
	for (i = 1; i <= n; i++)
	{
		ret *= i;
	}
	return ret;*/
	if (n <= 1)                 //递归方式
		return 1;
	else
		return n * FAC1(n - 1);
}
int main()  //求n的阶乘
{
	int n = 0;
	int ret = 0;
	scanf("%d", &n);
	ret = FAC1(n);
	printf("%d\n", ret);
	return 0;
}
//数组
// 一维数组的创建和初始化
// 数组是一组相同元素的集合。创建方式：type_t是指数组的元素类型，const_n是一个常量表达式，用来指定数组的大小。
int main()
{
	int arr[10] = { 1，2，3 };  //不完全初始化，剩下的元素初始化默认0
	char arr2[5] = { 'a','b' };
	char arr3[5] = "ab";
	/*int n = 5;*/
	/*char ch[n]; */   //报错，[]中只能使用常量，不能变量。
	return 0;
}
 一维数组的使用
int main()
{
	char arr[] = "asdfg";
	int i = 0;
	for (i = 0; i < strlen(arr); i++)
	{
		printf("%c ", arr[i]);
	}
	return 0;
}
int main()
{
	int arr[] = { 1,2,3,4,5,6,7,8,9,0 };
	int sz = sizeof(arr) / sizeof(arr[0]);
	int i = 0;
	for (i = 0; i < sz; i++)
	{
		printf("%d ", arr[i]);              //利用下标访问数组
	}
	return 0;
}

 一维数组在内存中的存储
int main()
{
	int arr[] = { 1,2,3,4,5,6,7 };
	int sz = sizeof(arr) / sizeof(arr[0]);
	int i = 0;
	for (i = 0; i < sz; i++)
	{
		printf("&arr[%d]=%p\n", i, &arr[i]);
	}
	return 0;
}
 二维数组的创建和初始化
int main()
{
	int arr[3][4] = { 1,2,3,4,5 };
	int arr1[3][4] = { {1,2,3},{4,5} };
	int arr2[][] = { 1,2,3,4,5,6,7,8 };     //报错
	int arr3[][] = { {1,2,3,4},{5,6,7,8} }; //也不行
	int arr4[3][]= { {1,2,3,4},{5,6,7,8} }; //列不能省略
	int arr4[][4] = { {1,2,3,4},{5,6,7,8} };//可以省略行
	return 0;
}
 二维数组的使用
int main()
{
	int arr[3][4] = { {1,2,3},{4,5,6} };
	int i = 0;
	for (i = 0; i < 3; i++)
	{
		int j = 0;
		for (j = 0; j < 4; j++)
		{
			printf("%d ", arr[i][j]);
		}
		printf("\n");
	}
	return 0;
}
 二维数组在内存中的存储
int main()
{
	int arr[3][4] = { {1,2,3},{4,5,6} };
	int i = 0;
	for (i = 0; i < 3; i++)
	{
		int j = 0;
		for (j = 0; j < 4; j++)
		{
			printf("&arr[%d][%d]=%p\n",i,j,&arr[i][j]);
		}
		printf("\n");
	}
	return 0;
}
 数组作为函数参数
void bubble_sort(int arr[],int sz)
{
	int i = 0;
	for (i = 0; i < sz - 1; i++)
	{
		int j = 0;
		for (j = 0; j < sz-1-i; j++)
		{
			if (arr[j] > arr[j + 1]);
			{
				int tmp = arr[j];
				arr[j] = arr[j + 1];
				arr[j + 1] = tmp;
			}
		}
	}
}
void bubble_sort1(int arr[], int sz)    //优化版
{
	int i = 0;
	for (i = 0; i < sz - 1; i++)
	{
		int flag = 1;                   //假设已经有序
		int j = 0;
		for (j = 0; j < sz - 1 - i; j++)
		{
			if (arr[j] > arr[j + 1]);
			{
				int tmp = arr[j];
				arr[j] = arr[j + 1];
				arr[j + 1] = tmp;
				flag = 0;                //本次数组不完全有序
			}
		}
		if (flag == 1)                   //利用flag判断是否已经排序完成
		{
			break;
		}
	}
}
int main()
{
	int arr[] = { 9,8,7,6,5,4,3,2,1,0 }; //将arr排成升序
	int i = 0;
	int sz = sizeof(arr) / sizeof(arr[0]);
	bubble_sort(arr,sz); //冒泡排序函数
	for (i = 0; i < sz; i++)
	{
		printf("%d ", arr[i]);
	}
	return 0;
}
int main()                             //数组名
{
	int arr[] = { 1,2,3,4,5,6,7,8,9 };
	printf("%p\n", arr);
	printf("%p\n", &arr[0]);
	printf("%d\n", *arr);                   //数组名通常就是首元素地址
	int sz = sizeof(arr) / sizeof(arr[0]);  //例外1 sizeof(数组名)，计算的是整个数组的大小，单位是字节。
	printf("%p\n", arr);                    //例外2 取地址 &数组名，代表的是整个数组的地址。
	printf("%p\n", arr+1);                  // 加一后是数组中第二个元素的地址
	printf("%p\n", &arr[0]);
	printf("%p\n", &arr[0]+1);
	printf("%p\n", &arr);                   //看似一样，实际是整个数组地址。加一后的地址是整个数组之后的地址
	printf("%p\n", &arr+1);
	return 0;

//测试 三子棋 游戏
#pragma once
#include<stdlib.h>
#include<time.h>
#include <stdio.h>
#define ROW 3
#define COL 3

void InitBoard(char board[ROW][COL], int row, int col);//函数声明
void DisplayBoard(char board[ROW][COL], int row, int col);
void Playermove(char board[ROW][COL],int row,int col);
void Computermove(char board[ROW][COL], int row, int col);
char Iswin(char board[ROW][COL], int row, int col);


#include "game.h"
#define _CRT_SECURE_NO_WARNINGS 1

void InitBoard(char board[ROW][COL], int row, int col) 
{
	int i = 0;
	int j = 0;
	for (i = 0; i < row; i++)
	{
		for (j = 0; j < col; j++)
		{
			board[i][j] = ' ';
		}
	}
}

void DisplayBoard(char board[ROW][COL], int row, int col)
{
	printf("\n");
	int i = 0;
	for (i = 0; i < row; i++)
	{
		int j = 0;
		for (j = 0; j < col; j++)
		{
			printf(" %c ", board[i][j]);
			if (j < col - 1)
				printf("|");
		}
		printf("\n");
		if (i < row - 1)
		{
			int j = 0;
			for (j = 0; j < col; j++)
			{
				printf("---");
				if (j < col - 1)
					printf("|");
			}
			printf("\n");
		}
	}
}

void Playermove(char board[ROW][COL], int row, int col)
{
	int x = 0;
	int y = 0;
	printf("玩家下：>\n");
	while (1)
	{
		printf("请输入要下的坐标：>");
		scanf_s("%d%d", &x, &y);
		if (x >= 1 && x <= row && y >= 1 && y <= col)
		{
			if (board[x - 1][y - 1] == ' ')
			{
				board[x - 1][y - 1] = '*';
				break;
			}
			else
				printf("该坐标被占用\n");
		}
		else
		{
			printf("坐标非法，请重新输入！\n");
		}
	}
}

void Computermove(char board[ROW][COL], int row, int col)
{
	int x = 0;
	int y = 0;
	printf("电脑下：>");
	while (1)
	{
		x = rand() % row;
		y = rand() % col;
		if (board[x][y] == ' ')
		{
			board[x][y] = '#';
			break;
		}
	}
}

int IsFull(char board[ROW][COL], int row, int col)
{
	int i = 0;
	int j = 0;
	for (i = 0; i < row; i++)
	{
		for (j = 0; j < col; j++)
		{
			if (board[i][j] == ' ')
			{
				return 0;
			}
		}
	}
}
 
char Iswin(char board[ROW][COL], int row, int col) //判断输赢
{
	int i = 0;
	for (i = 0; i < row; i++)  //横三行判断
	{
		if (board[i][0] == board[i][1] && board[i][1] == board[i][2] && board[i][1] != ' ')
		{
			return board[i][0];
		}
	}
	for (i = 0; i < col; i++) //竖三列判断
	{
		if (board[0][i] == board[1][i] && board[1][i] == board[2][i] && board[2][i] != ' ')
		{
			return board[0][i];
		}
	}
	if (board[0][0] == board[1][1] && board[1][1] == board[2][2] && board[1][1] != ' ')  //对角线判断
		return board[1][1];
	if (board[2][0] == board[1][1] && board[1][1] == board[0][2] && board[1][1] != ' ')
		return board[1][1];
	if (1 == IsFull(board, ROW, COL))
	{
		return 'Q';
	}
	return 'c';
}


#define _CRT_SECURE_NO_WARNINGS 1
#include <stdio.h>
#include "game.h"

void menu()
{
	printf("**** 1.play  0.exit ****\n");
}

void game()
{
	char ret = 0;
	char board[ROW][COL] = {0};
	InitBoard(board, ROW, COL);
	DisplayBoard(board,ROW,COL);
	while (1)
	{
		Playermove(board,ROW,COL);     //玩家下棋
		DisplayBoard(board, ROW, COL); //显示棋盘
		ret = Iswin(board,ROW,COL);             //判断输赢
		if(ret != 'c')
		{
			break;
		}
		Computermove(board, ROW, COL);
		DisplayBoard(board, ROW, COL);
		ret = Iswin(board, ROW, COL);
		if (ret != 'c')
		{
			break;
		}
	}
	if (ret == '*')
	{
		printf("玩家赢\n");
	}
	else if (ret == '#')
	{
		printf("电脑赢\n");
	}
	else
	{
		printf("平局\n");
	}
}

void test()
{
	int input = 0;
	srand( (unsigned int) time(NULL) );
	do
	{
		menu();
		printf("请选择：");
		scanf("%d", &input);
		switch (input)
		{
		case 1:
			game();
			break;
		case 0:
			printf("退出游戏\n");
			break;
		default:
			printf("选择错误，重新选择：");
			break;
		}
	} while (input);
}




find· fish·
#pragma once
#include<stdio.h>
#define ROW 9
#define COL 9

#define ROWS ROW+2
#define COLS COL+2

#define EASY_COUNT 10

#include<stdlib.h>
#include<time.h>

void Initboard(char board[ROWS][COLS], int rows, int cols, char set);
void DisplayBoard(char board[ROWS][COLS], int row,int col);
void Setmine(char board[ROWS][COLS], int row, int col);
void Findmine(char mine[ROWS][COLS], char show[ROWS][COLS], int row, int col);
#define _CRT_SECURE_NO_WARNINGS 1
#include "game.h"


#define _CRT_SECURE_NO_WARNINGS 1
#include "game.h"

//初始化
void Initboard(char board[ROWS][COLS], int rows, int cols, char set)
{
	int i = 0;
	int j = 0;
	for (i = 0; i < rows; i++)
	{
		for (j = 0; j < cols; j++)
		{
			board[i][j] = set;
		}
	}
}

//打印棋盘
void DisplayBoard(char board[ROWS][COLS], int row, int col)
{
	int i = 0;
	int j = 0;
	for (i = 0; i <= col; i++) //打印列号
	{
		printf("%d ", i);
	}
	printf("\n");              //打印换行
	for (i = 1; i <= col; i++) //打印分割线
	{
		printf("~~");
	}
	printf("\n");
	for (i = 1; i <= row; i++)
	{
		printf("%d ", i);
		printf("|");
		for (j = 1; j <= col; j++)
		{
			printf("%c ", board[i][j]);
		}
		printf("\n");
	}
}

//放鱼(王老师）入塘
void Setmine(char board[ROWS][COLS], int row, int col)
{
	int count = EASY_COUNT;
	while (count)
	{
		int x = rand() % row + 1;
		int y = rand() % col + 1;
		if (board[x][y] == '0')
		{
			board[x][y] = '1';
			count--;
		}
	}
}

int get_mine_count(char mine[ROWS][COLS], int x, int y)
{
	//''里面是ASCII码，有'1'-'0'=1.利用该方法把字符1转换为数字1.
	return  mine[x - 1][y] +
			mine[x - 1][y - 1] +
			mine[x][y - 1] +
			mine[x + 1][y - 1] +
			mine[x + 1][y] +
			mine[x + 1][y + 1] +
			mine[x][y + 1] +
			mine[x - 1][y + 1] - 8 * '0';
}
void Findmine(char mine[ROWS][COLS], char show[ROWS][COLS], int row, int col)
{
	int x = 0;
	int y = 0;
	int win = 0;
	while (win<row*col - EASY_COUNT)
	{
		printf("请输入找鱼的坐标：（如1 1）");
		scanf_s("%d%d", &x, &y);
		if (x >= 1 && x <= 9 && y >= 1 && y <= 9)
		{
			//坐标合法
			if (mine[x][y] == '1')                  //只掉到一条
			{
				printf("很遗憾，其他鱼被吓跑了\n");
				DisplayBoard(mine, row, col);
				break;
			}
			else                                    //统计周围几条鱼,继续钓
			{
				int count = get_mine_count(mine, x, y);
				show[x][y] = count + '0';
				DisplayBoard(show, row, col);
				win++;
			}
		}
		else
		{
			printf("输入坐标错误，请重新输入！\n");
		}
	}
	if (win == row * col - EASY_COUNT)
	{
		printf("姜太公大获全胜！\n");
	}
}
void menu()
{
	printf("      find fish     \n");
	printf("找到鱼的位置并钓起它\n");
	printf("你是贪婪的姜太公，想要一次性钓走整个鱼塘的鱼\n");
	printf("拥有特殊技能的你，可以放下鱼竿并感知周围鱼的尾数\n");
	printf("如果鱼竿直接钓到鱼会吓跑其他鱼\n");
	printf("********************\n");
	printf("*****   1.play    **\n");
	printf("*****   0.exit    **\n");
	printf("********************\n");
}

void game()
{
	char mine[ROWS][COLS] = { 0 }; //11*11
	char show[ROWS][COLS] = { 0 };
	Initboard(mine, ROWS, COLS,'0');
	Initboard(show, ROWS, COLS,'*');
	DisplayBoard(show, ROW, COL);
	Setmine(mine, ROW, COL);
	//DisplayBoard(mine, ROW, COL);
	Findmine(mine, show, ROW, COL);
	printf("\n");
}

void test()
{
	int input = 0;
	srand((unsigned)time(NULL));
	do
	{
		menu();
		printf("请选择：");
		scanf_s("%d", &input);
		switch (input)
		{
		case 1:
			game();
			break;
		case 0:
			printf("退出游戏\n");
			break;
		default:
			printf("选择错误，重新选择\n");
			break;
		}
	} while (input);
}
int main()
{
	test();
	return 0;
}


操作符
算术操作符
int main()
{
	int a = 5 / 2; // 商二余一
	printf(" a = %d\n", a);
	return 0;
}

移位操作符
int main()
{
	int a = 16;
	a >> 1;           //算术右移操作符 0000000000010000(16位二进制数） 变成0000000000001000 右丢左补原符号位
	int b = a >> 1;   //逻辑右移。右丢左补0
	printf("%d\n", b);
	return 0;
}
int main()
{
	int a = -1;
	int b = a >> 2;
	printf("%d\n", b);  //整数存到内存中的是补码
	printf("%d\n", &a); //移位操作符不能移负数
	return 0;
}

位操作符
int main()
{
	int a = 3; //00000000000000000000000000000011
	int b = 5; //00000000000000000000000000000101
	int c = a & b; //00000000000000000000000000000001 按位与
	printf("%d\n", c);
	int d = 3;
	int f = 5;
	int e = d | f; //00000000000000000000000000000111 按位或
	printf("%d\n", e);
	int g = 3;
	int h = 5;
	int q = a ^ b; //00000000000000000000000000000110 按位异或
	printf("%d\n", q);
	return 0;
}

变态面试题：交换两个变量值不使用第三个变量。
int main()
{
	int a = 3;  //00000000000000000000000000000011
	int b = -4; //10000000000000000000000000000100
	//加减法（有缺陷，int范围内可能还行，遇到大数会溢出）
	a = a + b;  //a=-1
	b = a - b;  //b=3
	a = a - b;  //a=-4  实现交换   
	//异或法（不溢出）
	a = a ^ b;  //10000000000000000000000000000111
	b = a ^ b;  //00000000000000000000000000000011
	a = a ^ b;  //10000000000000000000000000000100 (a^b)^a=(a'b+ab')a'+(a'b+ab')'a=a'b+ab=b 实现交换
	return 0;
}

求一个整数存储在内存中的二进制中的二进制数中的个数
int main()                 //只能算正数
{
	int num = 0;
	int count = 0;
	scanf("%d", &num);
	while (num)
	{
		if (num % 2 == 1)
			count++;
		num = num / 2;
	}
	printf("%d\n", count);
	return 0;
}
int main()
{
	int num = 0;
	int count = 0;
	scanf_s("%d", &num);
	int i = 0;
	for (i = 0; i < 32; i++)
	{
		if (1 == ((num >> i) & 1))
			count++;
	}
	printf("%d\n", count);
	return 0;
}

赋值操作符
 = 赋值 可连续赋值但不推荐   ==是判断相等
复合赋值符
int main()
{
	int a = 10;
	a = a + 2;
	a += 2;

	a = a >> 1;
	a >>= 1;

	a = a & 1;
	a &= 1;
	return 0;
}

单目操作符
int main()
{
	int a = 10;
	if (a)
	{
		printf("哈哈\n");
	}
	if (!a)
	{
		printf("呵呵\n");
	}
	printf("%d\n", !a);    // !逻辑取反
	return 0;
}
int main()
{
	int a = 10;
	int*p=&a; //取地址操作符
	*p = 20;  //解引用操作符，指向地址内容
	return 0;
}
int main()
{
	int a = 10;
	char c = 'r';
	char* p = &c;
	int arr[10] = { 0 };
	printf("%d\n", sizeof(a));    //4
	printf("%d\n", sizeof(int));  //4
	printf("%d\n", sizeof(c));    //1
	printf("%d\n", sizeof(char)); //1
	printf("%d\n", sizeof(p));    //4
	printf("%d\n", sizeof(char*));//4
	printf("%d\n", sizeof(arr));  //40
	printf("%d\n", sizeof(int[10]));//40
	return 0;
}
int main()
{
	short s = 0;
	int a = 10;
	printf("%d\n", sizeof(s = a + 5));  //2
	printf("%d\n", s);                  //0
	return 0;
//}
int main()
{
	int a = 0;
	printf("%d\n",~a); //pirntf打印原码，按二进制位取反得到补码存在内存
	int b = 11;
	b = b | (1 << 2);  //按位或
	printf("%d\n", b);
	int c = 1;
	c = c & (~(1 << 2));
	printf("%d\n", a);
	return 0;
}
void test1(int arr[])
{
	printf("%d\n", sizeof(arr));
}
void test2(char ch[])
{
	printf("%d\n", sizeof(ch));
}
int main()
{
	int arr[10] = { 0 };
	char ch[10] = { 0 };
	printf("%d\n", sizeof(arr)); //40
	printf("%d\n", sizeof(ch)); //10
	test1(arr); //4
	test2(ch); //4  传的是指针，所以是数组首元素指针地址大小
	return 0;
}

逻辑操作符
int main()
{
	int i = 0, a = 0, b = 2, c = 3, d = 4;
	//i = a++ && ++b && d++;   // 逻辑短路，一旦第一个为假，后面都不执行。
	i = a++ || ++b || d++;     // 逻辑短路，第一个一旦为真，后面都不执行。
	printf("a=%d\n b=%d\n c=%d\n d=%d\n", a, b, c, d);
	return 0;
}

条件操作符
int main()
{
	int a = 0;
	int b = 0;
	if (a > 5)
		b = 3;
	else
		b = -3;
	b = (a > 5 ? 3 : -3); //三目操作符
	return 0;
}
int main()
{
	int a = 10;
	int b = 20;
	int max = 0;
	max = (a > b ? a : b); //选最大值
	return 0;
}

逗号表达式
int main()
{
	int a = 1;
	int b = 2;
	int c = (a > b, a = b + 10, a, b = a + 1); //从左向右依次执行,最后一个逗号表达式结果是整个的结果
	printf("%d\n", c);
	return 0;
}

下标引用操作符
int main()
{
	int a[10] = { 0 };
	a[4] = 10;
	1 + 2;
	return 0;
}

函数调用操作符()
int get_max(int x, int y)
{
	return (x > y ? x : y);
}
int main()
{
	int a = 0;
	int b = 20;
	int max = get_max(a, b); //操作数： 函数名+（参数）
	printf("max=%d\n", max);
	return 0;
}

结构体操作符
struct Stu
{
	char name[20];
	int age;
	char id[20];
};
int main()
{
	int a = 20;
	struct Stu s1 = { "张夏",20,"20211116" }; //用这个类型创建了一个学生对象，并初始化
	struct Stu* ps = &s1;
	printf("%s\n", (*ps).name);
	printf("%d\n", (*ps).age);
	printf("%s\n", s1.name);
	printf("%d\n", s1.age);
	printf("%s\n", s1.id);    //结构体变量.成员名
	printf("%s\n", ps->name); //结构体指针->成员名
	return 0;
}

表达式求值
隐式类型转换：C的整型算术运算总是以缺省整型类型的精度来进行。为了获得该精度，表达式中的字符和短整型操作数在使用之前被转换为普通整型（整型提升）
int main()
{
	char a = 3;         //00000000000000000000000000000011 a=00000011
	char b = 127;       //00000000000000000000000001111111 b=01111111
	char c = a + b;     //00000000000000000000000010000010 整型提升：按照变量数据类型的符号位提升，再相加。 
	printf("%d\n", c);  //截断后c=100000010 c的符号位变成1（负数） 补成11111111111111111111111110000010(补码） 输出原码10000000000000000000000001111110 -126
	return 0;
}
int main()
{
	char a = 0xb6;      //只能放一个字节，但是里面10110110
	short b = 0xb600;   //b理由类上
	int c = 0xb6000000;
	if (a == 0xb6)      //a整型提升，首位是1，提升后数与原值不符
		printf("a");
	if (b == 0xb600)
		printf("b");
	if (c == 0xb6000000)
		printf("c");
	return 0;
}
int main()
{
	char c = 1;
	printf("u\n", sizeof(c));   //1
	printf("%u\n", sizeof(+c)); //4 进行运算了，计算的是整型大小
	printf("%u\n", sizeof(!c)); //1
	return 0;
}

算术转换：操作符的各操作数属于不同类型，将占空间小的类型转换成大的进行运算。
操作符属性：优先级、结合性、是否控制求值顺序
int main()
{
	int a = 10;
	int b = 20;
	int c = b + a + 3;  //加号从左向右计算
	return 0;
}
逻辑与、逻辑或、逗号表达式、条件操作符会控制求值顺序！
歧义表达式：c + --c 导致左操作数的获取在右操作数之后，结果无法确定
非法表达式
int main()
{
	int i = 10;
	i = i-- - --i * (i = -3) * i++ + ++i; //不同编译器计算路径不同，结果不确定
	printf("i=%d\n", i);
	return 0;
int fun()
{
	static int count = 1;
	return ++count;
}
int main()
{
	int answer;
	answer = fun() - fun() * fun(); //先调用哪个fun函数不确定，调用顺序不同fun值不同
	printf("%d\n", answer);
	return 0;
}
int main()
{
	int i = 1;
	int a = (++i) + (++i) + (++i);
	printf("a = %d\n", a);
	return 0;
}
指针：编程语言中的一个对象，利用地址，它的值直接指向存在带闹闹存储器中另一个地方的值。将地址指向变量单元形象化为指针。
int main()
{
	int a = 0;   //在内存中开辟一块空间
	int* p = &a;  //取出变量a的地址，将其存放在指针变量p中。 指针变量中的值作为地址编号
	return 0;
}
int main() //指针类型，指针进行解引用操作的时候，能够访问空间大小。
{
	int a = 0x11223344;
	int c = 0x11223344;
	int* pa = &a;
	char* pc = &c;      //char不能放int的地址，报错。
	printf("%p\n", pa);
	*pa = 0; //4个都改变，int是四个字节
	*pc = 0; //只改变了一个，因为char是一个字节
	printf("%p\n", pc);
	return 0;
}
int main()   //指针类型决定了指针一步走多远
{
	int a = 0x11223344;
	int* pa = &a;
	char* pc = &a;
	printf("%p\n", pa);
	printf("%p\n", pa + 1); //4个字节
	printf("%p\n", pc);     
	printf("%p\n", pc + 1); //1个字节
	return 0;
}
int main()
{
	int arr[10] = { 0 };
	int* p = arr;
	char* p = arr;
	int i = 0;
	for (i = 0; i < 10; i++)
	{
		*(p + i) = 1;
	}
	return 0;
}

野指针：指针指向位置不可知
指针未初始化   ——要初始化
int main()
{
	int a;    //局部变量不初始化，默认随机值
	int* p;   //局部指针变量被初始化为随机值
	*p = 2;   //内存随机一个被初始化为2
	return 0;
}
 指针访问越界  ——小心越界
int main()
{
	int arr[10] = { 0 };
	int* p = arr;
	int i = 0;
	for (i + 0; i < 12; i++) //指针指向范围超出数组范围，p变成野指针。
	{
		*(p++)=i;
	}
	return 0;
}
 指针指向空间被释放  ——指向空间释放即使之置NULL 使用之前检查有效性
int* test()
{
	int a = 20;
	return &a;
}
int main()
{
	int* p=test(); //test中，指针指向的空间被释放了
	*p = 20;
	return 0;
}
int main()
{
	int a = 10;
	int* pa = &a;
	int* p = NULL;//空指针
	if (pa != NULL)
	{
		//指针使用
	}
	else
	{
		pa = NULL; //指针停用
	}
	return 0;
}

指针运算
指针+-整数
int main()
{
	int arr[10] = { 1,2,3,4,5,6,7,8,9,10 };
	int i = 0;
	int c = 0;
	int sz = sizeof(arr) / sizeof(arr[0]);
	int* p = arr;
	for (i = 0; i < 10; i++)
	{
		printf("%d ", *p);
		p = p + 1;  //可以等效为 p++；
	}
	for (c = 0; c < 5; c++)  //注意修改条件，不然发生越界
	{
		printf("%d ", *p);
		p = p += 2;  //1 3 5 7 9
	}
	return 0;
}
指针-指针
int main()
{
	int arr[10] = { 1,2,3,4,5,6,7,8,9,10 };
	printf("%d\n",& arr[9] - &arr[0]);  //大地址指针-小地址指针得到元素个数
	return 0;
}

int my_strlen(char* str)
{
	char* start = str;
	char* end = str;
	while (*end != '\0')
	{
		end++;
	}
	return end - start;
}
int main()  //模拟strlen函数
{
	char arr[] = "bit";
	int len = my_strlen(arr);
	printf("%d\n", len);
	return 0;
}

指针关系运算
#define N_VALUES 5
float values[N_VALUES];
float* vp;
   //允许指向数组元素的指针与指向数组最后一个元素后面的那个内存位置的指针比较，但不允许与指向第一个元素之前的那个内存位置的指针进行比较
for (vp = &values[N_VALUES]; vp > &values[0];)  
{
	*--vp = 0;
}

int main()
{
	int arr[10] = { 0 };
	printf("%p\n",arr);
	printf("%p\n", arr + 1); // +4

	printf("%p\n", &arr[0]); //数组地址——首元素地址
	printf("%p\n", &arr[0] + 1); // +4

	printf("%p\n", &arr);    //&arr-&数组名 数组名不是首元素地址，而是整个数组地址
	printf("%p\n", &arr + 1);  // +40
	//sizeof（arr）数组名表示整个数组，sizeof计算整个数组大小
	return 0;
}
int main()
{
	int arr[10] = { 0 };
	int* p = arr;
	int i = 0;
	for (i = 0; i < 10; i++)
	{
		printf("%d ", *(p + i) = i);
		//printf("%p ====== %p\n", p + i, &arr[i]); //指针形式打印数组
	}
	return 0;
}

二级指针
int main()
{
	int a = 10;
	int* pa = &a;
	int** ppa = &pa; // 此处ppa就是二级指针，存放指针的指针
	int*** pppa = &ppa; //pppa就是三级指针
	**ppa = 20;
	printf("%d\n", **ppa);
	printf("%d\n", a);
	printf("%p\n", &pppa);
	return 0;
}

指针数组 -数组
数组指针 -指针
int main()
{
	int a = 10;
	int b = 20;
	int c = 30;
	int* arr[3]={&a,&b,&c}; //指针数组
	int i = 0;
	for (i = 0; i < 3; i++)
	{
		printf("%d ", *(arr[i]));
	}
	return 0;
}

//创建一个数组，用函数初始化使其全0，打印数组每个元素
void init(int arr[], int sz)
{
	int i = 0;
	for (i = 0; i < sz; i++)
	{
		arr[i] = i+1;
	}
}
void print(int arr[], int sz)
{
	int i = 0;
	for (i = 0; i < sz; i++)
	{
		printf("%d ", arr[i]);
	}
	printf("\n");
}
void reverse(int arr[],int sz)
{
	int left = 0;
	int right = sz - 1;
	while (left < right)
	{
		int tmp = arr[left];
		arr[left] = arr[right];
		arr[right] = tmp;
		left++;
		right--;
	}
}
int main()
{
	int arr[10] = { 1,2,3,4,5,6,7,8,9,10 };
	int sz = sizeof(arr) / sizeof(arr[0]);
	init(arr, sz);
	print(arr, sz);
	reverse(arr, sz);
	print(arr,sz);
	return 0;
}
交换两个数组内的元素
void print(int arr[], int sz)
{
	int i = 0;
	for (i = 0; i < sz; i++)
	{
		printf("%d ", arr[i]);
	}
	printf("\n");
}
int main()
{
	int arr1[] = { 1,3,5,7,9 };
	int arr2[] = { 2,4,6,8,0 };
	int tmp = 0;
	int i = 0;
	int sz = sizeof(arr1) / sizeof(arr1[0]);
	for (i = 0; i < sz; i++)
	{
		tmp = arr1[i];
		arr1[i] = arr2[i];
		arr2[i] = tmp;
	}
	print(arr1, sz);
	print(arr2, sz);
	return 0;
}

int i; //全局变量不初始化，默认0
int main()
{
	i--;
	if (i > sizeof(i)) // sizeof计算变量/类型所占内存大小，是无符号数 -1变成2^32-1
	{
		printf(">\n");
	}
	else
	{
		printf("<\n");
	}
	return 0;
}

求二进制中不同位的个数
int main()
{

	return 0;
}

求二进制中1的个数
int count_bit_one(unsigned int n) //把有符号数转换成无符号数，就可以算负数了
{
	int count = 0;
	while (n)           //不能算负数
	{
		if (n % 2 == 1)
		{
			count++;
		}
		n = n / 2;
	}
	return count;
}
int count_bit_one(int n) //移位，按位与1
{
	int count = 0;
	int i = 0;
	for (i = 0; i < 32; i++)
	{
		if ((n >> i) & 1 == 1)
		{
			count++;
		}
	}
	return count;
}
打印二进制奇数位和偶数位
void print(int m)
{
	int i = 0;
	printf("奇数位: \n");
	for (i = 30; i >= 0; i -= 2)
	{
		printf("%d", (m >> i) & 1);
	}
	printf("\n");
	printf("偶数位: \n");
	for (i = 31; i >= 1; i -= 2)
	{
		printf("%d", (m >> i) & 1);
	}
	printf("\n");
}
int main()
{
	int m = 0;
	scanf("%d", &m);
	print(m);
	return 0;
}

用指针打印数组内容
void print(int* p, int sz)
{
	int i = 0;
	for (i = 0; i < sz; i++)
	{
		printf("%d", *(p + i));
	}
}
int main()
{
	int arr[] = { 1,2,3,4,5,6,7,8,9 };
	int sz = sizeof(arr) / sizeof(arr[0]);
	print(arr, sz);
	return 0;
}

nn乘法表
void print(int n)
{
	int i = 0;
	for (i = 0; i <= n; i++)
	{
		int j = 0;
		for (j = 0; j <= n; j++)
		{
			printf("%d x %d=%-3d ", i, j, i * j);
		}
		printf("\n");
	}
}
int main()
{
	int n = 0;
	scanf_s("%d", &n);
	print(n);
	return 0;
}
递归实现字符串逆序(不能使用库函数）
int my_strlen(char* str)  //替代库函数strlen
{
	int count = 0;
	while (*str != '\0')
	{
		count++;
		str++;
	}
	return count;
}
循环方式实现
void reverse_string(char arr[])
{
	int left = 0;
	int right = my_strlen(arr) - 1;  
	while (left < right)
	{
		int tmp = arr[left];
		arr[left] = arr[right];
		arr[right] = tmp;
		left++;
		right--;
	}
}
void reverse_string(char* arr)
{
	char tmp = arr[0];
	int len = my_strlen(arr);  
	arr[0] = arr[len - 1];
	arr[len - 1] = '\0';
	if (my_strlen(arr+1) >= 2)
		reverse_string(arr + 1);
	arr[len - 1] = tmp;
}
int main()
{
	char arr[] = "abcdef";
	reverse_string(arr);
	printf("%s\n", arr);
	return 0;
}

计算一个数的每位之和（递归）
int DigitSum(unsigned int num)
{
	if (num > 9)
	{
		return DigitSum(num/10) + num % 10;
	}
	else
	{
		return num;
	}
}
int main()
{
	unsigned int num = 0;
	scanf_s("%d", &num);
	int ret = DigitSum(num);
	printf("ret = %d\n", ret);
	return 0;
}

计算n^k的值
double Pow(int n,int k)
{
	if (k < 0)
		return (1 / (Pow(n, -k)));
	else if (k == 0)
		return 1;
	else
		return n * Pow(n, k - 1);
}
int main()
{
	int n = 0;
	int k = 0;
	scanf_s("%d%d", &n, &k);
	double ret = Pow(n,k);
	printf("ret = %lf\n", ret);
}
c语言调试
bug 臭虫，导致计算机出错。
调试Debug：除错，即找bug的过程。所有的bug都有迹可循，调试就是顺藤摸瓜。
基本步骤：
发现程序错误的存在    （程序员）bug写的少  （软件测试人员）bug找到的多    用户发现bug（代价巨大）
以隔离、消除等方式对错误进行定位
确定错误产生的原因
提出错误解决办法
对程序错误予以改正、重新测试
int main()                      //debug:调试版本  可以调试的
{                               //release：发布版本。有优化，体积小、运行速度快。测试测该版本
	int i = 0;
	for (i = 0; i < 100; i++)
	{
		printf("%d", i);
	}
	system("pause");
	return 0;
}
 F5启动调试
int main()
{
	int i = 0;
	int arr[10] = { 1,2,3,4,5,6,7,8,9,10 };  //debug版本： 死循环
	for (i = 0; i <= 12; i++)                //release版本： 13个hehe
	{
		printf("hehe\n");
		arr[i] = 0;
	}
	system("pause");
	return 0;
}
 F9断点，切换断点  
int main()
{
	int i = 0;
	for (i = 0; i < 100; i++)
	{
		printf("%d ", i);
	} 
	// 断点和F5：快速跳到要调试的部分。 F5跳到逻辑上遇到的下一个断点，再F10一步一步调试
	for (i = 0; i < 100; i++)
	{
		printf("%d ", 10 - i);
	}
	return 0;
}
 F11逐语句：不放过细节
int add(int x, int y)
{
	return x + y;      //看完了，shift F11跳出函数
}
int main()
{
	printf("hehe\n");
	int a = 10;
	int b = 20;
	int c = add(a, b);
}

int main()
{
	{
		int tmp = 0;
		printf("tmp=%d\n", tmp);
	}
	int arr[10] = { 0 };
	int i = 0;
	for (i = 0; i < 10; i++)
	{
		arr[i] = i;
	}

	return 0;
}
void test2()
{
	printf("hehe\n");
}
void test1()
{
	test2();
}
void test()
{
	test1();
}
int main()
{
	test();
	return 0;
}

实例1：求1！+2！+……+n！
int main()
{
	int i = 0;
	int sum = 0;
	int n = 0;
	int ret = 1;
	scanf_s("%d", &n);
	for (i = 1; i <= n; i++)
	{
		int j = 0;
		for (j = 1; j <= i; j++)
		{
			ret *= j;
		}
		sum += ret;
		ret = 1;
	}
	printf("%d\n", sum);
	return 0;
}

实例2 为啥死循环
int main()
{
	int i = 0;
	int arr[10] = { 1,2,3,4,5,6,7,8,9,10 };
	for (i = 0; i <= 12; i++)               //第一次循环结束后，i从12又变回0，重复变成死循环
	{                                       //改变arr[12]时，i变成0、 arr[12]与i是同一地址
		printf("hehe\n");                   //i，arr都属于局部变量放在栈区。栈区：先使用高地址空间，再使用低地址空间；数组随着下标增长，地址由低到高。
		arr[i] = 0;							//数组越界过程中，遇到了i的地址，并把它改成了0，从而重置了循环
	}										//vs中<=12 就死循环;但i如果创建在arr下面就不会死循环，但会报错。
	system("pause");
	return 0;
}

优秀代码
 运行正常、bug少、效率高、可读性高、可维护性高、注释清晰、文档齐全
技巧：使用assert、尽量用const、良好编码风格、必要注释、避免编码陷阱
范例：模拟库函数strcpy(字符串拷贝)
#include<assert.h> //断言：会报错
void my_strcpy(char* dest, const char* src)
{
	assert(dest != NULL);
	assert(src != NULL);
	while (*dest++ = *src++;)
	{
		;
	}
	*dest = *src;
}
int main()
{
	char arr1[] = "##########";
	char arr2[] = "bit";
	my_strcpy(arr1, arr2);
	printf("%s\n",arr1);
	return 0;
}
int main()
{
	const int num = 10;
	const int* p = &num;
	*p = 20; // error 放在指针变量左边时，修饰的是*p 不能通过p去修改num了。
	printf("%d\n", num);
}

 数据的存储
重点 ：数据类型、整型在内存中的存储、大小端字节序介绍及判断、浮点型在内存中的存储解析

1 数据类型详细介绍
 内置类型：系统自带的
char        //字符数据类型
short		//短整型
int			//整型
long		//长整型
long long   //更长的整型
float		//单精度浮点数
double		//双精度浮点数
 自定义类型（构造类型）
意义：类型决定开辟内存空间的大小，大小决定了适用范围。
int main()
{
	int a = 10;     //4字节
	float f = 10.0; //4字节
	return 0;
}
内置类型：
整型家族： 
char （unsigned char ,signed char)
short (unsigned short[int] ,signed short[int])
int   (unsigned int,signed int)
long  (unsigned long[int].signed long[int])
浮点型家族：
float  
double

构造类型：
数组类型
结构体类型 struct
枚举类型   enum
联合类型   union

指针类型
int*pi;
char*pc;
float*pf;
void*pv;  

空类型:无类型、无返回。通常应用于函数返回类型、函数参数、指针类型

整型在内存中的存储
int main()
{
	int a = 20;
	//00000000000000000000000000010100 原码 0x00000014 (0x表示十六进制)
	//正数三码合一
	int b = -10;
	//10000000000000000000000000001010 原码 
	//11111111111111111111111111110101 反码
	//11111111111111111111111111110110 补码 0xFFFFFFF6
	//内存中从右往左存补码 即F6 FF FF FF
	return 0;
}
原码、反码、补码
整型采用，无符号数三码相同
计算机系统中，数值一律用补码来表示和存储。原因：使用补码，可以将符号位和数值域统一处理；加法和减法也可以统一处理。此外，补码原码相互转换不需额外硬件电路。
int main()
{
	1 - 1;
	//1 + (-1)
	return 0;
}

大端小端：多个字节安排问题
大端（存储）模式：数据低位保存在内存高位，数据高位存在内存低位
小端（存储）模式：数据高位保存在内存高位，数据低位存在内存低位
简述大端字节序和小端字节序的概念，并设计小程序来判断当前机器进行的字节序
int check_sys()
{
	int a = 1;
	return *(char*)&a;   //返回1小端，返回0大端
}
int main()
{
	int ret = check_sys();
	if (*p == 1)
	{
		printf("小端\n");
	}
	else
	{
		printf("大端\n");
	}
	return 0;
}
int main()
{
	char a = -1;         //-1
	signed char b = -1;  //-1
	unsigned char c = -1;//255
	printf("a=%d b=%d c=%d", a, b, c);
	char d = -128;     //整型提升后11111111111111111111111110000000（补码） 无符号数三码合一
	printf("%u\n", d); // %u打印十进制无符号数
	return 0;
}
 10000000 = -128
有符号char 范围： -128——127
无符号char 范围： 0——255
int main()
{
	char a = 128; //相当于127+1 变回 -128 输出结果同char a =-128
	return 0;
}

int main()
{
	int i = -20;            //10000000 00000000 00000000 00010100原码
	unsigned int j = 10;    //00000000 00000000 00000000 00001010原码
	printf("%d\n", i + j);  //11111111 11111111 11111111 11110101补码  -10
	return 0;
}
#include<windows.h>
int main()
{
	unsigned int i;          // i永远大于等于0
	for (i = 9; i >= 0; i--) //死循环
	{
		printf("%u\n", i);
		Sleep(100);
	}
	return 0;
}
int main()
{
	char a[1000]; //char类型的数组，有1000个元素
	int i;
	for (i = 0; i < 1000; i++)
	{
		a[i] = -1 - i;
	}
	printf("%d", strlen(a));
	return 0;
}
unsigned char i = 0;
int main()
{
	for (i = 0; i <= 255; i++)
	{
		printf("hello world\n");
	}
	return 0;
}
浮点型在内存的存储
int main()
{
	int n = 9; //0000000 000000000 00000000 00001001
	float* pFloat = (float*)&n;
	printf("n的值：%d\n", n);
	printf("*pFloat的值：%f\n", *pFloat); //0 00000000 000000000001001 e=00000000 所以（-1）^0*0.000000000001001*2^-126
	*pFloat = 9.0; //1001.0  =(-1)^S*M*2^E = (-1)^1.001*2^3   0 10000010 00100000000000000000000
 //内存中：SEM 1+8+23（32bit)  1+11+52(64bit)
	printf("n的值：%d\n", n);  //01000001 00010000 00000000 00000000
	printf("*pFloat的值：%f\n", *pFloat);
	return 0;
}
int main()
{
	float f = 5.5; //101.1 = (-1)^0*2^2     s=0,m=1.011,e=2  0 10000001 01100000000000000000000=0x40b00000=00 00 b0 40
	return 0;
}

指针详解
void test(int arr[]) //首元素地址传过去了
{
	int xz = sizeof(arr) / sizeof(arr[0]);
	printf("%d\n", xz);  //2  指针大小/单个元素大小 8/4

}
int main()
{
	int arr[10] = { 0 };
	test(arr);
	return 0;
}
int main()
{
	char ch = 'w';
	char* pc = &ch;
	return 0;
}
int main()
{
	char arr[] = "abcdef";
	char* pc = arr;
	printf("%s\n", arr);
	printf("%s\n", pc);
	return 0;
}
int main()
{
	const char* p = "abcdef"; //"abcdef"是个常量字符串，将a的地址赋给p
	//printf("%c\n", p);
	//printf("%s\n", p);
	//*p = 'w'; // error *p是常量，不能修改
	//printf("%s\n", p);
	return 0;
}

字符指针
 int main()
{
char arr1[] = "abcdef";
char arr2[] = "abcdef";
const char* p1 = "abcdef"; //为了节省空间，无法修改的"abcdef"在内存中只有一个。所以p1，p2都指向同一地址
const char* p2 = "abcdef";
if (arr1 == arr2)
{
	printf("hehe\n");
}
else
{
	printf("haha\n");
}
if (p1 == p2)
{
	printf("hehe\n");
}
else
{
	printf("haha\n");
}
return 0;
}
 
 数组指针 是数组
int main()
{
	int arr[10] = { 0 }; //整型数组
	char ch[5] = { 0 };  //字符数组
	int* parr[4]; //存放整型指针的数组
	char* pch[5]; //存放字符指针的数组
	return 0;
}
int main()
{
	int a = 10;
	int b = 20;
	int c = 30;
	int d = 40;
	int* arr[4] = { &a,&b,&c,&d };
	int i = 0;
	for (i = 0; i < 4; i++)
	{
		printf("%d", *(arr[i]));
	}
	return 0;
}
int main()
{
	int arr1[] = { 1,2,3,4,5 };
	int arr2[] = { 2,3,4,5,6 };
	int arr3[] = { 3,4,5,6,7 };
	int* parr[3] = { arr1,arr2,arr3 };
	int i = 0;
	for (i = 0; i < 3; i++)
	{
		int j = 0;
		for (j = 0; j < 5; j++)
		{
			printf("%d ", *(parr[i] + j));
		}
		printf("\n");
	}
	return 0;
}

 数组指针 是指针
int main()
{
	int* p = NULL; //整型指针——指向整型的指针
	char* pc = NULL; //字符指针 —— 指向字符的指针
	// 数组指针 —— 指向数组的指针，存放数组的地址
	int arr[10] = { 1,2,3,4,5,6,7,8,9,10 };
	int (* p)[10] = &arr; //数组地址存起来 *p就是一个数组指针
	return 0;
}
int main()
{
	char* arr[5];
	char*(*pa)[5] = &arr; //数组类型+指针变量+数组元素个数 = &数组名（表示数组地址而不是首元素地址）；
	return 0;
}
int main()
{
	int arr[10] = { 1,2,3,4,5,6,7,8,9,10 };
	int(*pa)[10] = &arr;
	int i = 0;
	for (i = 0; i < 10; i++) //可以这么用，但不方便
	{
		printf("%d ", (*pa)[i]);
	}
	return 0;
}
void print1(int arr[3][5], int x, int y)
{
	int i = 0;
	int j = 0;
	for (i = 0; i < x; i++)
	{
		for (j = 0; j < y; j++)
		{
			printf("%d ", arr[i][j]);
		}
		printf("\n");
	}
}
void print2(int(*p)[5], int x, int y) //用数组指针传二维数组的第一行数组
{
	int i = 0;
	int j = 0;
	for (i = 0; i < x; i++)
	{
		for (j = 0; j < y; j++)
		{
			printf("%d ", *(*(p + i) + j)); //用指针（行地址+列地址）指向每个元素
			printf("%d ", p[i][j]); // 与上式等价
		}
		printf("\n");
	}
}
int main()
{
	int arr[3][5] = { {1,2,3,4,5},{2,3,4,5,6},{3,4,5,6,7} };
	print1(arr, 3, 5);
	print2(arr, 3, 5);
	return 0;
}
int main()
{
	int arr[10] = { 1,2,3,4,5,6,7,8,9,10 };
	int i = 0;
	int* p = arr;
	for (i = 0; i < 10; i++)
	{
		printf("%d ", *(p + i));
		printf("%d ", *(arr + i));
		printf("%d ", arr[i]);      // arr[i] == *(arr+i) == *(p+i) == p[i]
	}
}
小结
int main()
{
	char ch = 'w';
	char* p = &ch;
	const char* p2 = "abcdef";
	//指针数组 - 数组 - 存放指针的数组
	int* arr[10];
	char* ch[5];
	//数组指针
	//int* p3;   //整型指针
	//char* p4;  //字符指针
	int arr2[5]; //数组
	int(*pa)[5] = &arr2; 
	return 0;
}
  int* parr1 [10] //数组，有10个元素，每个元素是int类型的指针。 指针数组
  int  (*parr2) [10] //指针，指向了一个10元素数，每个元素类型是int. 数组指针
  int  (*parr3[10]) [5] //数组，数组有10个元素，每个元素是一个数组指针;指针指向5元素数组，每个元素是int。
 数组传参和指针传参
void test(int arr[]) // ok
{}
void test(int arr[10]) // ok
{}
void test(int* arr) // ok
{}
void test2(int*arr[20]) // ok 20可以省略
{}
void test2(int**arr) // ok
{}
int main()
{
	int arr[10] = { 0 };
	int* arr2[20] = { 0 };
	test(arr);
	test2(arr2);
}
void test(int arr[3][5])
{}
void test1(int arr[][5]) //不可以省略列
{}
void test2(int (*arr)[5])
{}
void test3(int*(*arr[5]))
{}
int main()
{
	int arr[3][5] = { 0 };
	test(arr); //二维数组传参
	return 0;
}

void print(int* p, int sz) //一级指针传参
{
	int i = 0;
	for (i = 0; i < sz; i++)
	{
		printf("%d\n", *(p + i));
	}
}
int main()
{
	int arr[10] = { 1,2,3,4,5,6,7,8,9 };
	int* p = arr;
	int sz = sizeof(arr) / sizeof(arr[0]);
	print(p, sz);
	return 0;
}
void test1(int* p)
{}
void test2(char*p)
{}
int mian()
{
	int a = 10;
	int* p1 = &a;
	test1(&a); // ok
	test1(p1); // ok
	char ch = 'w';
	char* pc = &ch;
	test2(&ch); //ok
	test2(pc); //ok
	return 0;
}
void test(int** ptr) //二级指针传参
{
	printf("num=%d\n", **ptr);
}
int mian()
{
	int n = 10;
	int* p = &n;
	int** pp = &p;
	test(pp);
	test(&p);
	return 0;
}
void test(int**p)
{}
int main()
{
	int* ptr;
	int** pp = &ptr;
	test(&ptr); //一级指针地址
	test(pp); // 二级指针本身
	int* arr[10];
	test(arr); //存放一级指针的数组
	return 0;
}

 函数指针：是指向函数的指针
int add(int x, int y)
{
	return x + y;
}
int main()
{
	int a = 0;
	int b = 10;
	int (* pa)(int,int) = add; //函数类型+指针变量+参数类型
	// &函数名和函数名 都是函数的地址
	printf("%d\n", add(a, b));
	printf("%p\n", &add);
	printf("%d\n", (*pa)(2, 3));
}
void print(const char* str)
{
	printf("%s\n", str);
}
int main()
{
	void (*p)(const char*)=print;
	(*p)("hello");
	return 0;
}
( *(void(*) () ) 0) ();
void (*signal( int, void(*)(int) )) (int);
typedef void(* pfun_t)(int); //函数声明
 pfun_t signal(int, pfun_t); //相当于1
 
 函数指针数组
int Add(int x, int y)
{
	return x + y;
}
int Sub(int x, int y)
{
	return x - y;
}
int Mul(int x, int y)
{
	return x * y;
}
int Div(int x, int y)
{
	return x / y;
}
int main()
{
	int* arr[5]; //指针数组
	int(*pa)(int, int) = Add;
	int(*parr[4])(int, int) = { Add,Sub,Mul,Div };
	int i = 0;
	for (i = 0; i < 4; i++)
	{
		printf("%d\n",parr[i](2, 3)); // 5 -1 6 0
	}
	return 0;
}
char* my_strcpy(char* dest, const char* src);
// 写一个函数指针pf，能够指向my_strcpy
char* (*pf)(char*, const char*);
// 写一个函数指针数组 pfArr，能够存放4个my_strcpy函数的地址
char* (*pfArr[4])(char*, const char*);
计算器
void menu()
{
	printf("******************\n");
	printf("**1.add    2.sub**\n");
	printf("**3.mul    4.div**\n");
	printf("**  0.退出程序  **\n");
	printf("******************\n");
}
int add(int x, int y)
{
	return x + y;
}
int sub(int x, int y)
{
	return x - y;
}
int mul(int x, int y)
{
	return x * y;
}
int div(int x, int y)
{
	return x / y;
}
int main()
{
	int input = 0;
	int x = 0;
	int y = 0;
	int(*pfArr[5])(int, int) = { 0,add,sub,mul,div }; // 用作转移表
	do
	{
		menu();
		printf("请选择：");
		scanf_s("%d", &input);
		if (input >= 1 && input <= 4)
		{
			printf("请输入两个操作数：");
			scanf_s("%d%d", &x, &y);
			int ret = pfArr[input](x, y);
			printf("%d\n", ret);
		}
		else if (input == 0)
		{
			printf("退出\n");
		}
		else
		{
			printf("选择错误！\n");
		}
	} while (input);
	return 0;
}

int main() //冗余
{
	int input = 0;
	int x = 0;
	int y = 0;
	do
	{
		menu();
		printf("请选择:\n");
		scanf_s("%d", &input);

		switch (input)
		{
		case 1:
			printf("%d\n", add(x, y));
			printf("请输入两个操作数:");
			scanf_s("%d%d", &x, &y);
			break;
		case 2:
			printf("%d\n", sub(x, y));
			printf("请输入两个操作数:");
			scanf_s("%d%d", &x, &y);
			break;
		case 3:
			printf("%d\n", mul(x, y));
			printf("请输入两个操作数:");
			scanf_s("%d%d", &x, &y);
			break;
		case 4:
			printf("%d\n", div(x, y));
			printf("请输入两个操作数:");
			scanf_s("%d%d", &x, &y);
			break;
		case 0:
			printf("请输入两个操作数:");
			scanf_s("%d%d", &x, &y);
			printf("退出\n");
			break;
		default:
			printf("输入错误，请重输！");
		}
	} while (input);
	return 0;
}
 指向函数指针数组的指针
int Add(int x, int y)
{
	return x + y;
}
int main()
{
	int arr[10] = { 0 };
	int(*p)[10] = &arr; //取出数组的地址
	int (*pfArr[4])(int, int); //指针数组
	int(*(*ppfArr)[4])(int, int) = &pfArr; //ppfArr是一个数组指针，指针指向的数组有4个元素。指向数组的元素类型是函数指针
	return 0;
}

 回调函数：通过函数指针调用的函数。
 回调函数不是由该函数的实现方直接调用，而是在特定事件或条件发生时由另外一方调用的，用于对该事件或条件进行响应。
void calc(int (*pf)(int, int))
{
	int x = 0;
	int y = 0;
    printf("请输入两个操作数:");
	scanf_s("%d%d", &x, &y);
	printf("%d\n", pf(x, y));
}
void print(const char* str)
{
	printf("hehe:%s", str);
}
void test(void(*p)(const char*))
{
	printf("test\n");
	p("bit");
}
int main()
{
	test(print);
	return 0;
}
void BubbleSort(int arr[], int sz)
{
	//冒泡排序函数，只能排整型数组
}
//qsort:可以排序任意类型的数据
//void qsort(void* base, size_t num, size_t width, int(*cmp)(const void* e1, const void* e2))
#include <stdlib.h>
int cmp_int (const void* e1,const void* e2) // void*类型的指针可以接受任意类型的地址
{
	return *(int*)e1 - *(int*)e2;
}
void test1()
{
	int arr[] = { 1,3,5,7,9,2,4,6,8,10 };
	int sz = sizeof(arr) / sizeof(arr[0]);
	qsort(arr, sz, sizeof(arr[0]), cmp_int);
	int i = 0;
	for (i = 0; i < sz; i++)
	{
		printf("%d ", arr[i]);
	}
}
int cmp_float(const void* e1, const void* e2) // void*类型的指针可以接受任意类型的地址
{
	return ((int)( * (float*)e1 - *(float*)e2));
}
void test2()
{
	float f[] = { 9.0, 8.0, 7.0, 5.0, 10.0 };
	int sz = sizeof(f) / sizeof(f[0]);
	qsort(f, sz, sizeof(f[0]), cmp_float);
	int j = 0;
	for (j = 0; j < sz; j++)
	{
		printf("%f ", f[j]);
	}
}
struct stu
{
	char name[20];
	int age;
};
int cmp_stu_by_age(const void* e1, const void* e2)
{
	return ((struct stu*)e1)->age - ((struct stu*)e2)->age;
}
#include<string.h>
int cmp_stu_by_name(const void* e1, const void* e2)
{
	return strcmp(((struct stu*)e1)->name, ((struct stu*)e1)->name);  //字符串比较不能直接用大于小于比较，应该用strcmp
}
void test3()
{
	struct stu s[3] = { {"zhangsan",20},{"lisi",30},{"wangwu",15} };
	int sz = sizeof(s) / sizeof(s[0]);
	qsort(s, sz, sizeof(s[0]), cmp_stu_by_age);
}
void test4()
{
	struct stu s[3] = { {"zhangsan",20},{"lisi",30},{"wangwu",15} };
	int sz = sizeof(s) / sizeof(s[0]);
	qsort(s, sz, sizeof(s[0]), cmp_stu_by_name);
}
void Swap(char* buf1, char* buf2, int width)
{
	int i = 0;
	for (i = 0; i < width; i++)
	{
		char tmp = *buf1;
		*buf1 = *buf2;
		*buf2 = tmp;
		buf1++;
		buf2++;
	}
}
void bubble_sort(void* base, int sz, int width,int (*cmp)(const void*e1,const void*e2))
{
	int i = 0;
	for (i = 0; i < sz - 1; i++)
	{
		int j = 0;
		for (j = 0; j < sz - 1 - i; j++)
		{
			if (cmp((char*)base + j * width, (char*)base + (j + 1) * width) > 0)
			{
				Swap((char*)base+j*width,(char*)base+(j+1)*width,width);
			}
		}
	}
}
void test5()
{
	int arr[10] = { 9,8,7,6,5,4,3,2,1,0 };
	int sz = sizeof(arr) / sizeof(arr[0]);
	bubble_sort(arr,sz,sizeof(arr[0]),cmp_int);
	int i = 0;
	for (i = 0; i < sz; i++)
	{
		printf("%d ", arr[i]);
	}
}
int main()
{
	test1();
	test2();
	test3();
	test5();
	//BubbleSort(arr, sz);
	return 0;
}
指针和数组面试题解析
int main()
{
	//int a[] = { 1,2,3,4 };
	//printf("%d\n", sizeof(a));      //16   数组
	//printf("%d\n", sizeof(a+0));	//4/8  此处a表示首元素地址，+0还是首元素地址
	//printf("%d\n", sizeof(*a));		//4    首元素
	//printf("%d\n", sizeof(a+1));	//4/8  第二个元素地址
	//printf("%d\n", sizeof(a[1]));	//4    第二个元素
	//printf("%d\n", sizeof(&a));		//4/8  取出的是数组的地址，地址大小还是4
	//printf("%d\n", sizeof(*&a));	//16   抵消，还是数组
	//printf("%d\n", sizeof(&a+1));	//4/8  虽然跳过整个数组，但还是地址
	//printf("%d\n", sizeof(&a[0]));	//4/8  第一个元素的地址
	//printf("%d\n", sizeof(&a[0]+1));//4/8  第二个元素地址

	//char arr[] = { 'a','b','c','d','e','f' };
	//printf("%d\n", sizeof(arr));        //6  6*1bit
	//printf("%d\n", sizeof(arr + 0));	//4/8 首元素地址
	//printf("%d\n", sizeof(*arr));		//1   首元素地址解引用，计算首元素大小
	//printf("%d\n", sizeof(arr[1]));	    //1   第二个元素
	//printf("%d\n", sizeof(&arr));		//4/8
	//printf("%d\n", sizeof(&arr + 1));	//4/8
	//printf("%d\n", sizeof(&arr[0] + 1));//4/8

	char arr[] = { 'a','b','c','d','e','f' };
	printf("%d\n", strlen(arr));       //随机值 strlen计算字符串长度，找到\0才停止
	printf("%d\n", strlen(arr+0));	   //随机值
	printf("%d\n", strlen(*arr));	   //error 将'a'转换成ASCII码 97 访问0x00000097地址
	printf("%d\n", strlen(arr[1]));    //error
	printf("%d\n", strlen(&arr));      //随机值
	printf("%d\n", strlen(&arr+1));    //随机值，与上一个随机值-6
	printf("%d\n", strlen(&arr[0]+1)); //随机值，与上一个随机值+5
	return 0;
}

int main()
{
	char arr[] = "abcdef";
	printf("%d\n", sizeof(arr));       //7   a b c d e f \0
	printf("%d\n", sizeof(arr+0));	   //4/8 首元素地址大小
	printf("%d\n", sizeof(*arr));	   //1   首元素大小
	printf("%d\n", sizeof(arr[1]));	   //1   第二元素大小
	printf("%d\n", sizeof(&arr));	   //4/8 数组地址大小
	printf("%d\n", sizeof(&arr+1));	   //4/8 跳过整个数组后的地址
	printf("%d\n", sizeof(&arr[0]+1)); //4/8 第二个元素地址

	printf("%d\n", strlen(arr));       //6   a b c d e f
	printf("%d\n", strlen(arr+0));	   //6   从首元素开始往后算，一共6个
	printf("%d\n", strlen(*arr));	   //error
	printf("%d\n", strlen(arr[1]));	   //error  把第二个字符的ASCII值当作地址，依然非法访问
	printf("%d\n", strlen(&arr));	   //6      数组起始地址往后计算字符长度
	printf("%d\n", strlen(&arr+1));	   //随机值 跳过整个数组后的地址
	printf("%d\n", strlen(&arr[0]+1)); //5      第二个元素地址开始往后计算              

	const char* p = "abcdef";
	printf("%d\n", sizeof(p));          //4/8  指针变量大小
	printf("%d\n", sizeof(p + 1));      //4/8  第二个字符的地址
	printf("%d\n", sizeof(*p));         //1    首字符大小
	printf("%d\n", sizeof(p[0]));       //1    p[0] == *(p+0) =='a'
	printf("%d\n", sizeof(&p));         //4/8  取地址，计算地址大小
	printf("%d\n", sizeof(&p + 1));     //4/8  还是地址
	printf("%d\n", sizeof(&p[0] + 1));  //4/8  取b的地址
	 
	printf("%d\n", strlen(p));          //6
	printf("%d\n", strlen(p + 1));      //5
	printf("%d\n", strlen(*p));         //error
	printf("%d\n", strlen(p[0]));       //error
	printf("%d\n", strlen(&p));         //6
	printf("%d\n", strlen(&p + 1));     //随机值
	printf("%d\n", strlen(&p[0] + 1));  //5
	return 0;
}

二维数组
int main()
{
	int a[3][4] = { 0 };
	printf("%d\n", sizeof(a));           //48   3*4*4
	printf("%d\n", sizeof(a[0][0]));     //4    首行首元素
	printf("%d\n", sizeof(a[0]));        //16   4*4 a[0]单独放入sizeof作为一维数组，计算第一行大小
	printf("%d\n", sizeof(a[0]+1));      //4/8  a[0]+1作为第一行第二个元素的地址。a[0]是第一行的数组名，放在表达式是代表首元素地址
	printf("%d\n", sizeof(*(a[0]+1)));   //4    第一行第二个元素的大小
	printf("%d\n", sizeof(a+1));         //4/8  第二行数组的地址，计算的是地址大小
	printf("%d\n", sizeof(*(a+1)));      //16   第二行数组的大小
	printf("%d\n", sizeof(&a[0]+1));     //4    第二行的地址
	printf("%d\n", sizeof(*(&a[0]+1)));  //16   计算第二行大小
	printf("%d\n", sizeof(*a));          //16   计算第一行大小
	printf("%d\n", sizeof(a[3]));        //16   计算第四行大小。 sizeof不访问数组内容，只计算数组大小
}

 test1
int main()
{
	int a[5] = { 1,2,3,4,5 };
	int* ptr = (int*)(&a + 1);
	printf("%d,%d\n", *(a + 1), *(ptr - 1)); // 2,5
	return 0;
}

 test2
假设p的值为0x100000,如下表达式的值分别为多少？
已知结构体类型变量大小是20个字节。
struct Test
{
	int Num;
	char* pcName;
	short sDate;
	char cha[2];
	short sBa[4];
}*p;
int main()
{
	p = (struct Test*) 0x100000;
	printf("%p\n", p + 0x1);                //0x100014 跳过一个结构体20个字节，十六进制就是14
	printf("%p\n", (unsigned long)p + 0x1); //0x100001 整数+1
	printf("%p\n", (unsigned int*)p + 0x1); //0x100004 地址+1
	return 0;
}

test3
int main()
{
	int a[4] = { 1,2,3,4 };
	int* ptr1 = (int*)(&a + 1);       //数组地址+1，再强行转换成整型地址
	int* ptr2 = (int*)((int)a + 1);   //首元素地址强行转换成整数，+4bit后强行转换成整型地址
	printf("%x,%x", ptr1[-1], *ptr2); //ptr1[1] == *(ptr1+(-1)) , 小端存储后移一位再还原回去 
	return 0;
}

test4
int main()
{
	int a[3][2] = { (0,1),(2,3),(4,5) }; //(,)逗号表达式，数组里实际是{1,3,5}
	int* p;
	p = a[0];
	printf("%d", p[0]);
	return 0;
}

test5
int main()
{
	int a[5][5]; //二维数组
	int(*p)[4];  //数组指针，指向四个整型元素的数组
	p = (int(*)[4])a; //将a强制转换为p的类型
	printf("%p,%d\n", &p[4][2] - &a[4][2], &p[4][2] - &a[4][2]);
	return 0;
}

test6
int main()
{
	int aa[2][5] = { 1,2,3,4,5,6,7,8,9,10 };
	int* ptr1 = (int*)(&aa + 1);
	int* ptr2 = (int*)(*(aa + 1));
	printf("%d,%d\n", *(ptr1 - 1), *(ptr2 - 1)); //
	return 0;
}

test7
int main()
{
	const char* a[] = { "work","at","alibaba" }; // {char* w,char*a,char*a}
	const char** pa = a;                         // char*(*pa) = char*a (char*w)
	pa++;                                        //指向char*a
	printf("%s\n", *pa); //at                    
	return 0;
}

test8
int main()
{
	const char* c[] = { "ENTER", "NEW", "POINT", "FIRST" };  // {char*E,char*N,char*P,char*F}
	const char** cp[] = { c + 3,c + 2,c + 1,c };             // {char*F,char*P,char*N,char*E}
	const char*** cpp = cp;                                  // char*(**cpp) = char** cp的首元素 （char*F)
	printf("%s\n", **++cpp);       // 同优先级，右到左。 **（++cpp)  point  注意：++会保留计算结果
	printf("%s\n", *--*++cpp+3);   // *(--(*(++cpp))) +3  从c+1开始 ++ 到c+2指向NEW --z指向 ENTER +3到ER
	printf("%s\n", *cpp[-2]+3);    // 从c+2开始 -2指向FIRST +3到ST
	printf("%s\n", cpp[-1][-1]+1); // 从c+2开始  *(*（cpp-1)-1) = NEW   +1到EW 
	return 0;
}
指针
  1
int main()
{
	unsigned long pulArray[] = { 6,7,8,9,10 };
	unsigned long* pulPtr;
	pulPtr = pulArray;
	*(pulPtr + 3) += 3; //指向9，再加上3，得12
	printf("%d,%d", *pulPtr, *(pulPtr + 3));
	return 0;
}
 2 写一个函数，可以逆序字符串内容
void reverse(char* str)
{
	assert(str);
	int len = strlen(str);
	char* left = str;
	char* right = str + len - 1;
	while (left < right)
	{
		char tmp = *left;
		*left = *right;
		*right = tmp;
		left++;
		right--;
	}
}
int main()
{
	char arr[256] = { 0 };
	scanf_s("%s", arr); //遇到空格会停止
	//gets(arr); //读取一行
	reverse(arr);
	printf("%s\n", arr);
	return 0;
}

 3 
 int main()
{
	int a = 0;
	int n = 0;
	scanf_s("%d%d", &a, &n);
	int sum = 0;
	int ret = 0;
	int i = 0;
	for (i = 0; i < n; i++)
	{
		ret = ret * 10 + a;
		sum += ret;
	}
	printf("%d", sum);
	return 0;
}
 4 水仙花数
int main()
{
	int i = 0;
	for (i = 0; i <= 100000; i++)
	{
		//计算i的位数
		int n = 1;
		int tmp = i;
		int sum = 0;
		while (tmp /= 10)
		{
			n++;
		}
		//计算每一位的n次方和
		tmp = i;
		while (tmp)
		{
			sum += (int)pow(tmp % 10, n);
			tmp /= 10;
		}
		//比较i ==sum
		if(i == sum)
		{
			printf("%d ",i);
		}
	}
	return 0;
}

 5 打印菱形
int main()
{
	int line = 0;
	//int k = 0;
	scanf_s("%d", &line);//奇数
	//if (line % 2 != 0)
	//{
	//	int k = line;
	//}
	//else
	//{
	//	printf("输入错误，请输入奇数");
	//}
	int i = 0;
	//打印上半部分
	for (i = 0; i < line; i++)
	{
		int j = 0;
		for (j = 0; j < line - 1 - i; j++)
		{
			printf(" ");
		}
		for (j = 0; j < 2 * i + 1; j++)  
		{
			printf("*");
		}
		printf("\n");
	}
	//打印下半部分
	for (i = 0; i < line; i++)
	{
		int j = 0;
		for (j = 0; j <= i; j++)
		{
			printf(" ");
		}
		for (j = 0; j < 2 * (line - 1 - i) - 1; j++)
		{
			printf("*");
		}
		printf("\n");
	}
	return 0;
}
结构体
 1  喝汽水，1瓶1元，两个空瓶换一瓶，20元喝几瓶?
int main()
{
	int money = 0;
	int total = 0;
	int empty = 0;
	scanf_s("%d", &money);
	//买回的汽水喝掉
	total = money;
	empty = money;
	//换回汽水
	while (empty >= 2)
	{
		total += empty / 2;
		empty = empty / 2 + empty % 2;
	}
	printf("%d\n", total);
	return 0;
}

调试
 1 奇偶交换顺序
void print(int arr[], int sz)
{
	int i = 0;
	for (i = 0; i < sz; i++)
	{
		printf("%d ", arr[i]);
	}
	printf("\n");
}
void move(int arr[], int sz)
{
	int left = 0;
	int right = sz - 1;
	while (left<right) 
	{
		while ((left < right) && arr[left] % 2 == 1) //从左找偶数
		{
			left++;
		}
		while ((left < right) && arr[right % 2 == 0])//从右找奇数
		{
			right--;
		}
		if (left = right)
		{
			int tmp = arr[left];
			arr[left] = arr[right];
			arr[right] = tmp;
		}
	}

}
int main()
{
	int arr[] = { 1,2,3,4,5,6,7,8,9,10 };
	int sz = sizeof(arr) / sizeof(arr[0]);
	move(arr,sz);
	print(arr, sz);
	return 0;
}

 数据存储
 1
int main()
{
	unsigned char a = 200; //能放0-255
	unsigned char b = 100;
	unsigned char c = 0;
	c = a + b; //放不下300，溢出300 -（255+1）=44
	printf("%d %d", a + b, c);
	return 0;
}

 2 打印杨辉三角
int main()
{
	int arr[10][10] = { 0 };
	int i = 0;
	int j = 0;
	for (i = 0; i < 10; i++)
	{
		for (j = 0; j < 10; j++)
		{
			if (j == 0)
			{
				arr[i][j] = 1;
			}
			if (i == j)
			{
				arr[i][j] = 1;
			}
			if (i >= 2 && j >= 1)
			{
				arr[i][j] = arr[i - 1][j] + arr[i - 1][j - 1];
			}
		}
	}
	for (i = 0; i < 10; i++)
	{
		for (j = 0; j <= i; j++)
		{
			printf("%d ", arr[i][j]);
		}
		printf("\n");
	}
	return 0;
}

 3 判案，四个人里面找凶手
int main()
{
	int killer = 0;
	for (killer = 'a'; killer <= 'd'; killer++)
	{
		if ((killer != 'a') + (killer == 'c') + (killer == 'd') + (killer != 'd') == 3)
		{
			printf("killer =%c\n", killer);
		}
	}
	return 0;
}

 4 赛马问题：36匹马，6个跑道。没有计时器，赛马确定，36匹马中的前三名，最少比赛几次. 8
 5烧香问题：一根香，材质不均，但是烧完正好是一个小时。现有两根香，如何确定一刻钟。 第一根两头烧，同时第二根点燃一端；第一根烧完时，点燃第二根的另一端。
 4 猜名次，5个跳水运动员猜名次
int main()
{
	int a = 0;
	int b = 0;
	int c = 0;
	int d = 0;
	int e = 0;
	for (a = 1; a <= 5; a++)
	{
		for (b = 1; b <= 5; b++)
		{
			for (c = 1; c <= 5; c++)
			{
				for (d = 1; d <= 5; d++)
				{
					for (e = 1; e <= 5; e++)
					{
						if (((b == 2) + (a == 3) == 1) &&
							((b == 2) + (e == 4) == 1) &&
							((c == 1) + (d == 2) == 1) &&
							((c == 5) + (d == 3) == 1) &&
							((e == 4) + (a == 1) == 1))
						{
							if(a*b*c*d*e == 120)
							printf("a=%d b=%d c=%d d=%d e=%d\n", a, b, c, d, e);
						}
					}
				}
			}
		}
	}
	return 0;
}

字符指针
 1 
#include<stdlib.h>
int main()
{
	int* p = (int*)malloc(10 * sizeof(int)); //申请内存空间
	free(p); //释放空间
	p = NULL;
	return 0;
}

 2 三步翻转法
void reverse(char* left,char* right)
{
	assert(left != NULL);
	assert(right != NULL);
	while (left<right)
	{
		char tmp = *left;
		*left = *right;
		*right = tmp;
		left++;
		right--;
	}
}
void left_move(char* arr, int k)
{
	assert(arr);
	int len = strlen(arr);
	assert(k <= len);
	reverse(arr,arr+k-1); //逆序左边
	reverse(arr+k,arr+len-1); //逆序右边
	reverse(arr,arr+len-1); //逆序整体
}
int main()
{
	char arr[] = "abcdef";
	left_move(arr,2);
	printf("%s\n", arr);
	return 0;
}

int is_left_move(char* s1, char* s2)
{
	int len = strlen(s1);
	int i = 0;
	for (i = 0; i < len; i++)
	{
		left_move(s1, i);
		int ret = strcmp(s1, s2);
		if (ret == 0)
		{
			return 1;
		}
	}
	return 0;
}
int main()
{
	char arr1[] = "abcdef";
	char arr2[] = "cdefab";
	int ret = is_left_move(arr1, arr2);
	if (ret == 1)
	{
		printf("yes\n");
	}
	else
	{
		printf("no\n");
	}
	return 0;
}
 解法2
int is_left_move(char* str1, char* str2)
{
	int len1 = strlen(str1);
	int len2 = strlen(str2);
	if (len1 != len2)
		return 0;
	//strcat(str1, str1); //自己给自己追加会无限追加
	strncat(str1, str1, 6);
	char*ret = strstr(str1, str2); //找str1里面有没有str2
	if (ret == NULL)
	{
		return 0;
	}
	else
	{
		return 1;
	}
}
int main()
{
	char arr1[] = "abcdef";
	char arr2[] = "cdefab";
	int ret = is_left_move(arr1, arr2);
	if (ret == 1)
	{
		printf("yes\n");
	}
	else
	{
		printf("no\n");
	}
	return 0;
}

 3 矩阵找数，时间复杂度小于O(N)
int FindNum(int arr[3][3], int k, int* px, int* py)
{
	int x = 0;
	int y = *py - 1;
	while (x <= *px - 1 && y >= 0)
	{
		if (arr[x][y] > k)
		{
			y--;
		}
		else if (arr[x][y] < k)
		{
			x++;
		}
		else
		{
			*px = x;
			*py = y;
			return 1;
		}
	}
}
int main()
{
	int arr[3][3] = { {1,2,3},{4,5,6},{7,8,9} };
	int k = 7;
	int x = 3;
	int y = 3;
	int ret = FindNum(arr, k, &x, &y);
	if (ret == 1)
	{
		printf("找到了\n");
		printf("(%d,%d)\n", x, y);
	}
	else
	{
		printf("没找到\n");
	}
	return 0;
}
 字符串函数的使用和剖析
 前言： c语言对字符和字符串函数的处理很频繁，但没有字符串类型。通常是放在 常量字符串或字符数组 中。 字符串常量适合对它不做修改的字符串函数

求字符串长度
int my_strlen(const char* str)
{
	assert(str != NULL);
	int count = 0;
	while (*str != '\0')
	{
		count++;
		str++;
	}
	return count;
}
// 如何不创建临时变量来实现my_strlen? 递归写法
int main()
{
	int len = strlen("abcdef");
	char arr[] = { 'a', 'b', 'c', 'd', 'e', 'f' }; // 缺少\0
	int len1 = my_strlen(arr);
	printf("%d\n", len);
	printf("%d\n", len1);
	if (strlen("abc") - strlen("abcdef") > 0)
	{
		printf("hehe\n"); // strlen的返回类型是size_t，而不是int。 size_t本质就是unsigned int。
	}
	else
	{
		printf("haha\n");
	}
	return 0;
}

长度不受限制的字符串函数
 strcpy
char* my_strcpy(char* dest, char* src)
{
	assert(dest != NULL);
	assert(src != NULL);
	char* ret = dest; //拷贝目标空间的起始地址
	while (*dest++ = *src++) // 拷贝src指向的字符串到dest指向的空间，包含'\0'
	{
		;
	}
	return ret; //返回起始地址
}
int main()
{
	char arr1[] = "abcdefghi";
	char arr2[] = "bit";
	//strcpy(arr1, arr2); // strcpy(目标数组，源数组)
	my_strcpy(arr1, arr2);
	printf("%s\n", arr1);
	return 0;
}
 strcat
char* my_strcat(char* dest,const char* src)
{
	assert(dest != NULL);
	assert(src != NULL);
	char* ret = dest;
	while (*dest != '\0')
	{
		dest++;
	}
	while (*dest++ = *src++)
	{
		;
	}
	return ret;
}
int main()
{
	//char arr1[] = "hello"; //空间不够放bit
	char arr1[30] = "hello\0xxxx"; //arr2从\0开始往后追加
	char arr2[] = "bit";
	strcat_s(arr1, arr2); // 将arr2的内容追加到arr1的后面
	printf("%s\n", arr1);
	return 0;
}
 strcmp
int main()
{
	const char* p1 = "abcdef";
	const char* p2 = "sqwer";
	int ret = strcmp(p1, p2); //从首字符开始比较对应字符的ASCII码大小 ，相等时输出0
	if (ret > 0)
	{
		printf("p1>p2\n");
	}
	else if (ret == 0)
	{
		printf("p1=p2\n");
	}
	else
	{
		printf("p1<p2\n");
	}
	printf("%d\n", ret);
	return 0;
}
int my_strcmp(const char* str1, const char* str2)
{
	assert(str1 && str2 != NULL);
	while (*str1 == *str2)
	{
		if (*str1 == '\0') //比较到字符串结尾了，说明字符串相等
		{
			return 0;
		}
		str1++;
		str2++;
	}
	if (*str1 > *str2)
	{
		return 1;
	}
	else
	{
		return -1;
	}
	// return (*str1 - *str2）;
}
int main()
{
	const char* p1 = "abcdef";
	const char* p2 = "abqwe";
	int ret = my_strcmp(p1, p2);
	printf("%d\n", ret);
	return 0;
}
 容易变得不安全(越界、目标空间放不下等问题）
// 字符串查找
const char* my_strstr(const char* p1,const char* p2)
{
	assert(p1 != NULL);
	assert(p2 != NULL);
	char* s1 = NULL;
	char* s2 = NULL;
	char* cur = (char*) p1;
	if (*p2 == '\0')
	{
		return p1;
	}
	while (*cur)
	{
		s1 = cur;
		s2 = (char*)p2;
		while (*s1 && *s2 && (*s1 - *s2))
		{
			s1++;
			s2++;
		}
		if (*s2 == '\0')
		{
			return cur;
		}
		cur++;
	}
	return NULL; // 找不到子串
}
int main()
{
	const char* p1 = "abcdefghi";
	const char* p2 = "defq";
	const char* ret = strstr(p1, p2);
	if (ret == NULL)
	{
		printf("子串不存在\n");
	}
	else
	{
		printf("%s\n", ret);
	}
	return 0;
}
int main()
{
	char arr[] = "365206624@qq.com";
	char* next_token = NULL;
	const char* p = "@.";

	char buf[1024] = { 0 };
	strcpy_s(buf, arr);
	// 切割buf中的字符串
	char* ret = NULL;
	for (ret = strtok_s(arr, p, &next_token); ret != NULL; ret = strtok_s(NULL, p,&next_token))
	{
		printf("%s\n", ret);
	}
	//char*ret = strtok_s(arr, p, &next_token);
	//printf("%s\n", ret);

	//ret = strtok_s(NULL, p, &next_token);
	//printf("%s\n", ret);

	//ret = strtok_s(NULL, p, &next_token);
	//printf("%s\n", ret);
	return 0;
}

 错误信息报告
 strerror 把错误码翻译成对应的错误信息
#include<errno.h>
int main()
{
	char arr[1024] = { 0 };
    char* buf = arr;
	rsize_t bufsz = sizeof(arr);
	//errno_t str = strerror_s(buf,bufsz,errno);
	//// errno是一个全局错误码变量。
	//// 当c语言库函数执行中发生错误，就会把对应的错误码，赋值到errno中。
	//printf("%s\n", (char*)str);

	// 打开文件
	FILE* pf;
	const char* filename = "test.txt";
	const char* mode = "r";
	errno_t error = fopen_s(&pf,filename, mode);
	if (error == 0)
	{
		printf("%s\n", strerror_s(buf, bufsz,errno));
	}
	else
	{
		printf("success\n");
	}
	return 0;
}

 字符操作
#include<ctype.h>
 字符分类函数
int main()
{
	char ch = 'w';
	int ret = islower(ch);
	printf("%d\n", ret);

	char ch1 = '2';
	int ret1 = isdigit(ch1);
	printf("%d\n", ret1);
	return 0;
}
 字符转换函数
int main()
{
	char ch = tolower('Q');
	putchar(ch);

	printf("\n");

	char ch1 = toupper('q');
	putchar(ch1);
	return 0;
}
int main()
{
	char arr[] = "I Am A Student";
	int i = 0;
	while (arr[i])
	{
		if (isupper(arr[i]))
		{
			arr[i] = tolower(arr[i]);
		}
		i++;
	}
	printf("%s\n", arr);
	return 0;
}
内存操作函数
  memcpy
void* my_memcpy(void* dest, const void* src, size_t num)
{
	void* ret = dest;
	assert(dest && src != NULL);
	while (num--)
	{
		++* (char*)dest = ++ * (char*)src;
	}
	return ret;
}
struct s
{
	char name[20];
	int age;
};
int main()
{
	int arr1[] = { 1,2,3,4,5 };
	int arr2[5] = { 0 };
	memcpy(arr2, arr1, sizeof(arr1));
	struct s arr3[] = { {"张三",20},("李四",30) };
	struct s arr4[3] = { 0 };
	my_memcpy(arr4, arr3, sizeof(arr3));
	// void* 通用类型指针
	return 0;
}
数据类型：内置类型，自定义类型
自定义类型包括：结构体、枚举、联合体

结构体：结构是一些值的集合，这些值成为成员变量。结构的每个成员可以是不同类型的变量。
 结构体的声明
struct stu
{
	// 声明一个学生类型，是通过学生类型来创建学生对象/变量
	// 描述学生属性
	char name[20];
	char tele[12];
	char sex[10];
	int age;
}s4,s5,s6;// 全局结构体变量

int main()
{
	struct stu s1; // 局部结构体变量
	struct stu s2;
	return 0;
}
struct      // 匿名创建（省略结构体标签）
{
	int a;
	char c;
}sa;       // 这边补一下

struct
{
	int a;
	char c;
}*psa;    // 匿名结构体指针类型。 不能存放sa的地址
int main()
{
	psa = &sa; // error
	return 0;
}

 结构体自引用
 数据结构：数据在内存中存储的结构
struct node
{
	int data;
	struct node* next; 
	//struct node n; // 无限套
};

int main()
{
	sizeof(struct node);
	return 0;
}
typedef struct node  // 不可以匿名
{
	int data;
	struct node* next; 
	//struct node n; // 无限套
}node;

int main()
{
	struct node n1;
	node n2;
	return 0;
}

 结构体变量的定义和初始化
struct t
{
	double weight;
	int age;
};
struct s            // 声明同时定义
{
	char c;
	int a;
	double d;
	char arr[20];
	struct t st;
};
int main()
{
	//struct s s = { 'c',100,3.14,"hello bit" }; // 初始化
	//printf("%c %d %lf %s\n", s.c, s.a, s.d, s.arr);
	struct s s = { 'c',100,3.14,"hello bit",{55.6,30} };
	printf("%lf\n", s.st.weight);
	return 0;
}
 结构体内存对齐
 第一个成员在结构体变量偏移量为0的地址处
 其他成员变量要对齐到某个数字（对齐数）的整数倍的地址处
 对齐数=编译器默认的一个对齐数 与 该成员大小的 较小值
 结构体总大小是最大对齐数（每个变量都有一个对齐数，包括嵌套结构体）的整数倍
struct s1
{
	char c1;
	int a;
	char c2;
};
struct s2
{
	char c1;
	char c2;
	int a;
};
int main()
{
	struct s1 s1 = { 0 };
	printf("%d\n", sizeof(s1)); // 12
	struct s2 s2 = { 0 };
	printf("%d\n", sizeof(s2)); // 8
	return 0;
}

 如果嵌套结构体，则对齐数是嵌套结构体的最大对齐数、
 设置默认对齐数
#pragma pack(4)
struct a
{
	char c1;
	double d;
};

int main()
{
	struct a s;
	printf("%d\n", sizeof(a));
	return 0;
}
#pragma pack() // 取消设置
#include<stddef.h>
struct s
{
	char c;
	int i;
	double d;
};

int main()
{
	printf("%d\n", offsetof(struct s, c)); // offsetof 是个宏
	printf("%d\n", offsetof(struct s, i));
	printf("%d\n", offsetof(struct s, d));
	return 0;
}
 结构体实现位段（位段的填充、可移植性）
 位段的声明和结构体类似，两个不同：位段成员必须是：int，unsigned int或signed int（int型就行）;位段成员名后边有一个冒号和一个数字。
struct S      // 为了节省空间
{
	int a: 2; //2bit表达4种状态
	int b: 5;
	int c: 10;
	int d: 30; // 按整型开辟空间。不能大于32，一个最多32bit对应数字32。
};
int main()
{
	struct S s;
	printf("%d\n", sizeof(s));  // 8bit
	return 0;
}
struct S
{
	char a : 3;
	char b : 4;
	char c : 5;
	char d : 4;
};
int main()
{
	struct S s = { 0 };
	printf("%d\n", sizeof(s));
	s.a = 10;
	s.b = 20;
	s.c = 3;
	s.d = 4;
	printf("%d\n", sizeof(s));
	return 0;
}
 位段跨平台问题：
int 位段被当成有符号数还是无符号数；
位段最大位数目不定（16位机最多16）；
从左还是从右分配；
一个结构包含两个位段，一个比较大是丢弃剩下bit还是利用不确定

枚举
 枚举类型的定义
#define RED 0
#define GREEN 1
#define  BLUE 2
enum Sex
{
	MALE = 2,
	FEMAL,
	SECRET
};
//enum Color
//{
//	RED,
//	GREEN,
//	BLUE
//};
int main()
{
	//const int num = 100; //赋初值
	//enum Sex s = MALE;
	//enum Color c = 2; // error
	//printf("%d %d %d\n", RED, GREEN, BLUE); // 0 1 2
	//printf("%d %d %d\n", MALE, FEMAL, SECRET); // 0 1 2 依次往后赋值
	return 0;
}

 枚举的优点：比定义更容易理解，可维护，有类型更严谨，定义便捷，防止命名污染，便于调试

 枚举的使用
enum color
{
	RED=1,
	GREEN=2,
	BLUE=4
};
int main()
{
	enum color clr = GREEN; // 只能拿枚举常量给枚举变量赋值，否则会出现类型差异
	clr = 5; // error
	return 0;
}
enum Sex
{
	male,
    female,
	secret
};
int main()
{
	enum Sex s = male;
	printf("%d\n", sizeof(s));
	return 0;
}
联合-联合体-共用体
 联合类型的定义
 包含一系列成员，共用空间
union Un  // 联合体变量大小，至少是最大成员的大小。
{
	char c;
	int i;
};
int main()
{
	union Un u;
	printf("%d\n", sizeof(u)); // 4
	printf("%p\n", &(u.c));
	printf("%p\n", &(u.i));
	printf("%p\n", &u);
	return 0;
}
#define _CRT_SECURE_NO_WARNINGS 1
#include "contact.h"


void InitContact(struct Contact* ps)
{
	ps->data = (struct PeoInfo*)malloc(DEFAULT_SZ * sizeof(PeoInfo));
	if (ps->data == NULL)
	{
		return;
	}
	ps->size = 0;
	ps->capacity = DEFAULT_SZ;
}

void CheckCapacity(struct Contact* ps)
{
	if (ps->size == ps->capacity)
	{
		struct PeoInfo* ptr =(struct PeoInfo*)realloc(ps->data, (ps->capacity + 2) * sizeof(PeoInfo));
		if (ptr != NULL)
		{
			ps->data = ptr;
			ps->capacity += 2;
			printf("扩容成功\n");
		}
		else
		{
			printf("扩容失败\n");
		}
	}
}
void AddContact(struct Contact* ps)
{
	if (ps->size == MAX)
	{
		printf("通讯录已满,无法增加");
	}
	else
	{
		printf("请输入名字：");
		scanf("%s", ps->data[ps->size].name);
		printf("请输入年龄：");
		scanf("%s", &(ps->data[ps->size].age));
		printf("请输入性别：");
		scanf("%s", ps->data[ps->size].sex);
		printf("请输入电话：");
		scanf("%s", ps->data[ps->size].tele);
		printf("请输入地址：");
		scanf("%s", ps->data[ps->size].addr);
		ps->size++;
		printf("添加成功\n");
	}
}


void ShowContact(const struct Contact* ps)
{
	if (ps->size == 0)
	{
		printf("通讯录为空\n");
	}
	else
	{
		int i = 0;
		printf("%-20s\t%-4s\t%-5s\t%-12s\t%-20s\n", "名字", "年龄", "性别", "电话", "地址"); // 打印标题
		for (i = 0; i < ps->size; i++) // 打印内容
		{
			printf("%-20s\t%-4s\t%-5s\t%-12s\t%-20s\n",
				ps->data[i].name,
				ps->data[i].age,
				ps->data[i].sex,
				ps->data[i].tele,
				ps->data[i].addr);
		}
	}
}


static int FindByName(struct Contact* ps,char name[MAX_NAME]) // 内部用
{
	int i = 0;
	for (i = 0; i < ps->size; i++)
	{
		if (0 == strcmp(ps->data[i].name, name))
		{
			return i;
		}
	}
	return -1;
}


void DelContact(struct Contact* ps)
{
	char name[MAX_NAME]={0};
	printf("请输入被删除者的姓名：");
	scanf("%s", &name);
	// 查找
	int pos = FindByName(ps, name); // 找到返回名字所在元素的下标，找不到返回-1
	
	// 删除
	if (pos == -1)
	{
		printf("目标不存在\n");
	}
	else
	{
		int j = 0;
		for (j = 0; j < ps->size-1; j++)
		{
			ps->data[j] = ps->data[j + 1];
		}
		ps->size--;
		printf("删除成功\n");
	}
}


void SearchContact(struct Contact* ps)
{
	char name[MAX_NAME];
	printf("请输入被查找者的名字：");
	scanf("%s", name);
	int pos = FindByName(ps, name);
	if (pos == -1)
	{
		printf("要查找者不存在\n");
	}
	else
	{
		printf("%-20s\t%-4s\t%-5s\t%-12s\t%-20s\n", "名字", "年龄", "性别", "电话", "地址"); 
		printf("%-20s\t%-4s\t%-5s\t%-12s\t%-20s\n",
				ps->data[pos].name,
				ps->data[pos].age,
				ps->data[pos].sex,
				ps->data[pos].tele,
				ps->data[pos].addr);
	}
}
// 动态内存分配
// 创建变量  栈区：局部变量、函数形式参数。  堆区：动态内存分配。  静态区：全局变量、静态变量
// 创建数组  栈区：局部数组。                                      静态区：全局数组。
//struct S
//{
//	char name[20];
//	int age;
//};
//int main()
//{
//	struct S arr[50]; // 50个struct S类型的数据
//	return 0; // 存在空间浪费
//}

// 存在意义：需要多少空间，开辟多少空间

// 动态内存函数介绍
int main()
{
	int*p = (int*)malloc(10 * sizeof(int)); // malloc 返回类型是void 需要强制转换. 
	if (p == NULL) //返回NULL，表示内存空间不够。
	{
		printf("%s\n", strerror(errno)); // 打印错误原因
	}
	else
	{
		int i = 0;
		for (i = 0; i < 10; i++)
		{
			printf("%d ", *(p + i));
		}
	}        // 动态空间使用完后，应还给程序。
	free(p); // 将动态空间还给系统，不能用来释放数组等。可以free空指针，等于没操作。
	p = NULL; // p虽然被释放了，但还是存在。 需要手动把他变成空指针。
	return 0;
}
int main()
{
	int* p = (int*) calloc(10, sizeof(int)); // 将动态空间初始化为0
	if (p == NULL)
	{
		printf("%s\n", strerror(errno));
	}
	else
	{
		int i = 0;
		for (i = 0; i < 10; i++)
		{
			printf("%d ", *(p + i));
		}
	}
	free(p);
	p = NULL;
	return 0; 
}
 realloc
int main()
{
	int* p = (int*)malloc(20);
	if (p == NULL)
	{
		printf("%s\n", strerror(errno));
	}
	else
	{
		int i = 0;
		for (i = 0; i < 5; i++)
		{
			*(p + i) = i;
		}
	} // 开辟了20个字节空间，现在需要40个，增加空间。
	int* ptr = (int*)realloc(p, 40); // realloc 扩大空间，p是目标空间的地址，40是新空间的大小。
	// p 后空间足够，在后面加上空间； p后空间不足，开辟足够的新空间，将原来内容拷贝过来，释放就空间，返回新空间地址。
	if (ptr != NULL) // 开辟成功把ptr赋给p，防止开辟失败直接把p变成空指针从而丢失原先开辟的空间。
	{
		p = ptr;
		int i = 0;
		for (i = 0; i < 5; i++)
		{
			*(p + i) = i;
		}
		for (i = 0; i < 10; i++)
		{
			printf("%d ", *(p + i));
		}
	}
	free(p);
	p = NULL;
	return 0;
}


 常见动态内存错误
1 对空指针解引用
int main()
{
	int* p = (int*)malloc(40); // 如果malloc失败，p变赋值为空指针，违法操作。
	*p = 0;
	return 0;
}
 2 对动态开辟空间的越界访问
int main()
{
	int* p = (int*)malloc(5 * sizeof(int));
	if (p == NULL)
	{
		return 0;
	}
	else
	{
		int i = 0;
		for (i = 0; i < 10; i++) // 越界访问
		{
			*(p + i) = i;
		}
	}
	free(p);
	p = NULL;
	return 0;
}
 3 对非动态开辟内存的free
int main()
{
	int a = 10;
	int* p = &a; 
	*p = 20;
	free(p); // 对非动态开辟内存的free
	p = NULL;
	return 0;
}
 4 使用free释放动态内存的一部分
int main()
{
	int* p = (int*)malloc(40);
	if (p == NULL)
	{
		return 0;
	}
	else
	{
		int i = 0;
		for (i = 0; i < 10; i++)
		{
			*p++ = i; // p发生了变化
		}
	}
	free(p); //只能从空间首地址开始释放空间
	p = NULL;
	return 0;
}
 5 对同一块动态内存的多次释放
int main()
{
	int* p = (int*)malloc(40);
	if (p == NULL)
	{
		return 0;
	}
	else
	{
		;
	}
	free(p);
	p = NULL; // 手动变p为空指针，防止多次释放报错。
	// 。。。
	free(p);
	return 0;
}
 6 忘记释放动态内存（内存泄露）
int main()
{
	while (1)
	{
		malloc(1);   // 只开辟，不回收。
		Sleep(1000);
	}
	return 0;
}


 经典题目
 1 Test执行结果？ error
void GetMemory(char* p)
{
	p = (char*)malloc(100);
}
void Test(void)
{
	char* str = NULL;
	GetMemory(str);
	strcpy(str, "hello world");
	printf(str);
}

void GetMemory(char** p) // 改版1
{
	*p = (char*)malloc(100);
}
void Test(void)
{
	char* str = NULL;
	GetMemory(&str);
	strcpy(str, "hello world");
	printf(str);
	free(str);
	str = NULL;
}

char* GetMemory(char** p) // 改版2
{
	*p = (char*)malloc(100);
	return p;
}
void Test(void)
{
	char* str = NULL;
	str = GetMemory(&str);
	strcpy(str, "hello world");
	printf(str);
	free(str);
	str = NULL;
}

int main()
{
	Test();
	return 0;
}
 2 test函数输出结果
char* GetMemory(void)
{
	char p[] = "hello world";
	return p;
}
void Test(void)
{
	char* str = NULL;
	str = GetMemory();
	printf(str);
}
 改版
int* Test()
{
	int* ptr = (int*)malloc(100);
	return ptr;
}
int main()
{
	int* p =Test();
	return 0;
}
 3 
void GetMemory(char** p, int num)
{
	*p = (char*)malloc(num);
}
void Test(void)
{
	char* str = NULL;
	GetMemory(&str, 100);
	strcpy(str, "hello");
	printf(str); // 忘记释放动态内存空间
}
void Test()
{
	char* str = (char*)malloc(100);
	strcpy_s(str, 6,"hello");
	free(str); //释放空间，但没有把str置NULL
	str = NULL;
	if (str != NULL)
	{
		strcpy_s(str,6, "world"); // 释放过的空间再次使用
		printf(str);
	}
}

int main()
{
	Test();
	return 0;
}
 柔性数组: c99中，结构中的最后一个元素允许是未知大小的数组，称为柔性数组成员。
struct S
{
	int n;
	int arr[]; // 数组大小可以调整
};
int main()
{
	//struct S s;
	//printf("%d\n", sizeof(s)); // 初始状态，柔性数组大小为0
	struct S* ps = (struct S*) malloc(sizeof(struct S)+ 5*sizeof(int)); // 内存连续，访问效率更高
	ps->n = 100;
	int i = 0;
	for (i = 0; i < 5; i++)
	{
		ps->arr[i] = i;
	}
	struct S* ptr = (struct S* ) realloc(ps, 44);
	if (ptr != NULL)
	{
		ps = ptr;
	}
	for (i = 5; i < 10; i++)
	{
		ps->arr[i] = i;
	}
	for (i = 0; i < 10; i++)
	{
		printf("%d ", ps->arr[i]);
	}
	free(ps);
	ps = NULL;
	return 0;
}

struct S
{
	int n;
	int* arr;
};
int main()
{
	struct S* ps = (struct S*)malloc(sizeof(struct S));
	ps->arr = (int*) malloc(5 * sizeof(int));
	int i = 0;
	for (i = 0; i < 5; i++)
	{
		ps->arr[i] = i;
	}
	for (i = 0; i < 5; i++)
	{
		printf("%d ", ps->arr[i]);
	}
	printf("\n");
	// 扩大空间
	int* ptr = (int*)realloc(ps->arr, 10 * sizeof(int));
	if (ps != NULL) // 检验是否成功扩容
	{
		ps->arr = ptr;
	}
	for (i = 5; i < 10; i++)
	{
		ps->arr[i] = i;
	}
	for (i = 0; i < 10; i++)
	{
		printf("%d ", ps->arr[i]);
	}
	// 释放内存
	free(ps->arr); // 多次malloc，free容易出错
	free(ps);
	ps->arr = NULL;
	ps = NULL;
	return 0;
}
 文件操作
 什么是文件：磁盘里存放数据的介质
 文件名：文件路径+文件名主干+文件后缀
 文件类型：根据数据的组织形式，数据文件被称为文本文件\二进制文件（以二进制存储，不加转换输出到外存）
int main()
{
	int a = 10000;
	FILE* pf = fopen("test.txt", "wb"); // 打开文件test.txt，不存在就创建
	fwrite(&a, 4, 1, pf); //以二进制形式写到文件中。 以a的地址，写一个四字节的到of中（其实就是把a的值写入文件）
	fclose(pf);
	pf = NULL;
	return 0;
}
 文件缓冲区
 ANSIC用缓冲文件系统，系统自动在内存中为程序中每一个正在使用的文件开辟一块文件缓冲区。
 内存向磁盘输出数据先放缓冲区，装满后统一送到磁盘。从磁盘读数据，先充满缓冲区，再从缓冲区中逐一送数据到程序数据区。

 文件指针:文件类型指针
 被使用文件在内存中开辟了一个相应的文件信息区，用来存放文件相关信息（名字、状态、当前位置等）。被保存在一个结构体变量中，名为FILE。
struct _iobuf {
	char* _ptr;
	int _cnt;
	char* _base;
	int _flag;
	int _file;
	int _charbuf;
	int _bufsiz;
	char* _tmpfname;
};
typedef struct _iobuf FILE;
 定义pf是一个指向FILE类型的指针变量，指向文件信息区，找到与之关联的文件。


 文件的打开和关闭
int main()
{
    // 相对路径写法中， .. 表示上一级路径  . 表示当前路径
	FILE* pf = fopen("../test.txt", "r"); // 打开文件名(相对路径）  打开方式（只读）
	if (pf == NULL)
	{
		printf("%s\n", strerror(errno));
	}
	//打开文件
	//读文件
	//关闭文件
	fclose(pf); // 让这个结构体关闭，释放内存空间，但pf没有变空指针
	pf = NULL;  // 手动将pf置空指针
	return 0;
}
int main()
{
	FILE* pfWrite = fopen("TEST.txt","w");
	if (pfWrite == NULL)
	{
		printf("%s\n", strerror(errno));
		return 0;
	}
	// 写文件
	fputc('b', pfWrite);
	fputc('i', pfWrite);
	fputc('t', pfWrite);
	// 关闭文件
	fclose(pfWrite);
	pfWrite = NULL;
}
int main()
{
	FILE* pfRead = fopen("TEST.txt", "r");
	if (pfRead == NULL)
	{
		printf("%s\n", strerror(errno));
		return 0;
	}
	// 写文件
	printf("%c ", fgetc(pfRead));
	printf("%c ", fgetc(pfRead));
	printf("%c ", fgetc(pfRead));
	// 关闭文件
	fclose(pfRead);
	pfRead = NULL;
}

 从键盘输入  （键盘：标准输入设备）stdin
 输出到屏幕  （屏幕：标准输出设备）stdout
 键盘和屏幕都是外设 （程序默认打开的两个流设备） （默认打开3个 分别为是stdin FILE*，stdout FILE*，stderr FILE*
int main()
{
	int ch = fgetc(stdin); // 读一个字符
	fputc(ch, stdout);     // 输出一个字符到屏幕
	return 0;
}
 读取或输出一个字符串 
int main()
{
	char buf[1024] = { 0 };
	FILE* pf = fopen("test.txt", "r");
	if (pf == NULL)
	{
		return 0;
	}
	fgets(buf, 1024, pf);
	printf("%s\n", buf);
	// outs(buf);
	fclose(pf);
	pf = NULL;
	return 0;
}
int main()
{
	char buf[1024] = { 0 };
	FILE* pf = fopen("test.txt", "w");
	if (pf == NULL)
	{
		return 0;
	}
	fputs("hello", pf);
	fputs("world", pf);
	fclose(pf);
	pf = NULL;
	return 0;
}

 读取或输出一行 
int main()
{
	char buf[1024] = { 0 };
	//fgets(buf,1024,stdin); // 从标准输入读，放到buf里面
	//fputs(buf, stdout);    // 从buf输出到标准输出
	gets(buf);
	puts(buf);
	return 0;
}
 格式化输入或输出函数
struct S
{
	int n;
	float score;
	char arr[10];
};

int main()
{
	struct S s = { 100,3.14f,"bit" };
	FILE* pf = fopen("test.txt", "w");
	if (pf == NULL)
	{
		return 0;
	}
	//格式化形式写文件
	fprintf(pf, "%d %f %s", s.n, s.score, s.arr);

	fclose(pf);
	pf = NULL;
	return 0;
}
int main()
{
	struct S s = {0};
	FILE* pf = fopen("test.txt", "r");
	if (pf == NULL)
	{
		return 0;
	}
	//格式化输入数据
	fscanf(pf, "%d %f %s", &(s.n), &(s.score), s.arr);
	printf("%d %f %s\n", s.n, s.score, s.arr);
	//fscanf(stdin, "%d %f %s", &(s.n), &(s.score), s.arr);
	//printf(stdout,"%d %.2f %s\n", s.n, s.score, s.arr);
	fclose(pf);
	pf = NULL;
	return 0;
}
int main()
{
	struct S s = { 100,3.14f,"abcd" };
	struct S tmp = { 0 };
	char buf[1024] = { 0 };
	sprintf(buf, "%d %f %s", s.n, s.score, s.arr);
	printf("%s\n", buf); // 将结构体转换成字符串
	scanf(buf, "%d %f %s", &(tmp.n), &(tmp.score), tmp.arr);
	printf("%d %f %s\n", tmp.n, tmp.score, tmp.arr);
	return 0;
}

 二进制读写
struct S
{
	char name[1024];
	int age;
	float weight;
};
int main()
{
	//struct S s = { "张三",20,55.6 };
	struct  S tmp = { 0 };
	FILE* pf = fopen("test.txt", "wb");
	if (pf == NULL)
	{
		return 0;
	}
	//fwrite(&s, sizeof(struct S), 1, pf); // 写
	fread(&tmp, sizeof(struct S), 1, pf);  // 读
	printf("%s %d %lf\n", tmp.name, tmp.age, tmp.weight);
	fclose(pf);
	pf = NULL;
	return 0;
}
 文件的随机读写 
int main()
{
	FILE* pf = fopen("test.txt", "r");
	if (pf == NULL)
	{
		return 0;
	}
	fseek(pf, 2, SEEK_CUR); // 偏移量不能超出文本范围
	int ch = fgetc(pf);
	printf("%c\n", ch);
	fclose(pf);
	pf = NULL;
	return 0;
}
int main()
{
	FILE* pf = fopen("test.txt", "r");
	if (pf == NULL)
	{
		return 0;
	}
	fseek(pf, -2, SEEK_END); // 偏移量不能超出文本范围
	//int pos = ftell(pf);   // ftell 返回文件指针相对起始位置的偏移量
	//printf("%c\n", pos);
	rewind(pf);              // rewind返回起始位置

	fclose(pf);
	pf = NULL;
	return 0;
}

 文件结束的判定
int main()
{
	FILE* pf = fopen("text.txt", "r");
	if (pf == NULL)
	{
		return 0;
	}
	int ch = fgetc(pf);
	printf("%d\n", ch);
	feof(); // EOF文件结束标志，feof用于当文件读取结束时，判断是读取失败结束，还是遇到文件尾结束。
	fclose(pf);
	pf = NULL;
	return 0;
} 
int main()
{
	FILE* pf = fopen("test.txt", "r");
	if (pf == NULL)
	{
		perror("open file test,txt");  // 报错函数
	}
	int ch = 0;
	while ((ch = fgetc(pf)) != EOF)
	{
		putchar(ch);
	}
	if (ferror(pf))
	{
		printf("error\n");
	}
	else if (feof(pf))
	{
		printf("end of file\n");
	}
	fclose(pf);
	pf = NULL;
	return 0;
}
struct A
{
	int a;
	short b;
	int c;
	short d;
};
struct B
{
	int a;
	short b;
	char c;
	int d;
};
 c语言预处理
 程序的翻译环境：翻译+链接
 将.c文件翻译成.exe文件
extern int Add(int x, int y); // 生成外部文件
int main()
{
	int arr[10] = { 0 };
	int i = 0;
	for (i = 0; i < 10; i++)
	{
		arr[i] = i;
	}
	for (i = 0; i < 10; i++)
	{
		printf("%d ", i);
	}
	return 0;
}
 源文件 经编译器 生成目标文件（.obj）  到链接器+链接库 生成可执行程序
 翻译：预处理 编译 汇编
 预处理（文本操作）： 头文件包含（#include）、删除注释、完成预处理指令（#define）
 编译：把c代码翻译成汇编代码
 汇编：将汇编代码转换成二进制指令。
 链接：合并段表，符号表的合并和重定位。

 程序的执行环境
 1.程序载入内存。
 2.程序开始执行，调用main函数。
 3.开始执行程序代码。用堆栈存储函数的局部变量和返回地址，用静态区存储整个程序过程中需要保留的值。
 4.终止程序。可能包含意外终止。

 c语言程序的编译和链接
 预定义符号介绍
int main()
{
	//printf("%s\n", __FILE__);
	//printf("%d\n", __LINE__);
	//printf("%s\n", __DATE__);
	//printf("%s\n", __TIME__);
	int i = 0;
	int arr[10] = { 0 };
	FILE* pf = fopen("log.txt", "w");
	for (i = 0; i < 10; i++)
	{
		arr[i] = i;
		fprintf(pf, "file:%s line:%d date:%s time:%s i=%d\n",
			__FILE__, __LINE__, __DATE__, __TIME__, i);
		printf("%s\n", __FUNCTION__);
	}
	fclose(pf);
	pf = NULL;
	for (i = 0; i < 10; i++)
	{
		printf("%d", arr[i]);
	}
	return 0;
}
int main()
{
	printf("%d\n", __STDC__); // __STDC__ 遵从ANSI C协议则输出1，否则未定义。
	return 0;
}


 预处理指令#define
 #开头的都是预处理指令 #if #endif #pragma #ifdef #line
 申明字符
#define MAX 100
#define STR "hehe"
#define reg register
#define do_forever for(;;)
int main()
{
	reg int a;
	int max = MAX;
	printf("%d\n", max);
	printf("%s\n", STR);
	do_forever;                     
	return 0;
}
 申明宏
#define SQUARE(X) (X)*(X)
int main()
{
	//int ret = SQUARE(5);
	//printf("ret=%d\n", ret);
	int ret = SQUARE(5 + 1);
	printf("%d\n", ret); //宏是完整替换而不是传参，5+1*5+1=11 而不是36  给X加括号可解决
	return 0;
}
 调用宏时，检查参数是否包含宏，被包含的宏首先被替换
#define MAX 100
#define DOUBLE(X) ((X)+(X))
int main()
{
	int a = 5;
	int ret = 10 * DOUBLE(MAX);
	printf("%d\n", ret);
	return 0;
}
 替换文本随后被插入到程序中原来文本的位置。对于宏，参数名被他们的值替换。
 最后再次对文本进行扫描，如有#define定义的符号则重复上述过程。
 字符串中的符号不被替换。
void print(int a)
{
	printf("the value of a is %d\n", a);  //要打印b却是a的名字
}
int main()
{
	int a = 10;
	int b = 20;
	print(a);
	print(b);
	return 0;
}
#define PRINT(X) printf("the value of "#X" is %d",X); // #X表示X代表的内容为字符串
int main()
{
	printf("hello world \n");
	printf("hello " "world\n");
	printf("hel""lo ""world\n");
	int a = 10;
	int b = 20;
	PRINT(a);
	PRINT(b);
	return 0;
}
#define CAT(X, Y) X##Y // ##将它两边的符号合成一个符号
int main()
{
	int c1 = 4;
	printf("%d\n", CAT(c, 1));
	return 0;
}
 宏和函数的对比
#define MAX(X,Y) (X)>(Y)?(X):(Y) // 宏常被用于简单计算。宏与类型无关， 宏比函数在程序和规模上小，执行速度快
int main()
{
	int a = 10;
	int b = 11;
	int max = MAX(a++, b++);    // ++产生副作用
	printf("%d\n", max);
	printf("%d\n", a);
	printf("%d\n", b);
	return 0;
}
int Max(int x, int y)            // 函数可以调试，宏不行。 宏类型无关，容易出错。 宏容易有运算优先级问题。
{
	return (x > y ? x : y);
}
int main()
{
	int a = 10;
	int b = 20;
	int max = Max(a, b);
	int max1 = MAX(a, b);
	printf("%d\n", max);
	printf("%d\n", max1);
	return 0;
}
 宏可以传类型
#define MALLOC(num,type) (type*)malloc(num*sizeof(type))
int main()
{
	int*p =(int*) malloc(10 * sizeof(int));
	int* p = MALLOC(10, int);
	return 0;
}
 宏全大写，函数名不全大写

 命令行定义：在命令行中定义符号，用于启动编译过程，帮助将一个源文件创建不同版本用于不同机器上运行。 
 
 预处理指令#include
  预处理指令#include
 头文件被包含方式： 库文件用<>  ,本地文件用"" 
 避免重复引用带来的预处理后代码冗余
 1
 #ifndef __TEST_H_
 #define __TEST_H_
     printf("\n");
 #endif
 2
 #pragma once (目前使用较多，很方便)
 
 条件编译：选择性编译代码
int main()
{
	int arr[10] = { 0 };
	int i = 0;
	for (i = 0; i < 10; i++)
	{
		arr[i] = i;
#ifdef DEBUG  // 判断是否被定义。 如果定义了DEBUG，则编译，否则不编译。
		printf("%d ", arr[i]);
#endif
	}
	return 0;
}
int main()
{                        // 多分支条件编译 常量表达式
#if 1==2                 // 如果第一条满足编译条件，则编译第一条，下面的不编译。
	printf("haha\n");
#elif 2==1
	printf("hehe\n");
#else
	printf("hihi\n");
#endif
	printf("\n");

	return 0;
}
int main()
{
#ifndef DEBUG         // 如果没定义，则编译
	printf("\n");
#endif
	return 0;
}

 嵌套指令
int main()
{
#if defined(OS_UNIX)
	#ifdef OPTION1
	  unix_version_option1();
    #endif
	#ifdef OPTION2
	  unix_version_option2();
	#endif
#elif defined(OS_MSDOS)
	#ifdef OPTION2
	msdos_version_option2();
	#endif
#endif
	return 0;
}
#include<stddef.h>
#define OFFSETOF(struct_name,member_name) (int)&(((struct_name*)0)->member_name)
struct S
{
	char c1;
	int a;
	char c2;
};
int main()
{
	struct S s;
	printf("%d\n", offsetof(struct S, c1));
	printf("%d\n", offsetof(struct S, a));
	printf("%d\n", offsetof(struct S, c2));
	return 0;
}

int main()
{
	//struct S s; 
	printf("%d\n", OFFSETOF(struct S, c1) );
	printf("%d\n", OFFSETOF(struct S, a)  );
	printf("%d\n", OFFSETOF(struct S, c2) );
	return 0;
}





SECOND
// 打印
//int main()
//{
//	printf("This is a C program.\n");
//	return 0;
//}
// 求和
//int main()
//{
//	int a, b, sum;
//	a = 123;
//	b = 456;
//	sum = a + b;
//	printf("sum is %d\n", sum);
//	return 0;
//}
// 找最大数
//int max(int x, int y)
//{
//	int z;
//	if (x > y)
//		z = x;
//	else
//		z = y;
//	return z;
//}
//int main()
//{
//	int a, b, c;
//	scanf_s("%d,%d", &a, &b);
//	c = max(a, b);
//	printf("max=%d\n", c);
//	return 0;
//}

// 程序：一组计算机能识别和执行的指令。
// 为什么需要计算机语言？ 便于人和计算机交流信息。
// 高级语言的特点：容易理解，功能强，适用任何型号的计算机。
// C语言特点：语言简洁紧凑，使用方便灵活；
//            运算符丰富；
//			  数据类型丰富；
//            具有结构化控制语句；
//            语法限制不严格，程序设计自由度大；
//            能直接访问物理地址，进行位操作；可移植性好；
//            生成目标代码质量高，程序执行效率高。

 程序=算法+数据结构
 算法：对操作的描述；数据结构：对数据的描述。
 简答算法举例
 1
int main()
{
	char arr[50]={0};
	int i = 0;
	for (i = 0; i < 50; i++)
	{
		arr[i] = i;
	}
	int n = 0;
	while (n < 50)
	{
		n = 1;
		if (arr[n] > 10)
		{
			printf("%d ", arr[n]);
		}
		n++;
	}
	return 0;
}
 2
int main()
{
	int year;
	for (year = 2000; year < 2501; year++)
	{
		if (year % 4 == 0)
		{
			if (year % 100 == 0)
			{
				printf("%d 不是闰年\n", year);
			}
			else
			{
				printf("%d 是闰年\n", year);
			}
		}
		else
		{
			printf("%d 不是闰年\n", year);
		}
	}
	return 0;
}
 3
int main()
{
	int sign = 1;
	double sum = 1.0;
	double term;
	double deno = 2.0;
	while (deno <= 100)
	{
		sign = (-1) * sign;
		term = sign * (1 / deno);
		sum = sum + term;
		deno = deno + 1;
	}
	printf("%f ", sum);
	return 0;
}
 4
int main()
{
	int a;
	scanf_s("%d", &a);
	int i = 2;
	while (i<= a/2)
	{
		if (a % i == 0)
		{
			printf("%d不是素数\n", a);
			return 0;
		}
		else
		{
			i++;
		}
	}
	printf("%d是素数", a);
	return 0;
}

// 3.1 顺序程序设计举例
// 1 华氏度转摄氏度
//int main()
//{
//	float f;
//	printf("请输入要转换的华氏度值：");
//	scanf_s("%f", &f);
//	float c = 5.0/9 * (f-32);
//	printf("转换得摄氏度为：%f\n", c);
//	return 0;
//}
// 2 计算存款利息
//int main()
//{
//	float p0 = 1000;
//	float r1 = 0.0036;
//	float r2 = 0.0225;
//	float r3 = 0.0198;
//	float p1, p2, p3;
//	p1 = p0 * (1 + r1); // 活期一年
//	p2 = p0 * (1 + r2); // 定期一年
//	p3 = p0 * (1 + r3/2)*(1+r3/2); // 两次半年定期
//	printf("p1=%f \np2=%f \np3=%f\n", p1, p2, p3);
//	return 0;
//}

// 3.2 数据表现形式及运算
// 3.2.1 常量和变量
//  1 常量：运行过程中值不能被改变的量（常数）
//    整型常量，实型常量（十进制小数形式，指数形式），字符常量（普通字符'c' 内存存其代码,转义字符\x),字符串常量（"afewf"),符号常量（#define定义）
//  2 变量：先定义名字类型，具有特定属性的存储单元。
//  3 常变量： const x  。 具有变量基本属性，不能改变其值。
//  4 标识符：用来对变量、符号名常量、函数、数组、类型等命名的有效字符序列。
// 3.2.2 数据类型
//  类型：对数据分配存储单元的安排（单元长度，存储形式）
//   基本类型：整型：基本整型int，短整型short int，长整型long int，双长整型long long int，字符型char，布尔型bool
//             浮点类型：单精度浮点型float，双精度浮点型double，复数浮点型float
//   枚举类型enum
//   空类型void
//   派生类型：指针类型* ，数组类型[] ，结构体类型struct ，共用体类型union ，函数类型。

// 3.3 运算符
// 3.3.1 C运算符
//  算术运算符，关系运算符，逻辑运算符，位运算符，赋值运算符，条件运算符，逗号运算符，指针运算符，求字节运算符，强制类型转换运算符，成员运算符，下标运算符
// 3.3.2 基本算术运算符
//  +(正) -(负) * /(取商) %(取余) + -
//  ++(自增)  --(自减）  ++i先使用i的值，再使+1. i++先使i+1，再使用i的值。

// 3.3.4 算术表达式和运算符的优先级与结合性
//  表达式求值时，先按运算符优先级顺序进行，同优先级的按结合方向处理（结合性）。
//  结合性可分：左结合性（自左向右），右结合性（自右向左）。 （算术运算符是左结合性，赋值运算符是右结合性）

// 3.3.5 不同类型数据间的混合运算
// 运算时将字节大小小的强制转换成字节大小最大的类型，再进行运算。
// 如果是字符型与整型数据运算，则将字符型对应代码与整型淑君进行运算。
// 应用：将大写字母输出成小写字母
//int main()
//{
//	char c1, c2;
//	c1 = 'A';
//	c2 = c1 + 32;
//	printf("%c\n", c1);
//	printf("%c\n", c2);
//  printf("%d\n", c2);
//	return 0;
//}

// 3.3.6 强制类型转换运算符
//  (类型) (表达式)  : 将表达式的类型强制转换成前面括号中的类型
//  仅在本次运算中生效，不改变表达式原有属性。


// 3.4 C语句
// 3.4.1 C语句的作用和分类
// 函数包含声明部分和执行部分。 执行部分由语句组成，语句用于向计算机发出操作指令，要求执行相应操作。
// 分类：
//  （1）控制语句
//       1.控制语句 if()...  else...
// 	     2.for()...
//       3.while()...
//       4.do...  while()
//       5.continue     结束本次循环（跳出所在循环，回到上一层继续执行）
//       6.break        终止switch或循环语句
//       7.switch()  case...
//       8.return       从函数返回
//       9.goto         转向
//       ...表示内嵌语句，()表示判断条件
//  （2）函数调用语句  函数名（参数1, ... ,参数n);
//  （3）表达式语句    表达式;  如赋值语句 a=3;
//  （4）空语句         ;
//  （5）复合语句      {.......} 用{}将语句和声明括起来，形成语句块

// 3.4.2 赋值语句
// 例：求三角形面积
//int main()
//{
//	double a, b, c, s,area;  // 定义变量类型
//	a = 3.67;  //给变量赋值
//	b = 5.43;
//	c = 6.21;
//	s = (a + b + c) / 2;
//	area = sqrt(s * (s - a) * (s - b) * (s - c)); // 用函数开方
//	printf("a=%f,b=%f,c=%f\n", a, b, c );         // 用函数打印
//	printf("area=%f\n", area);
//	return 0;
//}
//  1 赋值运算符 = （右结合性）
//  2 复合的赋值运算符 += -= *= /= %= 
//    a += 3     等价于 a=a+3
//    x *= y + 8 等价于 x=x*(y+8)
//  3 赋值表达式：将一个变量和一个表达式连接起来的式子。 变量 赋值运算符 表达式
//  4 赋值过程中的类型转换。 类型不一致，但都是基本类型时：
//      浮点型赋给整型，对浮点数取整再给整型。
//      整型赋给单双精度，数值不变以浮点数形式存储。
//      double赋给float，取有效数字存到4个字节中； float赋给double，数值不变，按8字节存。
//      字符型赋给整型，将ASCII代码赋给整型。
//      将字节大的整型赋给字节小的整型，将低字节赋值（斩首.如4存2，则只存4的低2）  ！！！导致转换失真
//  5 赋值表达式和赋值语句：赋值语句就是 赋值表达式;
//  6 变量赋初值。 创建变量=定义变量类型+（给变量赋值） 可以分别完成，也可一步完成。
//int main()
//{
//	int a;
//	a = 3; // 分别完成
//	char b = 'c'; //一步完成
//	return 0;
//}


// 3.5 数据的输入输出
// 3.5.1 例：求一元二次方程的根
//int main()
//{
//	double a, b, c,disc,x1,x2,p,q;
//	printf("请输出a,b,c的值\n");
//	scanf_s("%lf%lf%lf", &a, &b, &c);  //输入函数  双精度格式声明%lf
//	disc = b * b - 4 * a * c;
//	p = -b / (2.0 * a);
//	q = sqrt(disc) / (2.0 * a);
//	x1 = p + q;
//	x2 = p - q;
//	printf("x1=%7.2f\nx2=%7.2f\n", x1, x2); //输出函数
//	// 7.2 表示指定数据占7列，其中小数占2列。 好处：根据需求输出小数位数，使数据整齐美观。
//	return 0;
//}

// 3.5.2 有关数据输入输出的概念
//  输入输出是以计算机为主体而言的。  输出是向输出设备（显示屏，打印机等），输入是从输入设备（键盘，光盘，扫描仪）。
//  C语言本身不提供输入输出语句。 输入输出操作是通过函数来实现的，意味着我们可以自己定义函数来实现输入输出操作。
//  C语言的标准输入输出函数：putchar（输出字符），getchar（输入字符），printf（格式输出），scanf（格式输入），puts（输出字符串），gets（输入字符串）
//  在程序开头用预处理指令#include把有关文件（比如使用了某个库函数）放在本程序中。

// 3.5.3用printf函数输出数据
//   1 一般格式
//     "格式控制" : 用""括起来的字符串，包含格式声明（%字符）用于将数据转换成指定格式后输出，普通字符（它啥样输出啥样）。
//      域宽：%x字符， x是一个数，用来指定输出数据的宽度（列数），输出数据在右侧。
//      输出表列  ; ("...",x,y);  x,y即为输出表列，用于提供格式声明的元数据
//   2 格式字符; d表示有符号十进制数，c表示一个字符，s表示一个字符串，f表示以小数形式输出实数（由系统决定长度）。
//   3 指定数据宽度和小数位数： %m.nf m指定域宽，n指定小数位数。 如果n=0，则小数点一同省略。
//     输出数据向左对齐： %-m,nf
//   4 e格式符： 指定以指数形式输出实数。  一般自动输出  小数部分6位 指数部分5列。 如____1.234560e+002(_空格）
//   5 其他格式符; i（十进制整型按实际长度输出） o（八进制整数形式输出） x（十六进制形式输出） u（以十进制整型形式输出无符号数） g（输出浮点数自动变f或是e）
// 3.5.3 用printf函数输出数据
//   1 一般格式
//     "格式控制" : 用""括起来的字符串，包含格式声明（%字符）用于将数据转换成指定格式后输出，普通字符（它啥样输出啥样）。
//      域宽：%x字符， x是一个数，用来指定输出数据的宽度（列数），输出数据在右侧。
//      输出表列  ; ("...",x,y);  x,y即为输出表列，用于提供格式声明的元数据
//   2 格式字符; d表示有符号十进制数，c表示一个字符，s表示一个字符串，f表示以小数形式输出实数（由系统决定长度）。
//   3 指定数据宽度和小数位数： %m.nf m指定域宽，n指定小数位数。 如果n=0，则小数点一同省略。
//     输出数据向左对齐： %-m,nf
//   4 e格式符： 指定以指数形式输出实数。  一般自动输出  小数部分6位 指数部分5列。 如____1.234560e+002(_空格）
//   5 其他格式符; i（十进制整型按实际长度输出） o（八进制整数形式输出） x（十六进制形式输出） u（以十进制整型形式输出无符号数） g（输出浮点数自动变f或是e）

// 3.5.4 用scanf函数输入数据
//   1 一般格式 
//     "格式控制"同printf。 地址列表：可以是变量地址（&x），或者字符串首地址。（表示把输入的值存入哪里）
//   2 格式声明： 类printf。
//   3 注意事项：
//     scanf的格式控制后是变量地址（&x），而不是变量名（x）
//     如果除格式声明外还有其他字符，则后面地址列表注意对应关系。
//     转义字符和空格字符，在格式控制中都算作输入
//int main()
//{
//	char a, b, c;
//	scanf_s("%c%c%c", &a, &b, &c); // 输入abc    输入a b c
//	printf("%c%c%c\n", a, b, c); // 输出abc    输出a b
//	return 0;
//}    输入数值数据时，若输入空格、回车、tab或遇非法字符（不属于数值的字符），则数据输入结束。

// 3.5.5 字符输入输出函数
//   1 putchar输出一个字符： putchar(c);
//int main()
//{
//	char a = 'h', b = 'e', c = 'y';
//	int d = 66, e = 79, f = 89;
//	putchar(a);
//	putchar(b);
//	putchar(c);
//	putchar('\n');
//	putchar(d);
//	putchar(e);
//	putchar(f);
//	return 0;
//}
//   2 getchar输入一个字符：getchar()
//int main()
//{
//	char a = getchar();
//	char b = getchar();
//	putchar(a);
//	putchar(b);
//	putchar(getchar());
//	putchar('\n');
//	return 0;
//}
//   将输入的大写字母输出为小写
//int main()
//{
//	char c1, c2;
//	c1 = getchar();
//	c2 = c1 + 32;
//	putchar(c2);
//	return 0;
//}


// TEST
// 1 计算n年后生产总值增长多少倍
//int main()
//{
//	int n;
//	printf("请输入多少年：");
//	scanf_s("%d", &n);
//	double r = 0.07,p = 1.0 ;
//	int i = 0;
//	//for (i = 0; i < n ; i++)
//	//{
//	//	p = (1 + r) * p;
//	//}
//	p = pow(1 + r, n);
//	printf("增长了%f倍\n", p);
//	return 0;
//}

// 2 算利息（这老师这么喜欢经济问题吗）
//int main()
//{
//	double p1, p2, p3, p4, p5;
//	double r1 = 0.015, r2 = 0.021, r3 = 0.0275, r5 = 0.03, r0 = 0.0035;
//	printf("%f\n", p1 = 1000 * (1 + 5 * r5));
//	printf("%f\n", p2 = 1000 * (1 + 2 * r2)*(1 + 3 * r3));
//	printf("%f\n", p3 = 1000 * (1 + 3 * r3) * (1 + 2 * r2));
//	printf("%f\n", p4 = 1000 * pow(1 + r1, 5));
//	printf("%f\n", p5 = 1000 * pow(1 + r0 / 4, 20));
//	return 0;
//}

// 3 算还款所需月数
//int main()
//{
//	float d = 300000, p = 6000, r = 0.01, m;
//	m = log10(p / (p - d * r)) / log10(1 + r);
//	printf("m=%6.1f\n", m);
//	return 0 ;
//}

// 4 数据输入
//int main()
//{
//	int a, b;
//	float x, y;
//	char c1, c2;
//	scanf_s("%d%d", &a, &b);
//	scanf_s("%f%e", &x, &y);
//	scanf_s("%c%c", &c1, &c2);
//	return 0;
//}

// 5 译码
//int main()
//{
//	char a, b, c, d, e;
//	scanf_s("%c%c%c%c%c", &a,1, &b,1, &c,1, &d,1, &e,1);
//	printf("%c%c%c%c%c\n", (a + 4), (b + 4), (c + 4), (d + 4), (e + 4));
//	return 0;
//}

// 6 圆球相关运算
//int main()
//{
//	float r = 1.5, l, s, sb, vb, vp,pi=3.1415926;
//	int h = 3;
//	printf("圆周长=%6.2f\n圆面积=%6.2f\n圆球表面积=%6.2f\n圆球体积=%6.2f\n圆柱体积=%6.2f\n", l = 2 * pi * r,
//		s = pi * r * r, sb = 4 * pi * r * r, vb = 4.0 / 3.0 * pi * r * r * r, vp = pi * r * r * h);
//	return 0;
//}

// 4 选择结构（根据判断选择执行程序）
// 4.1 选择结构和条件判断
//   选择语句： if 双分支语句 ， switch 多分支语句
//int main()
//{
//	double a, b, c, disc, x1, x2, p, q;
//	scanf_s("%lf%lf%lf", &a, &b, &c);
//	disc = b * b - 4 * a * c;
//	if (disc < 0)
//		printf("无实根\n");
//	else
//	{
//		p = -b / (2.0 * a);
//		q = sqrt(disc) / (2.0 * a);
//		x1 = p + q;
//		x2 = p - q;
//		printf("x1=%7.2f\nx2=%7.2f\n", x1, x2);
//	}
//	return 0;
//}


// 4.2 用if语句实现选择结构
// 4.2.1 if语句举例
// 输入三个数，按由小到大输出(冒泡排序）
//int main()
//{
//	int arr[3] = { 0 };
//	int len = sizeof(arr)/4;
//	scanf_s("%d%d%d", &arr[0],&arr[1],&arr[2]);
//	int i = 0;
//	for (i = 0; i < len-1; i++)
//	{
//		int j = 0;
//		for (j = 0; j < len-1-i; j++)
//		{
//			if (arr[j] > arr[j + 1])
//			{
//				int tmp = arr[j + 1];
//				arr[j + 1] = arr[j];
//				arr[j] = tmp;
//			}
//		}
//	}
//	for (i = 0; i < len; i++)
//	{
//		printf("%d ", arr[i]);
//	}
//	return 0;
//}
// 4.2.2 if语句一般形式
//   1 if（表达式） 语句 
//   2 if（表达式） 
//       语句1
//     else
//       语句2
//   3 if（表达式1） 语句1
//     else if（表达式2） 语句2
//     else if（表达式3） 语句3
//     ......
//     else               语句n


// 4.3 关系运算符和关系表达式
//   比较符称关系运算符。
// 4.3.1 关系运算符及其优先级
//   高优先级： <  <=  >  >=
//   低优先级： ==  !=
//   关系运算符的优先级高于赋值运算符，低于算术运算符
// 4.3.2 关系表达式
//   用关系运算符将两个数值或数值表达式联系起来的式子。 结果为真返回1，结果为假返回0。


// 4.4 逻辑运算符和逻辑表达式
// 4.4.1 逻辑运算符及其优先级
//   与&&  或||  非！
//   优先级：! > && > || 。   ! > 算术运算符 > 关系运算符 > && > || > 赋值运算符

// 4.4.2 逻辑表达式
//int main()
//{
//	printf("%d", 5 > 3 && 8 < 4 - !0);  // 根据优先级计算，但是该写法非常容易理解出错，建议分步写。
//	return 0;
//}


// 4.5 条件运算符和条件表达式
//   条件表达式： 表达式1？表达式2：表达式3
//   含义：先执行表达式1，为真执行表达式2，为假执行表达式3。
//int main()
//{
//	int a, b, max;
//	if (a > b)
//		max = a;
//	else
//		max = b;
//	max = (a > b) ? a : b; // 上面四句等价于这一句
//	return 0;
//}


// 4.6 选择结构的嵌套
//   if语句内包含一个或多个if语句。  注意if else的对应关系。
//int main()
//{
//	int x, y;
//	scanf_s("%d", &x);
//	if (x < 0)
//	{
//		y = -1;
//	}
//	else
//	{
//		if (x == 0)
//		{
//			y = 0;
//		}
//		else
//			y = 1;
//	}
//	printf("%d", y);
//	return 0;
//}


// 4.7 switch语句实现多分支选择结构
//int main()
//{
//	char grade;
//	scanf_s("%c", &grade, 4);
//	printf("得分：\n");
//	switch (grade)
//	{
//	case'A':printf("85-100\n");  break;
//	case'B':printf("70-84\n");  break;
//	case'C':printf("60-69\n");  break;
//	case'D':printf("<60\n");  break;
//	default:printf("输入错误\n");
//	}
//	return 0;
//}


// 4.8 综合举例
// 1 判断闰年
//int main()
//{
//	int year, leap;
//	printf("请输入年份：");
//	scanf_s("%d", &year);
//	if ((year % 4 == 0)  && (year % 400 == 0))
//	{
//		leap = 1;
//		printf("是润年\n");
//	}
//	else
//	{
//		leap = 0;
//		printf("不是闰年\n");
//	}
//	return 0;
//}

// 2 求一元二次方程通解
//int main()
//{
//	double a, b, c, disc, x1, x2, realpart, imagpart;
//	scanf_s("%lf%lf%lf", &a, &b, &c);
//	printf("方程");
//	if (fabs(a) <= 1e-6)
//		printf("不是二次方程\n");
//	else
//	{
//		disc = b * b - 4 * a * c;
//		if (fabs(disc) <= 1e-6)
//			printf("有相同实根：%8.4f\n", -b / (2 * a));
//		else
//		{
//			if (fabs(disc > 1e-6))
//			{
//				x1 = (-b + sqrt(disc)) / (2 * a);
//				x2 = (-b - sqrt(disc)) / (2 * a);
//				printf("有两不同实根：%8.4f 和 %8.4f\n", x1, x2);
//			}
//			else
//			{
//				realpart = -b / (2 * a);
//				imagpart = sqrt(-disc) / (2 * a);
//				printf("有虚根：\n");
//				printf("%8.4f+%8.4fi\n", realpart, imagpart);
//				printf("%8.4f-%8.4fi\n", realpart, imagpart);
//			}
//		}
//	}
//	return 0;
//}

// 3 分档折扣
//int main()
//{
//	int c, s;
//	float p, w, d, f;
//	printf("请输入价格，重量，距离：");
//	scanf_s("%f%f%d", &p, & w, & s);
//	if (s >= 3000)
//		c = 12;
//	else
//		c = s / 250;
//	switch (c)
//	{
//	case 0: d = 0; break;
//	case 1: d = 2; break;
//	case 2:
//	case 3: d = 5; break;
//	case 4:
//	case 5:
//	case 6:
//	case 7: d = 8; break;
//	case 8:
//	case 9:
//	case 10:
//	case 11: d = 10; break;
//	case 12: d = 15; break;
//	default: break;
//	}
//	f = p * w * s * (1 - d / 100);
//	printf("总运费为=%10.2f\n", f);
//	return 0;
//}
// 4 分段函数
//int main()
//{
//	int x, y;
//	scanf_s("%d", &x);
//	if (x < 1)
//		y = x;
//	else if (1 <= x < 10)
//		y = 2 * x - 1;
//	else
//		y = 3 * x - 11;
//	printf("%d", y);
//	return 0;
//}

// 5 成绩分段
//int main()
//{
//	int x;
//	scanf_s("%d", &x);
//	if (x >= 90)
//		printf("A\n");
//	else if (80 <= x < 90)
//		printf("B\n");
//	else if (70 <= x < 79)
//		printf("C\n");
//	else if (60 <= x < 69)
//		printf("D\n");
//	else
//		printf("E\n");
//	return 0;
//}

// 6 六位以内正数，求位数、分别输出每一位、逆序输出各位数字
//int Number_of_bit(int x)
//{
//	int i = 1;
//	while ((x = x / 10) != 0)
//	{
//		i++;
//	}
//	return i;
//}
//void Print_bit(int x,int y)
//{
//	int arr[5] = { 0 };
//	int i = 0;
//	for (i = 0; i < 5; i++)
//	{ 
//		arr[i] = x % 10;
//		x= x / 10;
//	}
//	printf("个位到万未依次为：\n");
//	for (i = 0; i < 5; i++)
//	{
//		printf("%d\n", arr[i]);
//	}
//	printf("\n");
//	printf("逆序打印结果为：\n");
//	for (i = 0; i < 5; i++)
//	{
//		printf("%d", arr[i]);
//	}
//}
//
//int main()
//{
//	int x = 0 ;
//	scanf_s("%d", &x);
//	int y = Number_of_bit(x);
//
//	printf("%d\n", y);
//	Print_bit(x, y);
//	return 0;
//}

// 7 提成分档
//int main()
//{
//	int i;
//	double bonus, bon1, bon2, bon4, bon6, bon10;
//	bon1 = 100000 * 0.1;
//	bon2 = bon1 + 100000 * 0.075;
//	bon4 = bon2 + 200000 * 0.05;
//	bon6 = bon4 + 200000 * 0.03;
//	bon10 = bon6 + 400000 * 0.015;
//	printf("请输入利润i:");
//	if (i <= 100000)
//		bonus = i * 0.1;
//	else if (i <= 200000)
//		bonus = bon1 + (i - 100000) * 0.075;
//	else if (i <= 400000)
//		bonus = bon2 + (i - 200000) * 0.05;
//	else if (i <= 600000)
//		bonus = bon4 + (i - 4000000) * 0.03;
//	else if (i <= 1000000)
//		bonus = bon6 + (i - 600000) * 0.015;
//	else
//		bonus = bon10 + (i - 1000000) * 0.01;
//	printf("奖金为：%10.2f\n", bonus);
//	return 0;
//}



// 5 循环结果程序设计
// 5.1 循环结构重要性：解决相同的大量重复操作。
// 5.2 while语句循环：只要循环条件表达式为真，就执行循环体语句。
//int main()
//{
//	int i = 1, sum = 0;
//	while (i < 100)
//	{
//		sum = sum + i;
//		i++;
//	}
//	printf("sum=%d\n", sum);
//	return 0;
//}


// 5.3 do...while语句循环：先执行do内的表达式，在用while内的表达式进行判断，为真则继续循环。
//int main()
//{
//	int i = 10, sum = 0;
//	do
//	{
//		sum = sum + i;
//		i++;
//	} while (i <= 100);
//	printf("%d", sum);
//	return 0;
//}
// do...while与while的区别：前者不管判断结果，一上来就执行一次操作；后者先判断再执行。 导致当第一次判断为真时，两种执行结果相同，否则不同。


// 5.4 for语句循环
//   for(1循环变量赋初值;2循环条件;3循环变量增值)
//int main()
//{
//	int i,sum;
//	for (i = 0; i < 100; i++)
//	{
//		sum = sum + i;
//	}
//	printf("%d\n", sum);
//	return 0;
//}
//   for()内的三个表达式均可以省略，但;不能省略。
//   当循环条件省略时，会无限循环，需要在执行语句内内嵌终止条件。
//   循环变量赋初值，也可以是与循环变量无关的其他表达式。
//   表达式1、3可以是一个简单表达式，也可以是逗号表达式。  表达式2一般是关系或逻辑表达式，也可以是数字或字符表达式，只要值不为零就执行循环体。


// 5.5 循环嵌套
//   循环内包含一个完整的循环结构。
//   while，do...while，for可以相互嵌套。


// 5.6 几种循环的比较
//   一般情况下三种循环语句可以相互替代。
//   循环体中应该包含使循环趋于结束的语句。（不断逼近循环终止条件）
//   while，do...while的循环变量初始化，在循环前；for的循环变量初始化可以在循环前，也可以在表达式1中实现。
//   可以用break跳出循环，也可以用continue结束本次循环。


// 5.7 改变循环执行状态
//   某些条件下需要提早结束循环。
// 5.7.1 break提前终止循环
//#define SUM 100000 //定义符号常量代表100000
//int main()
//{
//	float amount, aver, total;
//	int i;
//	for (i = 0, total = 0; i <= 1000; i++)
//	{
//		printf("请输入金额：");
//		scanf_s("%f", &amount);
//		total = total + amount;
//		if (total >= SUM)
//			break;               // 使进程跳出循环体，接着执行循环体下面的语句。 break只能用于循环语句和switch语句。
//	}
//	aver = total / i;
//	printf("num=%d\naver=%10.2f\n", i, aver);
//	return 0;
//}

// 5.7.2 continue提前结束本次循环
//   有时不希望结束整个循环，只希望提前结束本次循环接着执行下次循环。
//int main()  //输出不能被3整除的数
//{
//	int n;
//	for (n = 100; n <= 200; n++)
//	{
//		if (n % 3 == 0) //作用：当n能被3整除，则跳过打印，从而筛选打印出不能被3整除的数。
//			continue;
//		printf("%d ", n);
//	}
//	printf("\n");
//	return 0;
//}

// 5.7.3 break与continue的区别
//   break是跳出所在的循环体，执行它下面的程序；continue是结束所在循环体的当前一个循环，继续执行下一次循环。
//int main()  //输出矩阵
//{
//	int i, j, n = 0;
//	for (i = 1; i <= 4; i++)
//	{
//		for (j = 1; j <= 5; j++,n++)
//		{
//			if (n % 5 == 0)
//				printf("\n");
//			printf("%d\t", i * j);
//		}
//	}
//	printf("\n");
//	return 0;
//}

// 5.7.4 循环程序举例
// 1 求pie近似值
//int main()
//{
//	int sign = 1;
//	double pi = 0.0;
//	double i = 1.0;
//	double term = 1.0;
//	while (fabs(term) >= 1e-6)   //fabs求绝对值函数
//	{
//		pi = pi + term;
//		i = i + 2;
//		sign = -sign;
//		term = sign/i;
//	}
//	pi = 4 * pi;
//	printf("%10.8f\n", pi);
//	return 0;
//}

// 2 求斐波那契数列前40个数
//int main()
//{
//	int f1 = 1, f2 = 1, f3;
//	int i;
//	printf("%12d\n%12d\n", f1, f2);
//	for (i = 1; i <= 38; i++)
//	{
//		f3 = f1 + f2;
//		printf("%12d\n", f3);
//		f1 = f2;
//		f2 = f3;
//	}
//	return 0;
//}
// 改进版
//int main()
//{
//	int f1 = 1, f2 = 1;
//	int i;
//	for (i = 1; i <= 20; i++)
//	{
//		printf("%12d %12d ", f1, f2);
//		if (i % 2 == 0)
//			printf("\n");  // 4个数一行
//		f1 = f1 + f2;
//		f2 = f2 + f1;
//	}
//	return 0;
//}

// 3 判断素数
//int main()
//{
//	int n, i, k;
//	printf("请输入：");
//	scanf_s("%d", &n);
//	k = sqrt(n);
//	for (i = 2; i <= k; i++)
//	{
//		if (n % i == 0)
//			break;
//	}
//	if (i <= k)      // 出循环时，若i<k说明n有因数；若i=k+1，说明在2到k个数内n都没有因数，即i是素数。
//		printf("%d 不是素数\n", n);
//	else
//		printf("%d 是素数\n", n);
//	return 0;
//}

// 4 求100到200的全部素数
//int main()
//{
//	int n, k, i, m = 0;
//	for (n = 101; n < 200; n=n + 2)  // 偶数一定不是素数，所以只对奇数进行计算以减少时间复杂度
//	{
//		k = sqrt(n);
//		for (i = 2; i <= k; i++)
//		{
//			if (n % i == 0)
//				break;
//		}
//		if (i >= k + 1)
//		{
//			printf("%d ", n);
//			m = m + 1;
//		}
//		if (m % 10 == 0)
//			printf("\n");  // 满十个数换行
//	}
//	printf("\n");
//	return 0;
//}

// 5 译码
//int main()
//{
//	char c;
//	c = getchar();
//	while ('c' != '\n')
//	{
//		if (('c' >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z'))
//		{
//			if ((c >= 'W' && c <= 'Z') || (c >= 'w' && c <= 'z'))
//				c = c - 22;
//			else
//				c = c + 4;
//		}
//		printf("%c",c);
//		c = getchar();
//	}
//	printf("\n");
//	return 0;
//}
// 改进
//int main()
//{
//	char c;
//	while (c = getchar() != '\n')
//	{
//		if (('c' >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z'))
//		{
//			c = c + 4;  // 先全加4
//			if ((c >= 'W' && c <= 'Z') || (c >= 'w' && c <= 'z'))
//				c = c - 26; // 属于最后四个字母的减22减4
//		}
//		printf("%c",c);
//	}
//	printf("\n");
//	return 0;
//}

// test
// 1 求两个正整数最大公约数和最小公倍数
//int main()
//{
//	int p, r, n, m, temp;
//	printf("请输入两个正整数n,m:");
//	scanf_s("%d,%d", &n, &m);
//	if (n < m)
//	{
//		temp = n;
//		n = m;
//		m = temp;
//	}
//	p = n * m;
//	while (m != 0)
//	{
//		r = n % m;
//		n = m;
//		m = r;
//	}
//	printf("最大公约数为%d\n", n);
//	printf("最小公倍数为%d\n", p / n);
//	return 0;
//}

// 2 输入一行字符分别统计各类字符个数
//int main()
//{
//	char c;
//	int letters = 0, space = 0, digit = 0, other = 0;
//	while ((c = getchar()) != '\n')
//	{
//		if ((c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z'))
//			letters++;
//		else if (c == ' ')
//			space++;
//		else if (c >= '0' && c <= '9')
//			digit++;
//		else
//			other++;
//	}
//	printf("字母数：%d\n空格数：%d\n数字数：%d\n其他字符数：%d\n", letters, space, digit, other);
//	return 0;
//}

// 3 求和
//int main()
//{
//	double Sn = 0;
//	int n = 0, a = 0, term = 0;
//	scanf_s("%d%d", &a, &n);
//	int i = 0;
//	for (i = 0; i < n; i++)
//	{
//		term = term + a;
//		Sn = Sn + term;
//		a = a * 10;
//	}
//	printf("%f\n", Sn);
//	return 0;
//}

// 4 求阶乘
//int main()
//{
//	double Sn=0, term;
//	int n;
//	scanf_s("%d", &n);
//	int j = 0;
//	for (j = 1; j <= n; j++)
//	{
//		term = 1.0;
//		int k = j;
//		while (k)
//		{
//			term = term * k;
//			k--;
//		}	
//		Sn = Sn + term;
//	}
//	printf("%22.15e\n", Sn);
//	return 0;
//}
//  明显更好
//int main()
//{
//	double s = 0, t = 1;
//	int n,k;
//	scanf_s("%d", &k);
//	for (n = 1; n <= k; n++)
//	{
//		t = t * n;
//		s = s + t;
//	}
//	printf("%22.15e\n", s);
//	return 0;
//}

// 5 求和2
//int main()
//{
//	int i = 0;
//	double s1 = 0, s2 = 0, s3 = 0, s;
//	for (i = 1; i <= 100;i++)
//	{
//		s1 = s1 + i;
//	}
//	for (i = 1; i <= 50; i++)
//	{
//		s2 = s2 + i * i;
//	}
//	for (i = 1; i <= 10; i++)
//	{
//		s3 = s3 + 1 / i;
//	}
//	s = s1 + s2 + s3;
//	printf("%15.6f\n", s);
//	return 0;
//}

// 6 求水仙花数
//int main()
//{
//	int i, b, s, g;
//	for (i = 100; i <= 999; i++)
//	{
//		b = i / 100;
//		s = i / 10 - b * 10;
//		g = i % 10;
//		if (i == b * b * b + s * s * s + g * g * g)
//		{
//			printf("%d ", i);
//		}
//	}
//	printf("\n");
//	return 0;
//}

// 7 求完数
//int main()
//{
//	int m,s,i;
//	for (m = 2; m < 1000; m++)
//	{
//		s = 0;
//		for (i = 1; i < m; i++)
//		{
//			if ((m % i) == 0)  // m%i=0 则i就是m的因数
//				s = s + i;     // 用s来累加m的因数
//		}
//		if (s == m)            // 如果s=m，则m就是完数
//		{
//			printf("%d,它的因数是:", m);
//			for (i = 1; i < m; i++)  // 再循环一次，打印完数的因数。
//			{
//				if (m % i == 0)
//					printf("%d ", i);
//			}
//			printf("\n");
//		}
//	}
//	return 0;
//}

// 8 分数数列求和
//int main()
//{
//	int i,n;
//	scanf_s("%d", &n);
//	double s = 0,tmp, term1 = 1,term2 = 1;
//	for (i = 1; i <= n; i++)
//	{
//		tmp = term2;
//		term2 = term2 + term1;
//		term1 = tmp;
//		s = s + term2/term1;
//	}
//	printf("%16.10f\n", s);
//	return 0;
//}

// 9 球反弹1/2高度，求十次反弹时的高度和总路程
//int main()
//{
//	float h = 100.0;
//	int i,n;
//	scanf_s("%d", &n);
//	float s = 100.0;
//	for (i = 1; i <= n; i++)
//	{
//		s = s + h;
//		h = h / 2;
//	}
//	printf("总路程%f\n此时高度为%f\n", s, h);
//	return 0;
//}

// 10 猴子吃桃
//int main()   // 倒推计算
//{
//	int i;
//	int all = 1;
//	for (i = 1; i <= 9; i++)
//	{
//		all = (all + 1) * 2;
//	}
//	printf("%d\n", all);
//	return 0;
//}
//int main()    // 正推计算
//{
//	int day, x1, x2;
//	day = 9;
//	x2 = 1;
//	while (day > 0)
//	{
//		x1 = (x2 + 1) * 2;
//		x2 = x1;
//		day--;
//	}
//	printf("%d\n", x1);
//	return 0;
//}

// 11 迭代法求平方根
//int main()
//{
//	float a,x1,x2;
//	scanf_s("%f", &a);
//	int i;
//	x1 = a / 2;
//	for (i = 0;; i++)
//	{
//		x2 = (x1 + a / x1) / 2;
//		if (fabs(x2 - x1) <= 1e-5)
//			break;
//		x1 = x2;
//	}
//	printf("%8.5f\n", x2);
//	return 0;
//}

// 12 牛顿迭代法求方程根
//int main()
//{
//	double x1, x0, f, f1;
//	x1 = 11.5;
//	do
//	{
//		x0 = x1;
//		f = ((2 * x0 - 4) * x0 + 3) * x0 - 6;
//		f1 = (6 * x0 - 8) * x0 + 3;
//		x1 = x0 - f / f1;
//	} while (fabs(x1 - x0) >= 1e-5);
//	printf("%5.2f\n", x1);
//	return 0;
//}

// 13 二分法求方程根
//int main()
//{
//	float x0, x1, x2, fx0, fx1, fx2;
//	do
//	{
//		printf("请输入x1,x2:");
//		scanf_s("%f.%f", &x1, &x2);
//		fx1 = x1 * ((2 * x1 - 4) * x1 + 3) - 6;
//		fx2 = x2 * ((2 * x2 - 4) * x2 + 3) - 6;
//	} while (fx1 * fx2 > 0);
//	do
//	{
//		x0 = (x1 + x2) / 2;
//		fx0 = x0 * ((2 * x0 - 4) * x0 + 3) / 6;
//		if ((fx0 * fx1) < 0)
//		{
//			x2 = x0;
//			fx2 = fx0;
//		}
//		else
//		{
//			x1 = x0;
//			fx1 = fx0;
//		}
//	} while (fabs(fx0) >= 1e-5);
//	printf("x=%6.2f\n", x0);
//	return 0;
//}

// 14 打印图案
//int main()
//{  
//	printf("    *      *****************     \n");
//	printf("    *      *       *       *     \n");
//	printf("    *      *       *       *     \n");
//	printf("    *      *   *   *   *   *     \n");
//	printf("    *      *       *       *     \n");
//	printf("*   *      *       *       *     \n");
//	printf(" *  *  *   *****************     \n");
//	printf("  * * *                          \n");
//	printf("   **         ***********         \n");
//	printf("    *         *         *         \n");
//	printf("********      ***********         \n");
//	printf("     *                           \n");
//	printf("    *       ***************      \n");
//	printf("   *                             \n");
//	return 0;
//}
//int main()
//{
//	int i, j, k;
//	for (i = 0; i <= 3; i++)
//	{
//		for (j = 0; j <= 2 - i; j++)
//		{
//			printf(" ");
//		}
//		for (k = 0; k <= 2 * i; k++)
//		{
//			printf("*");
//		}
//		printf("\n");
//	}
//	for (i = 0; i <= 2; i++)
//	{
//		for (j = 0; j <= i; j++)
//		{
//			printf(" ");
//		}
//		for (k = 0; k <= 4 - 2 * i; k++)
//		{
//			printf("*");
//		}
//		printf("\n");
//	}
//	return 0;
//}

// 15 逻辑分析
//int main()
//{
//	char i, j, k;
//	for (i = 'x'; i <= 'z'; i++)
//	{
//		for (j = 'x'; j <= 'z'; j++)
//		{
//			if(i!=j)
//				for (k = 'x'; k <= 'z'; k++)
//				{
//					if (i != k && j != k)
//					{
//						if (i != 'x' && k != 'x' && k != 'z')
//							printf("A--%c\nB--%c\nC--%c\n", i, j, k);
//					}
//				}
//		}
//	}
//	return 0;
//}


// 6 数组
//   数组是一组有序数据的集合，用一个数组名和下标来唯一确定数组中的元素，每一个元素都属于同一个数据类型。
// 6.1 定义和引用一维数组
// 6.1.1 定义一维数组
//   int a[10];   类型 数组名[常量表达式];  常量表达式用来表示元素个数。

// 6.1.2 引用一维数组
//   对数组定义、赋值后，可以引用数组中的元素，一次只能引用一个元素而不能引用整体。
//   数组名[下标];
//int main()
//{
//	int arr[10] = { 0 };
//	int i;
//	for (i = 0; i < 10; i++) // 数组下标从0开始！
//	{
//		arr[i] = i;
//	}
//	for (i = 9; i >= 0; i--)
//	{
//		printf("%d ", arr[i]);
//	}
//	return 0;
//}

// 6.1.3 一维数组初始化
//   常在定义数组时给各数组元素赋值，称数组的初始化。
//   1 定义数组时对全部元素赋初值。
//     int arr[10] = { 0,1,2,3,4,5,6,7,8,9 };
//   2 可以只给部分元素赋值。
//     int arr[10] = { 0,1,2,3,4 };  表示只给前五个元素赋值，后五个自动赋0
//   3 如果给一个数组全部元素赋0.
//     int arr[10] = { 0,0,0,0,0,0,0,0,0,0 };  或 int arr[10] = { 0 };
//   4 对全部数组元素赋初值时，可以省略数组长度
//     int arr[5] = { 0,1,2,3,4 };   或  int arr[] = { 0,1,2,3,4 };

// 6.1.4 一维数组程序举例
// 1 fibonacci
//int main()
//{
//	int i;
//	int f[20] = { 1,1 };
//	for (i = 2; i < 20; i++)
//	{
//		f[i] = f[i - 2] + f[i - 1];
//	}
//	for (i = 0; i < 20; i++)
//	{
//		if (i % 5 == 0)
//			printf("\n");
//		printf("% 12d", f[i]);
//	}
//	printf("\n");
//	return 0;
//}

// 2 冒泡排序
//int main()
//{
//	int arr[10] = { 0 };
//	int i, j, t;
//	printf("请输入10个数：");
//	for (i = 0; i < 10; i++)
//	{
//		scanf_s("%d", &arr[i]);
//	}
//	printf("\n");
//	for (j = 0; j < 9; j++)
//	{
//		for (i = 0; i < 9 - j; i++)
//		{
//			if (arr[i] > arr[i + 1])
//			{
//				t = arr[i];
//				arr[i] = arr[i + 1];
//				arr[i + 1] = t;
//			}
//		}
//	}
//	printf("排序结果为:");
//	for (i = 0; i < 10; i++)
//	{
//		printf("%d ", arr[i]);
//	}
//	printf("\n");
//	return 0;
//}


// 6.2 定义和引用二维数组
// 6.2.1 定义二维数组
//   定义： 类型 数组名[常量表达式1][常量表达式2];
//   表达式1代表行，表达式2代表列。 实际内存中是按行连续存放的，而不是按矩阵存放。
//   c语言允许使用多维数组。

// 6.2.2 引用二维数组
//   引用： 数组名[下标][下标];
//   注意： 定义数组时a[3][4] 代表一个有三行四列的数组，而由于数组元素下标从0开始，所以实际元素是从a[0][0]到a[2][3],不存在元素a[3][4]。

// 6.2.3 二维数组初始化
//   1 分行给二维数组初始化
//      int arr[3][4] = { {1,2,3,4},{5,6,7,8},{9,10,11,12} };
//   2 所有数组写在一个括号内
//     int arr[3][4] = { 1,2,3,4,5,6,7,8,9,10,11,12 };  
//     太杂乱，容易遗漏，不方便检查。
//   3 可以对部分数据赋初值
//     int arr[3][4] = { {1},{2},{3} };
//     给每一行的第一个元素赋值，其余默认赋0.
//   4 如果对全部元素都赋初值，则第一维长度可以省略，但第二行长度不能省略。
//     int arr[ ][4] = { {1,2,3,4},{5,6,7,8},{9,10,11,12} };   系统会自己推算出第一维长度
//     定义时也可只对部分元素赋初值而省略第一维长度，如：
//     int arr[][4] = { {1,2,3},{},{4,5} };

// 6.2.4 二维数组程序举例
//   1 二维数组行列互换存至另一数组
//int main()
//{
//	int arr1[2][3] = { {1,2,3},{4,5,6} };
//	int arr2[3][2] = { 0 };
//	int i,j,t;
//	printf("数组1: \n");
//	for (i = 0; i < 2; i++)
//	{
//		for (j = 0; j < 3; j++)
//		{
//			printf("%5d", arr1[i][j]);
//			arr2[j][i] = arr1[i][j];
//		}
//		printf("\n");
//	}
//	printf("\n");
//	printf("数组2: \n");
//	for (i = 0; i < 3; i++)
//	{
//		for (j = 0; j < 2; j++)
//		{
//			printf("%5d", arr2[i][j]);
//		}
//		printf("\n");
//	}
//	printf("\n");
//	return 0;
//}
//   2 输出矩阵中值最大的元素，并输出其下标
//int main()
//{
//	// 初始化
//	int arr[3][4] = { 0 };
//	int i, j,mh,ml;
//	// 赋初值
//	for (i = 0; i < 3; i++)
//	{
//		for (j = 0; j < 4; j++)
//		{
//			scanf_s("%d", &arr[i][j]);
//		}
//	}
//	int max = arr[0][0];
//	// 打印矩阵
//	for (i = 0; i < 3; i++)
//	{
//		for (j = 0; j < 4; j++)
//		{
//			printf("%5d", arr[i][j]);
//		}
//		printf("\n");
//	}
//	// 找最大的元素: 每一行里比较，再每行最大数之间比较
//	for (i = 0; i < 3; i++)
//	{
//		for (j = 0; j < 4; j++)
//		{
//			if (arr[i][j] > max)
//			{
//				max = arr[i][j];
//				mh = i;
//				ml = j;
//			}
//		}
//	}
//	// 打印最大数及其下标
//	printf("最大数为arr[%d][%d]=%d\n", mh, ml, arr[mh][ml]);
//	return 0;
//}

// 6.3 字符数组
// 6.3.1 定义字符数组
//   char 数组名[常量表达式];

// 6.3.2 字符数组初始化
//   类整型数组
//   char c[4] = { 'c','v','b','d' };

// 6.3.3 引用字符数组中的元素
//int main()
//{
//	char c[15] = { 'i',' ','a','m',' ','a',' ','s','t','u','d','e','n','t','.' };
//	int i;
//	for (i = 0; i < 15; i++)
//	{
//		printf("%c", c[i]);
//	}
//	printf("\n");
//	return 0;
//}

// 6.3.4 字符串和字符串结束标志
//   c语言中，将字符串作为字符数组处理。
//   以\0作为字符串结束标志。遇到\0将前面的字符组成一个字符串。
//   系统在用字符数组存储字符串常量会自动补\0。
//   字符数组的另一种写法 char c[] = { "I am unhappy" };  甚至可以省略{}

// 6.3.5 字符数组的输入输出
//   1 逐个字符输入输出，用格式符%c
//   2 整个字符串一次输入或输出，用格式符%s
//   注意：数组中未赋值的元素自动赋\0，输出时遇到\0结束，所以可能导致输出部分。

// 6.3.6 使用字符串处理函数
//   1 puts函数 输出字符串
//int main()
//{
//	char str[] = { "China\nBeijing" };
//	puts(str);
//	return 0;
//}
//  2 gets函数 输入字符串
//int main()
//{
//	char str[255] = {"0"};
//	gets_s(str);
//	return 0;
//}
//  3 strcat函数 字符串连接函数
//int main()
//{
//	char str1[30] = { "People's Republic of " };
//	char str2[] = { "China" };
//	printf("%s", strcat(str1, str2));
//	return 0;
//}
//  4 strcpy和strncpy函数 字符串复制函数
//int main()
//{
//	char str1[10], str2[] = "china";
//	strcpy(str1, str2);
//	return 0;
//}
//  5 strcmp函数 字符串比较函数
//    将两个字符串自左至右逐个字符相比（按照ASCII码大小），直到出现不同字符或\0。
//    对于英文字母比大小，字母靠后的大，小写比大写大。
//    函数返回值：相同得0，大得正整数，小得负整数
//  6 strlen函数 测字符串长度
//int main()
//{
//	char str[10] = "china";
//	int a = strlen(str);
//	printf("%d\n", a); // 5 测字符串有效长度，不算'\0'
//	return 0;
//}
//  7 strlwr函数 转换小写函数
//    大写字母转小写
//  8 strupr函数 转换大写函数
//    小写字母转大写

// 6.3.7 字符数组应用举例
//   1 输入一行字符，统计其中单词数并用空格分隔开
//int main()
//{
//	char str[81];
//	int i, num = 0, word = 0;
//	char c;
//	gets_s(str,81);
//	for (i = 0; (c = str[i]) != '\0'; i++)
//	{
//		if (c == ' ')
//		{
//			word = 0;
//		}
//		else if (word == 0)
//		{
//			word = 1;
//			num++;
//		}
//	}
//	printf("单词数为%d\n", num);
//	return 0;
//}
//   2 3个字符串找其中最大的
//int main()
//{
//	char str[3][20];
//	char string[20];
//	int i;
//	for (i = 0; i < 3; i++)
//	{
//		gets_s(str[i], 20);
//	}
//	if (strcmp(str[0], str[1]) > 0)
//		strcpy(string, str[0]);
//	else
//		strcpy(string, str[1]);
//	if (strcmp(str[2], string) > 0)
//		strcpy(string, str[2]);
//	printf("最大的字符串为%s\n", string);
//	return 0;
//}

// test 
// 1 筛选法求100以内素数  Eratosthenes筛法
//int main()  // 试除法
//{
//	int i,j;
//	for (i = 0; i <= 100; i++)
//	{
//		for (j = 2; j <= i; j++)
//		{
//			if (i % j == 0)
//			{
//				break;
//			}
//		}
//		if (i == j)
//		{
//			printf("%d ", i);
//		}
//	}
//	printf("\n");
//	return 0;
//}
//int main()
//{
//	int i, j, n, a[101];
//	for (i = 1; i <= 100; i++)
//	{
//		a[i] = i;
//	}
//	a[1] = 0;
//	for (i = 2; i < sqrt(100); i++)
//	{
//		for (j = i + 1; j <= 100; j++)
//		{
//			if (a[i] != 0 && a[j] != 0)
//			{
//				if (a[j] % a[i] == 0)
//					a[j] = 0;                // 挖掉非素数
//			}
//		}
//	}
//	printf("\n");
//	for (i = 2, n = 0; i < 100; i++)      // 选出值不为0的元素打印（即打印素数）
//	{
//		if (a[i] != 0)
//		{
//			printf("%5d", a[i]);
//			n++;
//		}
//		if (n == 10)
//		{
//			printf("\n");
//			n = 0;
//		}
//	}
//	printf("\n");
//	return 0;
//}
// 2 选择法对10个整数排序
int main()
{
	int i, j, min, temp, a[11];
	printf("输入数据：\n");
	for (i = 1; i <= 10; i++)
	{
		printf("a[%d]=", i);
		scanf_s("%d", &a[i]);
	}
	printf("\n");
	printf("初始数据为：\n");
	for (i = 1; i <= 10; i++)
	{
		printf("%5d", a[i]);
	}
	printf("\n");
	for (i = 1; i <= 9; i++)
	{
		min = i;
		for (j = i + 1; j <= 10; j++)
		{
			if (a[min] > a[j])
				min = j;
		}
		temp = a[i];
		a[i] = a[min];
		a[min] = temp;
	}
	printf("\n排序后：\n");
	for (i = 1; i <= 10; i++)
	{
		printf("%5d", a[i]);
	}
	printf("\n");
	return 0;
}
 3 求3x3整型矩阵对角线元素之和
int main()
{
	int a[3][3], sum = 0;
	int i, j;
	printf("请输入矩阵元素：\n");
	for (i = 0; i < 3; i++)
	{
		for (j = 0; j < 3; j++)
		{
			scanf_s("%3d", &a[i][j]);
		}
	}
	for (i = 0; i < 3; i++)
	{
		sum = sum + a[i][i];
	}
	printf("sum=%6d\n", sum);
	return 0;
}
 4 已有排序好的数组，输入一个元素按原有规律插入数组
int main()
{
	int arr[11] = { 1,4,6,9,13,19,28,40,100 };
	int temp1, temp2, number, end, i, j;
	printf("arr:\n");
	// 输出初始数组
	for (i = 0; i <= 10; i++)
	{
		printf("%5d", arr[i]);
	}
	printf("\n");
	// 输入元素
	printf("请输入一个元素：\n");
	scanf_s("%d", &number);
	// 判断元素大小，插入元素
	end = arr[9];
	if (number > end)
		arr[10] = number;
	else
	{
		for (i = 0; i < 10; i++)
		{
			if (arr[i] > number)
			{
				temp1 = arr[i];
				arr[i] = number;
				for (j = i + 1; j < 11; j++) // 改变元素下标
				{
					temp2 = arr[j];
					arr[j] = temp1;
					temp1 = temp2;
			    }
			break;
			}
		}
	}
	// 输出新数组
	printf("new arr:\n");
	for (i = 0; i <= 11; i++)
	{
		printf("%5d", arr[i]);
	}
	printf("\n");
	return 0;
}
// 5 数组中的值逆序重新存放
//int main()
//{
//	int arr[5], i, temp;
//	printf("输入元素：\n");
//	for (i = 0; i <= 4; i++)
//	{
//		scanf_s("%d", &arr[i]);
//	}
//	for (i = 0; i < 3; i++)
//	{
//		temp = arr[i];
//		arr[i] = arr[5 - i - 1];
//		arr[5 - i - 1] = temp;
//	}
//	printf("new array: \n");
//	for (i = 0; i <= 4; i++)
//	{
//		printf("%d ", arr[i]);
//	}
//	printf("\n");
//	return 0;
//}
// 6 输出十行杨辉三角形
//#define N 10
//int main()
//{
//	int i, j, arr[N][N];
//	for (i = 0; i < N; i++)  // 左右两列赋1
//	{
//		arr[i][i] = 1;         
//		arr[i][0] = 1;
//	}
//	for (i = 2; i < N; i++)
//	{
//		for (j = 1; j <= i - 1; j++)
//		{
//			arr[i][j] = arr[i - 1][j-1] + arr[i-1][j];
//		}
//	}
//	for (i = 0; i < N; i++)
//	{
//		for (j = 0; j <= i; j++)
//		{
//			printf("%6d", arr[i][j]);
//		}
//		printf("\n");
//	}
//	printf("\n");
//	return 0;
//}
// 7 输出1到n平分的自然数构成的魔方阵（每一行列对角线之和相等）
//int main()
//{
//	int arr[15][15], i, j, k, p, n;
//	p = 1;
//	while (p == 1)  // 输入阶数并判断合法性
//	{
//		printf("请输入阶数（15阶以内奇数阶）：\n");
//		scanf_s("%d", &n);
//		if ((n != 0) && (n <= 15) && (n % 2 != 0))
//		{
//			p = 0;
//		}
//	}
//	// 初始化
//	for (i = 1; i <= n; i++)
//	{
//		for (j = 1; j <= n; j++)
//		{
//			arr[i][j] = 0;
//		}
//	}
//	// 建立魔法阵
//	j = n / 2 + 1;
//	arr[1][j] = 1;
//	for (k = 2; k <= n * n; k++)
//	{
//		i = i - 1;
//		j = j + 1;
//		if ((i < 1) && (j > n))
//		{
//			i = i + 2;
//			j = j - 1;
//		}
//		else
//		{
//			if (i < 1)
//				i = n;
//			if (j > n)
//				j = 1;
//		}
//		if (arr[i][j] == 0)
//		{
//			arr[i][j] = k;
//		}
//		else
//		{
//			i = i + 2;
//			j = j - 1;
//			arr[i][j] = k;
//		}
//	}
//	// 输出魔方阵
//	for (i = 1; i <= n; i++)
//	{
//		for (j = 1; j <= n; j++)
//		{
//			printf("%6d", arr[i][j]);
//		}
//		printf("\n");
//	}
//	printf("\n");
//	return 0;
//}
// 8 找一个二维数组中的鞍点（该点为行最大值，列最小值）
//#define N 4
//#define M 5
//int main()
//{
//	int arr[N][M], i, j, k, h;
//	printf("请输入一个4行五列的数组：\n");
//	for (i = 0; i < N; i++)
//	{
//		for (j = 0; j < M; j++)
//		{
//			scanf_s("%d", &arr[i][j]);
//		}
//	}
//	// 输出数组
//	printf("数组为：\n");
//	for (i = 0; i < N; i++)
//	{
//		for (j = 0; j < M; j++)
//		{
//			printf("%6d", arr[i][j]);
//		}
//		printf("\n");
//	}
//	// 找鞍点
//	int max = 0;
//	int l = 0;
//	int flag = 0;
//	for (i = 0; i < N; i++)
//	{
//		for (j = 0; j < M; j++)
//		{
//			if (arr[i][j] > max)
//			{
//				max = arr[i][j];
//				h = i;
//				l = j;
//			}
//		}
//		flag = 1;
//		for (k = 0; k < N; k++)
//		{
//			if (arr[k][l] < max)
//			{
//				flag = 0;
//				continue;
//			}
//		}
//		if(flag)
//		{
//			printf("鞍点为：arr[%d][%d] = %d\n", h, l, max);
//			break;
//		}
//	}
//	if (!flag)
//	{
//		printf("该数组没有鞍点\n");
//	}
//
//	printf("\n");
//	return 0;
//}
// 9 数组元素查找 二分法
#define N 15
int main()
{
	// 初始化
	int arr[N], i, number, top, bott, mid, loca, flag = 1, sign;
	char c;
	// 创建数组
	printf("输入数据：\n");
	scanf_s("%d", &arr[0]);
	i = 1;
	while (i < N)  // 强制从小到大输入数组元素
	{
		scanf_s("%d", &arr[i]);
		if (arr[i] >= arr[i - 1])
		{
			i++;
		}
		else
		{
			printf("请重新输入数据：\n");
		}
	}
	printf("\n");
	// 打印数组
	for (i = 0; i < N; i++) 
	{
		printf("%5d", arr[i]);
	}
	printf("\n");
	// 元素查找
	while (flag)
	{
		printf("请输入查找元素的值：\n");
		scanf_s("%d", &number);
		sign = 0;
		top = 0;
		bott = N - 1;
		if ((number < arr[0]) || (number > arr[N - 1]))
		{
			loca = -1;
		}
		while ((!sign) && (top <= bott))
		{
			mid = (bott + top) / 2;
			if (number == arr[mid])
			{
				loca = mid;
				printf("找到元素%d，位置是%d\n", number, loca + 1);
				sign = 1;
			}
			else if (number < arr[mid])
			{
				bott = mid - 1;
			}
			else
				top = mid + 1;
		}
		if (!sign || loca == -1)
		{
			printf("找不到该元素\n");
		}
		// 程序是否继续
		printf("是否继续查找(Y\N)?");
		scanf_s("%c", &c, 1);
		if (c == 'N' || c == 'n')
		{
			flag = 0;
		}
	}
	return 0;
}
// 10 统计文章中大写字母，小写字母，数字，空格及其他字符个数
//#define N 3
//#define M 80
//int main()
//{
//	// 初始化
//	int i, j, k, upp, low, dig, spa, oth;
//	char a[N][M] = { 0 };
//	// 输入内容
//	for (i = 0; i < N; i++)
//	{
//		printf("请输入内容：\n");
//		for (j = 0; j < M; j++)
//		{
//			scanf_s("%c", &a[i][j], 1);
//			for (k = 0; (k < M) && (a[i][k] != '\0'); k++)
//			{
//				if (a[i][k] >= 'A' && a[i][k] <= 'Z')
//				{
//					upp++;
//				}
//				else if (a[i][k] >= 'a' && a[i][k] <= 'z')
//				{
//					low++;
//				}
//				else if (a[i][k] >= '0' && a[i][k] <= '9')
//				{
//					dig++;
//				}
//				else if (a[i][k] == ' ')
//				{
//					spa++;
//				}
//				else
//				{
//					oth++;
//				}
//			}
//		}
//	}
//	// 输出内容
//	for (i = 0; i < N; i++)
//	{
//		for (j = 0; j < M; j++)
//		{
//			printf("%c", a[i][j]);
//		}
//	}
//	printf("\n");
//	// 输出统计结果
//	printf("大写字母个数为：%d\n", upp);
//	printf("小写字母个数为：%d\n", low);
//	printf("数字个数为：%d\n", dig);
//	printf("空格个数为：%d\n", spa);
//	printf("其他字符个数为：%d\n", oth);
//	return 0;
//}
// 11 打印图案
// 法1
//#define N 5
//#define M 9
//#define D 5
//int main()
//{
//	char a[N][M] = { 0 };
//	int i, j, k;
//	// 全部置*
//	for (i = 0; i < N; i++)
//	{
//		for (j = 0; j < M; j++)
//		{
//			a[i][j] = '*';
//		}
//	}
//	// 规定位置置空格
//	k = M - D;
//	for (i = 1; i < N; i++)
//	{
//		for (j = 0; j <= k - 4; j++)
//		{
//			a[i][j] = ' ';
//		}
//		k++;
//	}
//	k = M - 1;
//	for (i = N - 2; i >= 0; i--)
//	{
//		for (j = M-1; j >= k; j--)
//		{
//			a[i][j] = ' ';
//		}
//		k--;
//	}
//	// 输出图像
//	for (i = 0; i < N; i++)
//	{
//		for (j = 0; j < M; j++)
//		{
//			printf("%c ", a[i][j]);
//		}
//		printf("\n");
//	}
//	printf("\n");
//	return 0;
//}
// 法2
//int main()
//{
//	char a[5] = { '*','*', '*', '*', '*' };
//	int i, j, k;
//	for (i = 0; i < 5; i++)
//	{
//		printf("\n");
//		for (j = 1; j <= i; j++)
//		{
//			printf(" ");
//		}
//		for (k = 0; k < 5; k++)
//		{
//			printf("%c", a[k]);
//		}
//	}
//	printf("\n");
//	return 0;
//}
// 12 译码
//int main()
//{
//	int i, j, n;
//	char ch[80], tran[80];
//	printf("请输入原码：\n");
//	gets_s(ch, 80);
//	printf("原码为：%s\n", ch);
//	j = 0;
//	while (ch[j] != '\0')
//	{
//		if ((ch[j] >= 'A') && (ch[j] <= 'Z'))
//		{
//			tran[j] = 155 - ch[j];
//		}
//		else if ((ch[j] >= 'a') && (ch[j] <= 'z'))
//		{
//			tran[j] = 219 - ch[j];
//		}
//		else
//			tran[j] = ch[j];
//		j++;
//	}
//	n = j;  // 记录j个数，即记录有效字符数，防止输出译码+乱码。
//	for (j = 0; j < n; j++)
//	{
//		putchar(tran[j]);
//	}
//	printf("\n");
//	return 0;
//}
// 13 用程序将两个字符串连接起来
//int main()
//{
//	char s1[80], s2[40];
//	int i = 0, j = 0;
//	printf("请输入字符串1：\n");
//	scanf_s("%s", s1);
//	printf("请输入字符串2：\n");
//	scanf_s("%s", s2);
//	while (s1[i] != '\0')
//	{
//		i++;
//	}
//	while (s2[j] != '\0') // 在字符串1的\0处开始，将字符串2替换上去
//	{
//		s1[i++] = s2[j++];
//	}
//	s1[i] = '\0'; // 新字符串1尾部加上字符串终止符
//	printf("新数组为：%s\n", s1);
//	return 0;
//}
// 14 字符串比较
//int main()
//{
//	int i, resu;
//	char s1[100], s2[100];
//	printf("请输入字符串1：\n");
//	gets_s(s1, 100);
//	printf("请输入字符串2：\n");
//	gets_s(s2, 100);
//	i = 0;
//	while ((s1[i] == s2[i]) && (s1[i] != '\0')) // 循环直至字符不一样或字符串结束
//	{
//		i++;
//	}
//	if (s1[i] == '\0' && s2[i] == '\0')  // 字符串相同
//	{
//		resu = 1;
//	}
//	else // 字符串不同
//	{
//		resu = s1[i] - s2[i];
//	}
//	printf("结果为：%d\n", resu);
//	return 0;
//}
// 15 复制字符串
//int main()
//{
//	char s1[80], s2[80];
//	int i;
//	printf("请输入字符串：\n");
//	gets_s(s1, 80);
//	while (s1[i] != '\0')
//	{
//		s2[i] = s1[i];
//		i++;
//	}
//	s2[i] = '\0';
//	printf("%s\n", s2);
//	return 0;
//}
//int main()
//{
//	char s1[80], s2[80];
//	int i;
//	printf("请输入字符串：\n");
//	scanf_s("%s", s2, 80);
//	for (i = 0; i <= strlen(s2); i++)
//	{
//		s1[i] = s2[i];
//	}
//	printf("s1:%s\n", s1);
//	return 0;
//}
// 7.1 函数的意义
//   函数即功能，每个函数用以实现一个特定功能，函数名反映功能内容。
//   简化主函数，模块化设计，用什么功能从库里调什么函数，便于阅读、维护。


// 7.2 定义函数
// 7.2.1 意义：先定义，后调用
//   定义函数应包括：函数名，函数类型（返回值），参数的名字和类型，函数功能。

// 7.2.2 定义函数的方法
//   1 定义无参函数
//     类型名  函数名(void)   //void可省略
//     {
//       ......
//     }
//   2 定义有参函数
//     类型名 函数名(形参列表)
//     {
//        ......
//     }
// 例：
//int max(int x, int y)
//{
//	int z;
//	z = x > y ? x : y;
//	return z;
//}
//   3 定义空函数
//     类型名 函数名()
//     { }
//     什么功能也没有，一般用于扩充程序功能，先空着以后补充用。

// 7.3 调用函数
// 7.3.1 函数调用形式
//   函数名(实参列表);
//   函数调用方式：
//    1 函数调用语句；将函数调用作为单独的语句；
//    2 函数表达式：在另一个语句中调用函数，带着函数返回值进行计算。
//    3 函数参数：将函数调用作为另一个函数的一个参数。

// 7.3.2 函数调用时的数据传递
//   1 形参与实参 
//     调用有参函数时，主函数与被调用函数有数据传递关系。
//     主函数中被调用函数括号内的叫实际参数，定义函数括号内的叫形式参数。
//   2 实参与形参的数据传递
//     函数调用时，将实参的值调给形参，在被调用函数内运算。
//int max(int x, int y)
//{
//	int z;
//	z = x > y ? x : y;
//	return z;
//}
//int main()
//{
//	int max(int x, int y);
//	int a, b;
//	printf("请输入两个值：\n");
//	scanf_s("%d", &a);
//	scanf_s("%d", &b);
//	printf("较大的数为：%d\n", max(a, b));
//	return 0;
//}

// 7.3.3 函数调用过程
//   1 定义函数中指定的形参，在发生调用前不占用内存。
//   2 将实参值赋给形参。
//   3 执行被调用函数体，形参值进行运算。
//   4 return语句返回结果，带回主函数。（也可能无返回值）
//   5 调用结束，形参单元被释放。（清空形参占用的内存）

// 7.3.4 函数返回值
//   通过函数调用，返回一个具体值给主函数，即函数返回值。
//   函数返回值是通过函数中的return语句获得的。
//   函数返回值的类型就是定义函数的类型。


// 7.4 对被调函数的声明和函数原型
//   函数中调用一个函数需要的条件：
//   1 被调用函数必须已经被定义。（库函数或者用户定义的）
//   2 如果使用库函数，必须用#include<.h>声明。 如果用户定义函数与主函数不在同一文件中，则必须用用#include".h"声明（头文件名）。
//   3 如果使用用户定义的函数，若函数在主函数之前，可直接用；若在主函数之后，需要在主函数中声明（函数首部:）被调用函数再用。


// 7.5 函数嵌套调用
// c语言中函数不能嵌套定义（即定义函数中不能再定义函数），但可以嵌套调用函数（即调用函数中可以再调用函数）。
// 流程：主函数-调用函数1-调用函数2-......-调用函数n-返回函数值n-....返回函数值2-返回函数值1-主函数-程序执行完毕。
int max2(int a, int b)
{
	if (a >= b)
	{
		return a;
	}
	else
		return b;
}
int max4(int a, int b, int c, int d)
{
	int m;
	m = max2(a, b);
	m = max2(m, c);
	m = max2(m, d);
	return m;
}
int main()
{
	int a, b, c, d, max;
	printf("请输入四个数据：\n");
	scanf_s("%d%d%d%d", &a, &b, &c, &d);
	max = max4(a, b, c, d);
	printf("最大值为：%d", max);
	return 0;
}


// 7.6 函数的递归调用
//     在调用一个函数的过程中又出现直接或间接调用函数本身。
//     直接调用：函数直接调用自己；间接调用：函数调用别的函数，别的函数有调这个函数。
// 1 求年龄
//int age(int a)
//{
//	int b = a + 2;
//	return b;
//}
//int main()
//{
//	int a1 = 10;
//	int a5 = age(age(age(age(a1))));
//	printf("第五个学生的岁数为：%d\n", a5);
//	return 0;
//}
// 1 改
//int age(int n)
//{
//	int c;
//	if (n == 1)
//		c = 10;
//	else
//		c = age(n - 1) + 2;
//	return c;
//}
//int main()
//{
//	printf("第五名学生年龄为：%d\n", age(5));
//	return 0;
//}
// 2 递归法求n阶乘
//int fac(int n)
//{
//	int f;
//	if (n == 0 || n == 1)
//		f = 1;
//	else if (n < 0)
//		printf("error\n");
//	else
//		f = fac(n - 1) * n;
//	return f;
//}
//int main()
//{
//	int a = 0;
//	printf("请输入n:");
//	scanf_s("%d", &a);
//	printf("结果为:%d\n", fac(a));
//	return 0;
//}
// 3 汉诺塔
//void move(char x, char y)
//{
//	printf("%c->%c\n", x, y);
//}
//void hanoi(int n, char one, char two, char three)
//{
//	if (n == 1)
//	{
//		move(one, three);
//	}
//	else
//	{
//		hanoi(n - 1, one, two, three);
//		move(one, three);
//		hanoi(n - 1, two, one, three);
//	}
//}
//int main()
//{
//	int m;
//	printf("请输入移动盘子数目：");
//	scanf_s("%d", &m);
//	printf("需要的移动盘子的操作为：\n");
//	hanoi(m, 'A', 'B', 'C');
//	return 0;
//}


// 7.7 数组作为函数参数
//     调用有参函数时，需要提供实参。实参可以是常量、变量或者表达式。
//     数组元素作用和变量相当->凡是变量可以出现的地方均可以用数组元素替换。
//     数组名传递的是第一含元素的地址。
// 7.7.1 数组元素作函数参数
//   数组元素可以作函数实参，但不能作函数形参。 传递时，采用值传递方式，即数据从实参到形参，单向传递。
// 输入10个数，输出最大的元素和该数是第几个数
//int max(int x, int y)
//{
//	return (x > y ? x : y);
//}
//int main()
//{
//	int arr[10];
//	int m, n = 0;
//	printf("请输入10个元素：");
//	int i;
//	for (i = 0; i < 10; i++)
//	{
//		scanf_s("%d", &arr[i]);
//	}
//	printf("|n");
//	for (i = 0, m = arr[0]; i < 10; i++)
//	{
//		if (max(m, arr[i]) > m)
//		{
//			m = max(m, arr[i]);
//			n = i;
//		}
//	}
//	printf("最大元素为arr[%d]=%d\n", n, m);
//	return 0;
//}

// 7.7.2 一维数组名作函数参数
// 求十个学生平均成绩
//float Average(float arr[10])
//{
//	int i;
//	float aver, sum = arr[0];
//	for (i = 1; i < 10; i++)
//	{
//		sum = sum + arr[i];
//	}
//  aver = sum / n;
//	return aver;
//}
//int main()
//{
//	float score[10], aver;
//	int i;
//	printf("请输入10个数：");
//	for (i = 0; i < 10; i++)
//	{
//		scanf_s("%f", &score[i]);
//	}
//	aver = Average(score);
//	printf("平均值为：%6.2f\n", aver);
//	return 0;
//}
// 用同一个函数求不同长度数组的平均值
//#define N1 5
//#define N2 10
//float Average(float arr[], int n)
//{
//	int i;
//	float aver, sum = arr[0];
//	for (i = 1; i < n; i++)
//	{
//		sum = sum + arr[i];
//	}
//	aver = sum / n;
//	return aver;
//}
//int main()
//{
//	float arr1[N1] = { 0 }, arr2[N2] = { 0 };
//	int i;
//	printf("请输入数组1的%d个元素：",N1);
//	for (i = 0; i < N1; i++)
//	{
//		scanf_s("%6.2f", &arr1[i]);
//	}
//	printf("\n");
//	printf("请输入数组2的%d个元素：",N2);
//	for (i = 0; i < N2; i++)
//	{
//		scanf_s("%6.2f", &arr2[i]);
//	}
//	printf("\n");
//	printf("数组1平均值为：%6.2f\n", Average(arr1, N1));
//	printf("数组2平均值为：%6.2f\n", Average(arr2, N2));
//	return 0;
//}
// 用选择法对数组中的10个整数按从小到达排序
//#define N 10
//void sort(int arr[], int n)
//{
//	int i, j, k, t;
//	for (i = 0; i < n - 1; i++)
//	{
//		k = i;
//		for (j = i + 1; j < n; j++)
//		{
//			if (arr[j] < arr[k])
//			{
//				k = j;    // 最小的元素为arr[k]
//			}
//		}
//		t = arr[k];
//		arr[k] = arr[i];
//		arr[i] = t;       // 从arr[0]开始一次把最小值放入arr
//	}
//}
//int main()
//{
//	int arr[N] = { 0 }, i;
//	printf("请输入数组的%d个元素：", N);
//	for (i = 0; i < N;i++)
//	{
//		scanf_s("%d", &arr[i]);
//	}
//	printf("\n");
//	sort(arr, N);
//	for (i = 0; i < N; i++)
//	{
//		printf("%d ", arr[i]);
//	}
//	return 0;
//}

// 7.7.3 多维数组名作函数参数
//   合法的多维数组名作函数参数。
//   合法：指定每一维的大小，或省略第一维大小、指明第二维大小。
// 求矩阵元素最大值
//#define N 3
//#define M 4
//int max(int arr[][M-1],int n,int m)
//{
//	int i, j;
//	int max = arr[0][0];
//	for (i = 0; i < n; i++)
//	{
//		for (j = 0; j < m; j++)
//		{
//			if (arr[i][j] > max)
//			{
//				max = arr[i][j];
//			}
//		}
//	}
//	return max;
//
//}
//int main()
//{
//	int arr[N-1][M-1], i, j;
//	printf("请输入%d X %d 数组的元素：", N, M);
//	for (i = 0; i < N-1; i++)
//	{
//		for (j = 0; j < M-1; j++)
//		{
//			scanf_s("%d", &arr[i][j]);
//		}
//	}
//	printf("\n");
//	printf("最大值为：%d\n", max(arr, N-1, M-1));
//	return 0;
//}

// 7.8 局部变量和全局变量
// 7.8.1 局部变量
//   变量在函数内部定义，称局部变量。（函数的开头定义或者函数内复合语句内定义）
//   作用范围：所处程序块内。

// 7.8.2 全局变量
//   定义在函数外部的变量，称为·全局变量。
//   作用范围：整个文件。
//   注意：如果一个函数改变了全局变量的值，则其他使用这个全局变量的函数的结果会发生改变。
//#define N 10
//float Max = 0, Min = 0;
//float average(float arr[], int n)
//{
//	int i;
//	float sum = arr[0];
//	Max = Min = arr[0];
//	for (i = 1; i < n; i++)
//	{
//		if (arr[i] > Max)
//			Max = arr[i];
//		else if (arr[i] < Min)
//			Min = arr[i];
//		sum = sum + arr[i];
//	}
//	return (sum / n);
//}
//int main()
//{
//	float score[N];
//	int i;
//	printf("请输入%d个元素：", N);
//	for (i = 0; i < N; i++)
//	{
//		scanf_s("%f", &score[i]);
//	}
//	printf("max=%6.2f\nmin=%6.2f\naverage=%6.2f\n", Max, Min, average(score, N));
//	return 0;
//}
// 非必要不使用全局变量：
//   全局变量在全部执行过程中都占内存空间。
//   降低函数通用性，若全部变量和局部变量重名会使局部变量作用范围内全局变量失效。
//   降低出现清晰性，难以判断每一步各各外部变量的值。


// 7.9 变量的存储方式和生存期（生命周期）
// 7.9.1 动态存储方式和静态存储方式
//   按作用空间可分为：全局变量，局部变量。
//   按作用时间可分为：静态存储，动态存储。
//    存储空间：程序区，静态存储区，动态存储区。
//      静态存储区存全局变量，程序开始就在静态区开辟空间，执行时全局变量占固定的存储单元。
//      动态存储区存函数形参、非static变量和函数调用时的现场保护和地址返回，根据需要动态的开辟、释放。
//    c语言中，每个变量和函数都有两个属性：数据类型、数据存储类别（自动auto、静态static、寄存器register、外部extern）。

// 7.9.2 局部变量存储类别
// 1 自动变量：不专门申明为static的，都会自动动态分配存储空间，称这类局部变量为自动变量。
//   auto可以省略。
// 2 静态局部变量：用static声明变量，其占用存储单元在使用结束后不释放，下次调用继续使用这个值。
//  累加
//int f(int a)
//{
//	int b = 0;
//	static int c = 3; // 变量c的值是存在静态区的
//	b = b + 1;
//	c = c + 1;
//	return (a + b + c);
//}
//int main()
//{
//	int a = 2, i;
//	for (i = 0; i < 3; i++)
//	{
//		printf("%d\n", f(a));
//	}
//	return 0;
//}
//  求阶乘
//int fac(int n)
//{
//	static int f = 1;
//	f = f * n;
//	return f;
//}
//int main()
//{
//	int i;
//	for (i = 1 ; i <= 5; i++)
//	{
//		printf("%d!=%d\n", i, fac(i));
//	}
//	return 0;
//}
// 3 寄存器变量（register）
//   将变量存在cpu寄存器中。
//   优点：某些变量在运算过程中重复大量出现，将其存在寄存器中可以有效减少反复存取的时间，提高运算效率。

// 7.9.3 全局变量存储类别
//   全局变量全部存在静态区。但其作用域需要额外指定。
// 1 在一个文件内扩展为外部变量的作用域
//   如果外部变量不定义在文件开头，则其作用域是从定义处到文件结尾，即定义处之前的函数不能引用该变量。
//   可用extern对变量声明，表示将该变量作用域扩展到此位置。
// 求最大值
//int main()
//{
//	int max();
//	extern int A, B, C;
//	printf("请输入3个数：");
//	scanf_s("%d%d%d", &A, &B, &C);
//	printf("最大值为：%d", max());
//	return 0;
//}
//int A, B, C;
//int Max()
//{
//	int m;
//	m = A > B ? A : B;
//	if (C > m)
//		m = C;
//	return m;
//}
// 2 将外部变量的作用域扩展到其他文件
//   一个文件中想引用另一个文件的外部变量。
//   注意不能每个文件中都定义一个相同的变量，否则程序连接时会出现重复定义，所以需要外部变量声明。
//int A;
//int main()
//{
//	int power(int);
//	int b = 3, c, d, m;
//	printf("请输入一个值，求其m次方：\n");
//	scanf_s("%d%d", &A, &m);
//	c = A * b;
//	printf("%d * %d=%d\n", A, b, c);
//	d = power(m);
//	printf("%d * * %d=%d\n", A, m, d);
//	return 0;
//}
// 3 将外部变量的作用域限制在本文件中
//   希望某些外部变量只限于被本文件引用，可以在定义时加一个static声明。


// 7.10 变量的定义与声明
//   声明：定义性声明（定义），引用性声明。
//   将创建存储空间的声明称为定义，其余称为声明。


// 7.11 内部函数与外部函数
//   函数本质是全局的，类似全局变量。 根据函数是否能被其他源文件调用，将函数分为内部函数和外部函数。
// 7.11.1 内部函数（静态函数）
//   在函数类型名前加static。 

// 7.11.2 外部函数
//   在函数首部最左端加extern。


// test
// 1 求两个函数的最大公约数和最小公倍数
//int hcf(int x, int y)  //辗转相除法
//{
//	int r, t;
//	if (x > y)
//	{
//		t = x;
//		x = y;
//		y = t;
//	}
//	while ((r = y % x) != 0)
//	{
//		y = x;
//		x = r;
//	}
//	return x;
//}
//int lcd(int x, int y,int h)
//{
//	return (x * y / h);
//}
//int main()
//{
//	int a, b;
//	printf("请输入两个整数：");
//	scanf_s("%d,%d", &a, &b);
//	int h = hcf(a, b);
//	printf("最大公约数为：%d\n", hcf(a, b));
//	printf("最小公倍数为：%d\n", lcd(a, b, h));
//	return 0;
//}
// 2 求一元二次方程的根
float x1, x2, disc, p, q;
void Gzero(float a, float b)
{
	x1 = (-b + sqrt(disc)) / (2 * a);
	x2 = (-b - sqrt(disc)) / (2 * a);
}
void Ezero(float a, float b)
{
	x1 = x2 = (-b) / (2 * a);
}
void Szero(float a, float b)
{
	p = -b / (2 * a);
	q = sqrt(-disc) / (2 * a);
}

int main()
{
	float a, b, c;
	printf("请输入三个数：");
	scanf_s("%f,%f,%f", &a, &b, &c);
	disc = b * b - 4 * a * c;
	if (disc > 0)
	{
		Gzero(a, b);
		printf("x1=%f  x2=%f\n", x1, x2);
	}
	else if (disc == 0)
	{
		Ezero(a, b);
		printf("x1=x2=%f\n", x1);
	}
	else
	{
		Szero(a, b);
		printf("x1=%f+%fi  x2=%f-%f\n", p, q, p, q);
	}
	return 0;
}

// 3 判断素数
//int Prime(int n)
//{
//	int i;
//	for (i = 2; i <= sqrt(n); i++)
//	{
//		if ((n % i) == 0)
//		{
//			printf("%d不是素数\n", n);
//			return 0;
//		}
//	}
//	printf("%d是素数\n", n);
//	return 1;
//}
//
//int main()
//{
//	int a, b;
//	printf("请输入一个数：");
//	scanf_s("%d", &a);
//	b = Prime(a);
//	return 0;
//}

// 4 二维数组行列互换
#define N 3
void Convert(int arr[][N])
{
	int i, j, t;
	for (i = 0; i < N; i++)
	{
		for (j = i + 1; j < N; j++)
		{
			t = arr[i][j];
			arr[i][j] = arr[j][i];
			arr[j][i] = t;
		}
	}
}
int main()
{
	int arr[N][N];
	int i, j;
	printf("请输入%d x %d二维数组的元素：",N,N);
	for (i = 0; i < N; i++)
	{
		for (j = 0; j < N; j++)
		{
			scanf_s("%d", &arr[i][j]);
		}
	}
	printf("\n");
	for (i = 0; i < N; i++)
	{
		for (j = 0; j < N; j++)
		{
			printf("%5d", arr[i][j]);
		}
		printf("\n");
	}
	printf("\n");
	Convert(arr);
	for (i = 0; i < N; i++)
	{
		for (j = 0; j < N; j++)
		{
			printf("%5d", arr[i][j]);
		}
		printf("\n");
	}
	printf("\n");
	return 0;
}

#define N 5
void Inverse_char(char arr[],int size)
{
	int i;
	char t;
	for (i = 0; i < (size/2); i++)
	{
		t = arr[i];
		arr[i] = arr[size-i-1];
		arr[size-i-1] = t;
	}
}
int main()
{
	char arr[N];
	int j;
	printf("请输入字符串：");
	scanf_s("%s", &arr, N);
	printf("\n字符串为：%s\n", arr);
	j = strlen(arr);
	Inverse_char(arr,j);
	printf("反序后：%s\n", arr);
	return 0;
}

// 6 字符串连接
//#define N 30
//#define M 30
//void Link_char(char arr1[],char arr2[],char arr[])
//{
//	int i;
//	for (i = 0; i < N; i++)
//	{
//		if (arr1[i] != '\0')
//		{
//			arr[i] = arr1[i];
//		}
//		else
//			break;
//	}
//	for (; i < N + M; i++)
//	{
//		arr[i] = arr2[i-strlen(arr1)];
//	}
//}
//int main()
//{
//	char arr1[N], arr2[M],arr[N+M];
//	printf("请输入字符串1：");
//	scanf_s("%s", arr1, N);
//	printf("请输入字符串2：");
//	scanf_s("%s", arr2, M);
//	Link_char(arr1, arr2, arr);
//	printf("结果为：%s\n", arr);
//	return 0;
//}

// 7 识别字符串中的元音字母，并复制到另一字符串输出
//#define N 80
//#define M 80
//void cpy(char s[], char c[])
//{
//	int i, j = 0;
//	for (i = 0; s[i]!='\0'; i++)
//	{
//		if ((s[i] == 'a') || (s[i] == 'e') || (s[i] == 'i') || (s[i] == 'u') || (s[i] == 'A') || (s[i] == 'E') || (s[i] == 'I') || (s[i] == 'U'))
//		{
//			c[j] = s[i];
//			j++;
//		}
//	}
//	c[j] = '\0';
//}
//int main()
//{
//	char s[N], c[M];
//	printf("请输入字符串：");
//	scanf_s("%s", s, N);
//	cpy(s, c);
//	printf("\n%s\n", c);
//	return 0;
//}

// 8 输入4位数字，输出数字之间带空格
//#define N 80
//void Insert(char arr[])
//{
//	int i = strlen(arr);
//	while (i)
//	{
//		arr[2*i] = arr[i];
//		arr[2 * i - 1] = ' ';
//		i--;
//	}
//}
//int main()
//{
//	char arr[N], i;
//	printf("请输入4个数字：");
//	scanf_s("%s", &arr, N);
//	Insert(arr);
//	printf("\n%s\n", arr);
//	return 0;
//}

// 9 统计字符串中字母、数字、空格和其他字符的个数。
//#define N 250
//int c, d, s, o;
//void Count(char arr[])
//{
//	int i;
//	for (i = 0; i < N; i++)
//	{
//		if (((arr[i] >= 'a') && (arr[i] <= 'z')) || ((arr[i] >= 'A') && (arr[i] <= 'Z')))
//			c++;
//		else if ((arr[i] >= '0') && (arr[i] <= '9'))
//			d++;
//		else if (arr[i] == ' ')
//			s++;
//		else
//			o++;
//	}
//}
//int main()
//{
//	char arr[N];
//	printf("请输入字符串：");
//	scanf_s("%s", &arr, N);
//	Count(arr);
//	printf("字母有%d个\n数字有%d个\n空格有%d个\n其他字符有%d个\n", c , d , s , o );
//	return 0;
//}

// 10 找最长单词
//#define N 255
//int Alphabetic(char c)
//{
//	if (((c >= 'a') && (c <= 'z')) || ((c >= 'A') && (c <= 'Z')))
//		return 1;
//	else
//		return 0;
//}
//int Longest(char arr[])
//{
//	int len = 0, length = 0, flag = 1, place = 0, i, point = 0;
//	for (i = 0; i <= strlen(arr); i++)
//	{
//		if (Alphabetic(arr[i]))
//		{
//			if (flag)
//			{
//				point = i;  //当前单词开始的位置
//				flag = 0;
//			}
//			else
//				len++;      // 单词长度
//		}
//		else
//		{
//			flag = 1;
//			if (len >= length)
//			{
//				length = len;   // 最长单词的长度
//				place = point;  // 最长单词的位置
//				len = 0;
//			}
//		}
//	}
//	return place;
//}
//
//int main()
//{
//	char arr[N];
//	printf("请输入一个字符串：");
//	gets_s(arr, N);
//	printf("\n最长单词是：");
//	int i;
//	for (i = Longest(arr); Alphabetic(arr[i]); i++)
//		printf("%c", arr[i]);
//	printf("\n");
//	return 0;
//}

// 11 
#define N 10
char arr[N];
void Qsort(char arr[])
{
	int i, j;
	char t;
	for (j = 1; j < N; j++)
	{
		for (i = 0; (i < N - j) && (arr[i]!='\0'); i++)
		{
			if (arr[i] > arr[i + 1])
			{
				t = arr[i];
				arr[i] = arr[i + 1];
				arr[i + 1] = t;
			}
		}
	}
}
int main()
{
	int i, flag;
	for (flag = 1; flag == 1;)
	{
		printf("请输入一个%d字符的字符串：", N);
		scanf_s("%s", arr, N);
		if (strlen(arr) > N)
			printf("字符串太长，请重新输入！\n");
		else
			flag = 0;
	}
	Qsort(arr);
	printf("排序后字符串为：");
	for (i = 0; i < N; i++)
	{
		printf("%c", arr[i]);
	}
	printf("\n");
	return 0;
} 

// 14 计算成绩
//#define S 10
//#define C 5
//float arr[S][C];
//int k, s;
//void Input(float arr[S][C])
//{
//	int i, j;
//	for (i = 0; i < S; i++)
//	{
//		printf("请输入第%d个学生%d门科目的成绩：", (i + 1), C);
//		for (j = 0; j < C; j++)
//		{
//			scanf_s("%f", &arr[i][j]);
//		}
//		printf("\n");
//	}
//}
//float S_average(float arr[S][C],int a)
//{
//	float sa = 0;
//	int j;
//	for (j = 0; j < C; j++)
//	{
//		sa = sa + arr[a][j];
//	}
//	return (sa / C);
//}
//float C_average(float arr[S][C],int a)
//{
//	float ca = 0;
//	int i;
//	for (i = 0; i < S; i++)
//	{
//		ca = ca + arr[i][a];
//	}
//	return (ca/S);
//}
//float Max(float arr[S][C])
//{
//	float max = arr[0][0];
//	int i, j;
//	for (i = 0; i < S; i++)
//	{
//		for (j = 0; j < C; j++)
//		{
//			if (arr[i][j] > max)
//			{
//				max = arr[i][j];
//				s = i + 1;
//				k = j + 1;
//			}
//		}
//	}
//	return max;
//}
//float S_var(float arr[S][C])
//{
//	int i,j;
//	float all = 0.0, plus = 0.0;
//	for (i = 0; i < S; i++)
//	{
//		all +=  S_average(arr,i);
//		plus += S_average(arr, i) * S_average(arr, i);
//	}
//	return 	 (plus / S - (all / S) * (all / S));
//}
//void Output(void)
//{
//	int i, j;
//	printf("\n  NO.     cour1   cour2   cour3   cour4   cour5   aver\n");
//	// 每个学生的平均分
//	for (i = 0; i < S; i++)
//	{
//		printf("\n NO %2d ", (i + 1));
//		for (j = 0; j < C; j++)
//		{
//			printf("%8.2f", arr[i][j]);
//		}
//		printf("%8.2f", S_average(arr, i));
//	}
//	// 每门课的平均分
//	printf("\naverage:");
//	for (i = 0; i < C; i++)
//	{
//		printf("%8.2f", C_average(arr, i));
//	}
//	printf("\n");
//	// 单最高分及其对应课程
//	printf("最高分为%f,属于学生%d,科目%d\n", Max(arr), s, k);
//	// 平均分方差
//	printf("平均分方差为：%8.2f\n", S_var(arr));
//}
//
//int main()
//{
//	Input(arr);
//	Output();
//	return 0;
//}

// 15 工人信息
#define N 3
int num[N];
char name[N][8];
void Input(int num[], char name[][8])
{
	int i;
	for (i = 0; i < N; i++)
	{
		printf("请输入工号：");
		scanf_s("%d", &num[i]);
		printf("请输入姓名：");
		scanf_s("%s", &name[i], 8);
	}
	printf("\n");
}
void Sort_By_Num(int num[], char name[][8])
{
	int i, j, t, min;
	char tmp[8];
	for (i = 0; i < N - 1; i++)
	{
		min = i;
		for (j = i; j < N; j++)
		{
			if (num[min] > num[j + 1])
			{
				min = j;
			}
		}
		t = num[i];
		strcpy_s(tmp, 8, name[i]);
		num[i] = num[min];
		strcpy_s(name[i], 8, name[i + 1]);
		num[min] = t;
		strcpy_s(name[min], 8, tmp);
	}
	printf("结果为:\n");
	for (i = 0; i < N; i++)
	{
		printf("\n %5d%10s", num[i], name[i]);
	}
}
int Search(int num[], char name[][8])
{
	int n, top = 0, end = N - 1, mid, flag = 0;
	printf("请输入要查找的工号：");
	scanf_s("%d", &n);
	int i;
	for (i = top; i <= end; i++)
	{
		mid = (top + end) / 2;
		if (n > num[mid])
		{
			top = mid + 1;
		}
		else if (n < num[mid])
		{
			end = mid - 1;
		}
		else
		{
			printf("\nNO.%d name is %s\n", num[mid], name[mid]);
			return 0;
		}
	}
	return 1;	
}
int main()
{
	Input(num, name);
	Sort_By_Num(num, name);
	int s = Search(num, name);
	while(s==1)
	{
		printf("未找到，请重新输入！\n");
		s = Search(num, name);
	}
	return 0;
}
// 16 输入十六进制数，输出十进制数
#define MAX 1000
int htoi(char arr[])
{
	int i, n = 0;
	for (i = 0; arr[i] != '\0'; i++)
	{
		if (arr[i] >= '0' && arr[i] <= '9')
			n = n * 16 + arr[i] - '0';
		if (arr[i] = 'a' && arr[i] <= 'f')
			n = n * 16 + arr[i] - 'a' + 10;
		if (arr[i] = 'A' && arr[i] <= 'F')
			n = n * 16 + arr[i] - 'A' + 10;
	}
	return n;
}
int main()
{
	char arr[MAX];
	int flag, flag1, c, i = 0;
	printf("请输入一个十六进制数：");
	while ((c = getchar()) != '\0' && i < MAX && flag1)
	{
		if ((c >= '0' && c <= '9') || (c >= 'a' && c <= 'f') || (c >= 'A' && c <= 'F'))
		{
			flag = 1;
			arr[i++] = c;
		}
		else if (flag)
		{
			arr[i] = '\0';
			printf("转换后十进制数为：%d\n", htoi(arr));
			printf("是否继续换算？ Y/N");
			c = getchar();
			if (c == 'N' || c == 'n')
				flag1 = 0;
			else
			{
				flag = 0;
				i = 0;
				printf("请输入一个十六进制数：");
			}
		}
	}
	return 0;
}

// 17 递归法整数转换为字符串输出
//void Convert(int n)
//{
//	if (n < 0)
//	{
//		n = -n;
//	}
//	int i;
//	if ((i = n / 10) != 0)
//	{
//		Convert(i);
//	}
//	putchar(n % 10 + '0');
//	putchar(32);
//}
//int main()
//{
//	int n;
//	printf("请输入一个整数：");
//	scanf_s("%d", &n);
//	Convert(n);
//	printf("\n");
//	return 0;
//}

// 18 给出年月日，求该日是该年的第几天
//int If_lunar(int n)
//{
//	int flag = 0; // 非闰年
//	if (((n % 4 == 0) && (n % 100 != 0)) || (n % 400 == 0))
//		flag = 1; // 闰年
//	return flag;
//}
//int Sum_day(int m, int n)
//{
//	int d = 0, i;
//	int day_tab[13] = { 0,31,28,31,30,31,30,31,31,30,31,30,31 };
//	for (i = 0; i < m; i++)
//	{
//		d = d + day_tab[i];
//	}
//	return (d + n);
//}
//int main()
//{
//	int year, month, day, days;
//	printf("请输入日期:");
//	scanf_s("%d.%d.%d", &year, &month, &day);
//	days = Sum_day(month, day);
//	if (If_lunar(year) == 1)
//		days = days + 1;
//	printf("%d.%d.%d 是该年的第%d天。\n", year, month, day, days);
//	return 0;
//}



// 8 指针
// 8.1 什么是指针
//   地址指向变量所在的内存单元。（定义变量就是开房，初始化就是住人，地址就是房号）
//   地址形象化称为指针，即通过指针指向的地址找到变量。
//   指针是有类型的，为了从单元中取出你想要的数据大小。
//   变量访问方式：直接访问，间接访问（通过另一个变量来存放地址）
//   指针：地址    指针变量：存放另一个变量地址的变量。

// 8.2 指针变量
// 8.2.1 举例
//   通过指针变量访问整型变量
//int main()
//{
//	int a = 100, b = 10;
//	int* p1, * p2;
//	p1 = &a;
//	p2 = &b;
//	printf("a=%d,b=%d\n", a, b);
//	printf("*p1=%d,*p2=%d\n", *p1, *p2);
//	return 0;
//}

// 8.2.2 怎样定义指针变量
//   类型名* 指针变量名;
//   定义的同时，可以对其初始化。
//    1  *表示是指针型变量；定义时必须指明基类型。
//    2  指针变量的含义：1，用存储单元编号表示的纯地址 2，指向存储单元的数据类型。
//    3  不能直接将整型数赋给指针变量，要加地址符&

// 8.2.3 引用指针变量
//   1 给指针变量赋值  如 p=&a; 将a的地址放到p里
//   2 引用指针变量指向的变量  如 *p=1;  将1赋给指针p所指向的变量
//   3 引用指针变量的值（地址）
//int main()
//{
//	int* p1, * p2, * p, a, b;
//	printf("请输入两个整数：");
//	scanf_s("%d,%d", &a, &b);
//	p1 = &a;
//	p2 = &b;
//	if (a < b)
//	{
//		p = p1;
//		p1 = p2;
//		p2 = p;
//	}
//	printf("a=%d,b=%d\n", a, b);
//	printf("max=%d,min=%d", *p1, *p2);
//	return 0;
//}

// 8.2.4 指针变量作函数参数
//   函数参数还可以是指针，作用是将一个变量的地址传送到另一个函数中
//void Swap(int* p1, int* p2)
//{
//	int t;
//	t = *p1;
//	*p1 = *p2;
//	*p2 = t;
//}
//int main()
//{
//	int a, b;
//	printf("请输入两个整数：");
//	scanf_s("%d,%d", &a, &b);
//	int* p1 = &a;
//	int* p2 = &b;
//	if (a < b)
//		Swap(p1, p2);
//	printf("\nmax=%d,min=%d\n", a, b);
//	return 0;
//}

// 8.3 通过指针引用数组
// 8.3.1 数组元素的指针
//   数组元素的指针就是数组元素的地址
//   引用数组元素可以采用下标法，或者指针法（占内存少、运行速度快）。
//   int* p = a;    等价于   int* p;   p = &a[0];  将a数组首元素地址赋给指针变量p。

// 8.3.2 在引用数组元素时指针的运算
//   在指针已指向一个数组元素时，可以对指针进行以下运算:
//     1 加整数
//     2 减整数
//     3 自加运算
//     4 自减运算
//     5 两个指针相减（两个指针都指向同一数组中的元素）

// 8.3.3 通过指针引用数组元素
//   下标法  a[i]
//    指针法 *(p+i)
// 例
//int main()
//{
//	int a[10];
//	int i;
//	printf("请输入10个元素：");
//	for (i = 0; i < 10; i++)
//	{
//		scanf_s("%d", &a[i]);
//	}
//	for (i = 0; i < 10; i++)
//	{
//		printf("%d ", a[i]);
//	}
//	printf("\n");
//	return 0;
//}
//int main()
//{
//	int a[10];
//	int i;
//	printf("请输入10个元素：");
//	for (i = 0; i < 10; i++)
//	{
//		scanf_s("%d", (a + i));
//	}
//	for (i = 0; i < 10; i++)
//	{
//		printf("%d ", *(a + i));
//	}
//	printf("\n");
//	return 0;
//}
//int main()
//{
//	int a[10];
//	int* p, i;
//	printf("请输入10个元素：");
//	for (i = 0; i < 10; i++)
//		scanf_s("%d", (a + i));
//	for (p = a; p < (a + 10); p++)
//	{
//		printf("%d ", *p);
//	}
//	printf("\n");
//	return 0;
//}

//int main()
//{
//	int* p, arr[10], i;
//	p = arr;
//	printf("请输入10个元素：");
//	for (i = 0; i < 10; i++)
//		scanf_s("%d", p++);
//	p = arr;                 // 如果没有这句，p此时指向arr[0]+10的位置，下面打印函数将会出错。
//	for (i = 0; i < 10; i++)
//		printf("%d ", *p++);
//	return 0;
//}

// 8.3.4 用数组名作函数参数
///  本质是把数组首元素的地址传给函数。
// 将数组a的n个整数按相反顺序存放
//#define N 10
//void Inv(int x[], int n)
//{
//	int t, * i, * j;
//	i = x;
//	j = x + n - 1;
//	for (; i < j; i++, j--)
//	{
//		t = *i;
//		*i = *j;
//		*j = t;
//	}
//}
//int main()
//{
//	int arr[N];
//	printf("请输入%d个元素：", N);
//	int i, * p = arr;
//	for (i = 0; i < N; i++)
//		scanf_s("%d", p++);
//	Inv(arr, N);
//	p = arr;
//	for (i = 0; i < N; i++)
//		printf("%d ", *p++);
//	return 0;
//}

// 8.3.5 通过指针引用多维数组
//   1 多维数组元素的地址
//     a[0]表示数组首元素地址，a[i]+j表示二维数组第i行第j-1个元素的地址。
//     区别：a+1表示行加一的数组的地址，a[0]+1表示第0行第一个元素的地址。
//int main()
//{
//	int a[3][4] = { 1,3,5,7,9,11,13,15,17,19,21,23 };
//	printf("%d,%d\n",a,*a );
//	printf("%d,%d\n",a[0],*(a+0));
//	printf("%d,%d\n",&a[0],&a[0][0]);
//	printf("%d,%d\n",a[1],a+1);
//	printf("%d,%d\n",&a[1][0],*(a+1)+0);
//	printf("%d,%d\n",a[2],*(a+2));
//	printf("%d,%d\n",&a[2],a+2);
//	printf("%d,%d\n",a[1][0],*(*(a+1)+0));
//	printf("%d,%d\n",*a[2],*(*(a+2)+0));
//	return 0;
//}
//   2 指向多维数组元素的指针变量
//   （1）指向数组元素的指针变量
//int main()
//{
//	int a[3][4] = { 1,3,5,7,9,11,13,15,17,19,21,23 };
//	int* p;
//	for (p = a[0]; p < a[0] + 12; p++)
//	{
//		if ((p - a[0]) % 4 == 0)
//			printf("\n");
//		printf("%4d", *p);
//	}
//	printf("\n");
//	return 0;
//}
// 可用i*m(二维数组列数）+j 来确定 i行j列元素的相对位置。
//   （2）指向由m个元素组成的一维数组的指针变量
//int main()
//{
//	int a[4] = { 1,3,5,7 };
//	int(*p)[4];
//	p = &a;
//	printf("%d\n", (*p)[3]);
//	return 0;
//}
//   3 用指向数组的指针作函数参数
//   两种方法：用指向变量的指针作函数参数，用指向一维数组的指针变量。
//void Average(float* p, int n)
//{
//	float* p_end = p + n - 1;
//	float sum = 0, aver;
//	for (; p <= p_end; p++)
//	{
//		sum = sum + *p;
//	}
//	aver = sum / n;
//	printf("总平均分为：%5.2f\n",aver );
//}
//
//void Search(float (*p)[4], int n)
//{
//	int i;
//	printf("第%d名同学的成绩是：", n);
//	for (i = 0; i < 4; i++)
//	{
//		printf("%5.2f ", *(*(p + n - 1) + i));
//	}
//	printf("\n");
//}
//
//void Search_fail(float(*p)[4], int n)
//{
//	int i, j;
//	for (j = 0; j < n; j++)
//	{
//		int flag = 0;
//		for (i = 0; i < 4; i++)
//		{
//			if (*(*(p + j) + i) < 60)
//			{
//				flag = 1;
//			}
//		}
//		if (flag)
//		{
//			printf("第%d名学生有挂科，他的成绩是：", j + 1);
//			for (i = 0; i < 4; i++)
//			{
//				printf("%5.2f ", *(*(p + j) + i));
//			}
//		}
//	}
//	printf("\n");
//}
//int main()
//{
//	float score[3][4] = { {65,67,70,50},{80,87,90,81},{90,99,100,98} };
//	Average(*score, 12);
//	Search(score, 2);
//	Search_fail(score, 3);
//	return 0;
//}

// 8.4 通过指针引用字符串
// 8.4.1 字符串引用方式
//   1 用字符数组存放一个字符串，再用指针调用数组以达到引用字符串的目的。（可通过数组名和下标单独调用一个字符）
// 例：
//int main()
//{
//	char arr[ ] = "I love china.";
//	char* p = arr;
//	printf("%s\n", p);
//	printf("%c\n", p[7]);
//	return 0;
//}
//int main()
//{
//	char arr1[] = "I feel little bit down.", arr2[30];
//	char * p1, * p2;
//	p1 = arr1;
//	p2 = arr2;
//	for (; *p1 != '\0'; p1++, p2++)
//	{
//		*p2 = *p1;
//	}
//	*p2 = '\0';
//	p2 = arr2;
//	printf("%s\n", p2);
//	return 0;
//}

// 8.4.2 字符指针作函数参数
// 用函数调用实现字符串复制
//void String_cpy(char* a, char* b) // 从a复制到b去
//{
//	for (; *a != '\0'; a++, b++)
//		*b = *a;
//  // 也可写成 while(*b++=*a++);
//	*b = '\0';
//}
//int main()
//{
//	char arr1[] = "I hope to see sunshine tomorrow.", arr2[40];
//	//int a = strlen(arr1);
//	/*printf("%d\n", a);*/
//	char* p1, * p2;
//	p1 = arr1;
//	p2 = arr2;
//	String_cpy(p1, p2);
//	printf("%s\n", arr2);
//	return 0;
//}

// 8.4.3 使用字符指针变量和字符数组的比较
//   1 字符数组由若干个元素组成，每个元素放一个字符；字符指针变量中放字符串首字母地址。
//   2 赋值方式不同。不能对数组名赋值；可以对字符指针变量赋值。
//   3 初始化含义不同。数组可以在定义时对各元素赋初值，但不能用赋值语句对数组中全部元素整体赋值。
//   4 存储单元内容。字符数组有若干存储单元；字符指针变量只有一个用来存放地址。
//   5 字符数组名代表一个固定的值，不能改变；指针变量的值可以改变。
//   6 字符数组中各元素值可以被改变；字符指针指向的字符串常量中的内容不能被改变。
//   7 引用数组元素。字符数组可以采用下标法，也可以地址法；对于字符指针变量，可以变量带下标（p[i]），也可以用地址（ *(p+5) ）。
//   8 用指针变量指向一个格式字符串，可以用它代替printf函数中的格式字符串。


// 8.5 指向函数的指针
// 8.5.1 什么是函数的指针
//   函数名代表函数的起始地址，即函数的指针。
//   可以定义一个指针变量指向函数开始地址。 如：int(*p)(int,int);

// 8.5.2 用函数指针变量调用函数
//int Max(int x, int y)
//{
//	return (x > y ? x : y);
//}
//int main()
//{
//	int(*p)(int, int);
//	int a, b, c;
//	p = Max;
//	printf("请输入两个数：");
//	scanf_s("%d,%d", &a, &b);
//	c = (*p)(a, b);
//	printf("a=%d\nb=%d\nmax=%d\n", a, b, c);
//	return 0;
//}

// 8.5.3 怎样定义和使用指向函数的指针变量
// 类型名(*指针变量名)(函数参数列表);
// 如果要使用指针调用函数，必须先使指针变量指向该函数。 如：p=Max;
// 注意 指向函数的指针变量不能进行算术运算。
// 函数名调用函数，一个函数名只能调用一个函数；指针变量调用函数，则可以灵活调用多个函数。
//int Max(int x, int y)
//{
//	return (x > y ? x : y);
//}
//int Min(int x, int y)
//{
//	return (x < y ? x : y);
//}
//int main()
//{
//	int(*p)(int, int);
//	int a, b, c, n;
//	printf("请输入两个数：");
//	scanf_s("%d,%d", &a, &b);
//	printf("请选择求较大值还是较小值？1/2");
//	scanf_s("%d", &n);
//	if (n == 1)
//		p = Max;
//	else
//		p = Min;
//	c = (*p)(a, b);
//	printf("a=%d\nb=%d\n", a, b);
//	if (n == 1)
//		printf("max=%d\n", c);
//	else
//		printf("min=%d\n", c);
//	return 0;
//}

// 8.5.4 用指向函数的指针作函数参数
//   把函数的入口地址作为函数参数传递到其他函数。
//int Max(int x, int y)
//{
//	return (x > y ? x : y);
//}
//int Min(int x, int y)
//{
//	return (x < y ? x : y);
//}
//int Add(int x, int y)
//{
//	return (x + y);
//}
//void Fun(int x, int y, int(*p)(int, int))
//{
//	printf("%d\n", (*p)(x, y));
//}
//int main()
//{
//	int(*p)(int, int);
//	int a, b, n = 0;
//	printf("请输入两个数：");
//	scanf_s("%d,%d", &a, &b);
//	while (n == 0)
//	{
//		printf("请选择功能：\n");
//		printf("1 求较大值  2 求较小值  3 求和  :");
//		scanf_s("%d", &n);
//		switch (n)
//		{
//		case 1:
//			p = Max;
//			printf("较大值为：");
//			break;
//		case 2:
//			p = Min;
//			printf("较小值为：");
//			break;
//		case 3:
//			p = Add;
//			printf("两数之和为：");
//			break;
//		default:
//			printf("输入错误，请重新输入！\n");
//			n = 0;
//			break;
//		}
//		printf("\n");
//	}
//	Fun(a, b, p);
//	return 0;
//}
#define A 3
//#define B 3
//float* Score(int n,float a[A][B])
//{
//	float* p;
//	p = a[n];
//	return p;
//}
//float* Search_fail(float (* a)[B])
//{
//	int i;
//	float* p;
//	p = NULL;
//	for (i = 0; i < B; i++)
//	{
//		if (*( * a + i) < 60)
//			p = *a;
//	}
//	return p;
//}
//int main()
//{
//	float a[A][B];
//	printf("请录入%d名学生的%d门科目的成绩：", A, B);
//	float* p;
//	for (p = a[0]; p < a[0] + A * B; p++)
//	{
//		scanf_s("%f", p);
//	}
//	//int i = 0;
//	//for (p = a[0]; p < a[0] + A * B; p++)
//	//{
//	//	printf("%5.2f ", *p);
//	//	i++;
//	//	if (i % B == 0)
//	//		printf("\n");
//	//}
//	//int n = 0;
//	//printf("请输入想查找成绩的学生序号：");
//	//scanf_s("%d", &n);
//	//p = Score(n,a);
//	//printf("序号%d的成绩为：", n);
//	//for (; p[0] < p[0] + B; p++)
//	//	printf("%5.2f ", *p);
//	//printf("\n");
//	int j;
//	for (j = 0; j < A; j++)
//	{
//		p = Search_fail(a + j);
//		if (p != NULL)
//		{
//			int i;
//			printf("有挂科的学生成绩为：");
//			for (i = 0; i < B; i++)
//				printf("%5.2f ", *(p + i));
//			printf("\n");
//		}
//	}
//	return 0;
//}

// 8.7 指针数组和多重指针
// 8.7.1 什么是指针数组
//   一个数组，其元素全是指针类型数组，称为指针数组。
//   相当于数组的每个元素都是一个指针变量。
//   一般形式为： 类型名 * 数组名[数组长度];
//   指针数组适合用于指向若干字符串，方便处理字符串们。
//     原因：字符串本身就是一个字符数组，要设计一个二维数组才能存放多个字符串，但是字符串长短不一，会浪费空间。
// 例：将若干字符串按首字母顺序排序。
//void Sort(const char* name[],int n)
//{
//	int i, j, k;
//	const char* t;
//	for (i = 0; i < n - 1; i++)
//	{
//		k = i;
//		for (j = i + 1; j < n; j++)
//		{
//			if (strcmp(name[k], name[j]) > 0)
//				k = j;
//		}
//		if (k != j)
//		{
//			t = name[i];
//			name[i] = name[k];
//			name[k] = t;
//		}
//	}
//}
//void Print(const char* name[], int n)
//{
//	int i = 0;
//	const char* p = name[0];
//	while (i < n)
//	{
//		p = *(name + (i++));
//		printf("%s\n", p);
//	}
//}
//int main()
//{
//	const char* name[] = { "Follow me","BASIC","Great Wall","FORTRAN","Computer design" };
//	int n = 5;
//	Sort(name, n);
//	Print(name, n);
//	return 0;
//}

// 8.7.2 指向指针数据的指针变量
//   指针数组的每个元素都有其地址。
//   一般形式： 类型名 ** 变量名;
//int main()
//{
//	const char* name[] = { "Follow me","BASIC","Great Wall","FORTRAN","Computer design" };
//	const char** p;
//	int i;
//	for (i = 0; i < 5; i++)
//	{
//		p = name + i;
//		printf("%s\n", *p);
//	}
//	return 0;
//}

//int main()
//{
//	int a[5] = { 1,2,3,4,5 };
//	int* num[5] = { &a[0],&a[1],&a[2],&a[3],&a[4] };
//	int** p, i;
//	p = num;
//	for (i = 0; i < 5; i++)
//	{
//		printf("%d ", **p);
//		p++;
//	}
//	printf("\n");
//	return 0;
//}

// 8.7.3 指针数组作main函数的形参。
//   一般main函数没有参数，调用main函数不必给出实参。
//   实际上，在某些情况下，main函数可以有参数。
//   int main(int argc,char * argv[])
//   命令行参数：argc代表参数个数，argv是一个指针数组，指向命令行中的字符串首字符。
//   命令行一般形式为： 命令名 参数1 参数2 参数3 。。。。。 参数n
//int main(int argc,char* argv[])
//{
//	int i;
//	for (i = 1; i < argc; i++)
//	{
//		printf("%s%c", argv[i], (i < argc - 1) ? ' ' : '\n');
//	}
//	return 0;
//}


// 8.8 动态内存分配与指向它的指针
// 8.8.1 什么是内存的动态分配
//   c语言除了静态区、动态区的栈，还有动态区的堆。
//   堆，可以根据需要随时开辟、释放内存。
//   只能通过指针来引用。

// 8.8.2 如何建立内存的动态分配
//   对内存的动态分配是通过库函数实现的，主要有： malloc,calloc,free,realloc.
//   1 用malloc开辟动态存储区
//     void malloc(unsigned int size);  / 在内存动态存储区分配一个长度为size的连续空间。
//     此函数是个指针，返回的指针指向该空间的第一个字节。
//     注意：基类型为void，不指向任何类型的数据，只是一个地址。若操作失败，则返回一个空指针(NULL).
//   2 用calloc开辟动态存储区
//     void* calloc{unsigned n，unsigned size);  // 在动态存储区中分配n个长度为size的连续空间。一般空间比较大，能放下一个数组。
//     用calloc可以为一维数组开辟动态空间，n为数组元素个数，每个元素长度为size，这就是动态数组。
//   3 用realloc函数重新分配动态存储区
//     void * realloc(void * p,unsigned int size);
//     如果已经用maollce或calloc函数开辟了动态存储区，可以通过realloc来重新分配空间。
//     将p所指向的动态空间大小改为size，p值不变，如果失败则返回空指针。
//   4 用free释放动态存储区
//     void free(void * p);
//     释放p所指向的动态空间，使这部分空间能为其他变量使用。
//     p应为最近一次调用calloc或malloc得到的函数返回值。
//   以上函数使用时，需要想引用头文件 #include<stdlib.h>。

// 8.8.3 void指针类型
//   c99允许使用基类型为void的指针类型。
//   可以定义一个基类型为void的指针变量，它不指向任何类型的数据。当它值赋给另一指针变量时，系统自动进行类型转换，使之适合被赋值变量的类型。
//   好处：动态分配函数开辟的空间可能被用于各种类型的数据。定义其为void类型，方便进行类型强制转换。
// 建立动态数组，输入5个学生成绩，另外用一个函数检查其中有无不及格的，输出不合格成绩。
//void Check(int* p,int n)
//{
//	int i;
//	for (i = 0; i < n; i++)
//	{
//		if (*(p + i) < 60)
//			printf("%d ", p[i]);
//	}
//	printf("\n");
//}
//int main()
//{
//	int* p1, i;
//	p1 = (int*)malloc(5 * sizeof(int));
//	printf("请输入五个学生的成绩：");
//	for (i = 0; i < 5; i++)
//	{
//		scanf_s("%d", p1 + i);
//	}
//	Check(p1,i);
//	free(p1);
//	return 0;
//}

// 8.9 有关指针的小结
//   1 了解指针含义：指向地址。
//     指针变量的值是指针（地址）
//     数组名是一个地址（首元素地址）
//     函数名是一个指针（指向函数代码区首字节）
//   2 C语言中，所有数据都有其类型。所有数据存在内存存储单元中。
//     指针型数据不仅是纯地址，还需指向数据的类型。 即指针具有纯地址，自身的类型（指针型），指向数据的类型（基类型）。
//   3 区别指针和指针变量。指针即地址，指针变量是一个存放地址的变量。
//   4 指向：通过地址能找到具有该地址的数据。。只有具有相同基类型的数据才能将其地址放在相应的指针变量中。
//   5 搞清指针的指向。
//   6 指针运算。自加、自减、加减、赋值。
//   7 指针变量可以赋空值（NULL）


// test
// 1 输入3个整数，按从小到大输出。
//#define N 3
//void Sort(int a[N], int n)
//{
//	int i, t, j;
//	for (j = 0; j < n; j++)
//	{
//		for (i = j + 1; i < n; i++)
//		{
//			if (a[i] < a[j])
//			{
//				t = a[j];
//				a[j] = a[i];
//				a[i] = t;
//			}
//		}
//	}
//}
//void Sort1(int a[N], int n)  // why can not work?
//{
//	int t;
//	int* p = a;
//	for (; p == &a[n-1]; p++)
//	{
//		int* p1 = p;
//		for (; p1 == &a[n-1]; p1++)
//		{
//			if (*p1 < *p)
//			{
//				t = *p;
//				*p = *p1;
//				*p1 = t;
//			}
//		}
//	}
//}
//int main()
//{
//	int a[N], i;
//	int* p = a;
//	printf("请输入三个整数：");
//	for (i = 0; i < N; i++)
//	{
//		scanf_s("%d", p + i);
//	}
//	printf("\n");
//	/*Sort1(a, N);*/
//	//for (p = &a[0]; p == &a[N - 1]; p++)
//	//{
//	//	printf("%d ", *p);
//	//}
//	for (i = 0; i < N; i++)
//	{
//		printf("%d ", *(p + i));
//	}
//	printf("\n");
//	return 0;
//}

// 2 输入3个字符串，由小到大顺序输出
//void Mergesort_string(char *p,int start,int mid,int end)
//{
//	char* tmp = (char*)malloc((end - start + 1) * sizeof(char));
//	int i = start;  // 左序列起点
//	int j = mid + 1; // 右序列起点
//	int k = 0;  // 临时序列起点
//	while (i <= mid && j <= end)
//	{
//		if (strcmp((p + i), (p + j)) > 0)
//		{
//			j++;
//			tmp[k++] = *(p + j);
//		}
//		else
//		{
//			i++;
//			tmp[k++] = *(p + i);
//		}
//	}
//	while (i <= mid)
//	{
//		i++;
//		tmp[k++] = *(p + i);
//	}
//	while (j <= end)
//	{
//		j++;
//		tmp[k++] = *(p + j);
//	}
//	for (i = 0; i < k; i++)
//	{
//		*(p + i) = tmp[i];
//	}
//	free(tmp);
//}
//void Merge_up2down(char* p, int start, int end)
//{
//	if (p == NULL || start >= end)
//		return;
//	int mid = (end + start) / 2;
//	Merge_up2down(p, start, mid);   // 左序列递归分
//	Merge_up2down(p, mid + 1, end); // 右序列递归分
//	Mergesort_string(p, start, mid, end);
//}
//void Merge_groups(char* p, int len, int gap) // len数组长度，gap子数组长度
//{
//	int i;
//	int twolen = 2 * gap;
//	for (i = 0; i + 2 * gap - 1 < len; i += (2 * gap))
//	{
//		Mergesort_string(p, i, i + gap - 1, i + 2 * gap - 1);
//	}
//	if (i + gap - 1 < len - 1)
//	{
//		Mergesort_string(p, i, i + gap - 1, len - 1);
//	}
//}
//void Merge_down2up(char* p, int len)
//{
//	int n;
//	if (p == NULL || len <= 0)
//		return;
//	for (n = 1; n < len; n *= 2)
//		Merge_groups(p, len, n);
//}
//#define N 40
//void Swap(char* p1,char* p2)
//{
//	char p[N];
//	strcpy(p, p1);
//	strcpy(p1, p2);
//	strcpy(p2, p);
//}
//int main()
//{
//	char str1[N], str2[N], str3[N];
//	printf("请输入三个字符串：");
//	gets_s(str1, N);
//	gets_s(str2, N);
//	gets_s(str3, N);
//	if (strcmp(str1, str2) > 0)
//		Swap(str1, str2);
//	if (strcmp(str1, str3) > 0)
//		Swap(str1, str3);
//	if (strcmp(str2, str3) > 0)
//		Swap(str2, str3);
//	printf("%s\n%s\n%s\n", str1, str2, str3);
//	return 0;
//}

// 3 输入10个整数，最小的放最前，最大的放最后，输出
//void Input(int a[], int n)
//{
//	int* p;
//	printf("请输入%d个整数：",n);
//	for (p = a; p < a + n; p++)
//	{
//		scanf_s("%d", p );
//	}
//	printf("\n");
//}
//void Max_min_value(int a[], int n)
//{
//	int i;
//	int* p = a;
//	int *min = p, *max = p, t;
//	for (i = 1; i < n; i++)    
//	{
//		if (*min > *(p + i))
//			min = (p + i);
//		if (*max < *(p + i))
//			max = (p + i);
//	}
//	if (a[0] > *min)  // 将最小的数与第一个数换位置
//	{
//		t = a[0];
//		a[0] = *min;
//		*min = t;
//	}
//	if (a[n - 1] < *max) // 将最大的数和最后一个数换位置
//	{
//		t = a[n-1];
//		a[n - 1] = *max;
//		*max = t;
//	}
//}
//void Output(int a[], int n)
//{
//	int i;
//	int* p;
//	printf("调整后%d个整数为：", n);
//	for (p = a; p < a+ n; p++)
//	{
//		printf("%d ", *p );
//	}
//}
//int main()
//{
//	int a[10];
//	Input(a, 10);
//	Max_min_value(a, 10);
//	Output(a, 10);
//	return 0;
//}

// 4 n个整数后移m个位置，最后m个数变成最前面m个数。（循环右移m位）
//#define N 50
//void Loop_r(int a[], int m, int n)
//{
//	int* p, a_end;
//	a_end = *(a + n - 1);
//	for (p = a + n - 1; p > a; p--)
//		*p = *(p - 1);
//	*a = a_end;
//	m--;
//	if (m > 0)
//		Loop_r(a, m, n);
//}
//int main()
//{
//	int arr[N], n, m;
//	int* p = arr;
//	printf("请输入一共多少个整数：");
//	scanf_s("%d", &n);
//	printf("请输入这些整数：");
//	for (; p < arr + n; p++)
//		scanf_s("%d", p);
//	printf("请输入右移的位数：");
//	scanf_s("%d", &m);
//	Loop_r(arr, m, n);
//	for (p = arr; p < arr + n; p++)
//		printf("%d ", *p);
//	printf("\n");
//	return 0;
//}

// 5 n人一圈报数，一号位开始从一报三，报到3的退圈，最后剩下原来第几号
//#define N 50
//int main()
//{
//	int i, k, m, n, num[N], * p;
//	printf("请输入一共多少人：");
//	scanf_s("%d", &n);
//	p = num;
//	for (i = 0; i < n; i++)
//		*(p + i) = i + 1;  // 从1到n给每个人编号
//	i = 0;  // 循环计数
//	k = 0;  // 报号
//	m = 0;  // 退出人数
//	while (m < n - 1)     // 当退出人数比n-1少时，继续循环
//	{
//		if (*(p + i) != 0)
//			k++;
//		if (k == 3)
//		{
//			*(p + i) = 0; // 对退出的人编号置0，则最后只剩下一个编号，即为所求
//			k = 0;
//			m++;
//		}
//		i++;
//		if (i == n) // 报数一圈后，i恢复0
//			i = 0;
//	}
//	while (*p == 0)
//		p++;
//	printf("最后剩下的人编号为：%d\n", *p);
//	return 0;
//}

// 6 求字符串的长度
//#define N 20
//int String_len(char a[])
//{
//	int x = 0;
//	char* pa;
//	for (pa = a; pa < a + N; pa++,x++)
//	{
//		if (*pa == '\0')
//			return x;
//	}
//	return 0;
//}
//int main()
//{
//	char arr[N];
//	printf("请输入一个字符串：");
//	scanf_s("%s", arr ,N);
//	int len = String_len(arr);
//	if (len == 0)
//		printf("字符串过长！\n");
//	else
//		printf("字符串长度为：%d\n", len);
//	return 0;
//}

// 7 将字符串从第m个字符开始的全部字符复制成另一个字符串
//#define N 20
//void Locate_cpy(char a1[],char a2[], int m)
//{
//	char* p1 = a1 + m - 1;
//	char* p2 = a2;
//	while (*p1 != '\0')
//	{
//		*p2++ = *p1++;
//	}
//	*p2 = '\0';
//
//}
//int main()
//{
//	char arr1[N], arr2[N];
//	int m;
//	char* p = arr2;
//	printf("请输入一个字符串：");
//	scanf_s("%s", arr1, N);
//	printf("请输入从第几位开始复制：");
//	scanf_s("%d", &m);
//	Locate_cpy(arr1, arr2, m);
//	printf("复制后的字符串为：");
//	while (*p != '\0')
//	{
//		printf("%c", *p++);
//	}
//	return 0;
//}

//8 输入一行文字，找出其中大写字母、小写字母、空格、数字以及其他字符各有多少。
//#define N 100
//int upper = 0, lower = 0, digit = 0, space = 0, other = 0;
//void Count(char a[])
//{
//	char* p = a;
//	while (*p != '\0')
//	{
//		if (( * p >= 'A') && ( * p <= 'Z'))
//			++upper;
//		else if (( * p >= 'a') && (*p <= 'z'))
//			++lower;
//		else if (( * p >= '0') && ( * p <= '9'))
//			++digit;
//		else if (*p == ' ')
//			++space;
//		else
//			++other;
//		p++;
//	}
//}
//int main()
//{
//	char a[N];
//	printf("请输入一行文字：");
//	scanf_s("%s", a, N);
//	Count(a);
//	printf("大写字母有%d个\n",upper);
//	printf("小写字母有%d个\n",lower);
//	printf("空格有%d个\n",space);
//	printf("数字有%d个\n",digit);
//	printf("其它字符有%d个\n",other);
//	return 0;
//}

// 9 转置3x3整型矩阵
//#define N 3
//void Move(int* p)
//{
//	int i, j, t;
//	for (i = 0; i < N; i++)
//	{
//		for (j = i; j < N; j++)
//		{
//			t = *(p + N * i + j);
//			*(p + N * i + j) = *(p + N * j + i);
//			*(p + N * j + i) = t;
//		}
//	}
//}
//int main()
//{
//	int arr[N][N];
//	int* p;
//	printf("请输入方阵：");
//	int i;
//	for (i = 0; i < N; i++)
//		scanf_s("%d %d %d", &arr[i][0], &arr[i][1], &arr[i][2]);
//	p = &arr[0][0];
//	Move(p);
//	printf("转置后方阵为：\n");
//	for (i = 0; i < N; i++)
//		printf("%d %d %d\n", arr[i][0], arr[i][1], arr[i][2]);
//	return 0;
//}

// 10 5x5矩阵中最大元素放中心，4个角分别放最小元素（最小左上角，其次右上，然后左下，最后右下）
//#define N 5
//void Change(int* p)
//{
//	int i, j, t;
//	int* pmax = p, * pmin = p;
//	for (i = 0; i < N; i++)
//	{
//		for (j = 0; j < N; j++)
//		{
//			if (*pmax < *(p + N * i + j))S
//				pmax = p + N * i + j;
//			if (*pmin > *(p + N * i + j))
//				pmin = p + N * i + j;
//		}
//	}
//	t = *(p + N * N / 2);   // 中心
//	*(p + N * N / 2) = *pmax;
//	*pmax = t;
//	t = *p;      // 左上
//	*p = *pmin;
//	*pmin = t;
//	for (i = 0; i < N; i++)
//	{
//		for (j = 0; j < N; j++)
//		{
//			if (i == 0 && j == 0)
//				continue;
//			if (*pmin > *(p + N * i + j))
//				pmin = p + N * i + j;
//		}
//	}
//	t = *pmin;  // 右上
//	*pmin = *(p + N - 1);
//	*(p + N - 1) = t;
//	for (i = 0; i < N; i++)
//	{
//		for (j = 0; j < N; j++)
//		{
//			if ((i == 0 && j == 0) || (i == 0 && j == N - 1))
//				continue;
//			if (*pmin > *(p + N * i + j))
//				pmin = p + N * i + j;
//		}
//	}
//	t = *pmin; // 左下
//	*pmin = *(p + N * N - N);
//	*(p + N * N - N) = t;
//	for (i = 0; i < N; i++)
//	{
//		for (j = 0; j < N; j++)
//		{
//			if ((i == 0 && j == 0) || (i == 0 && j == N - 1) || (i == N - 1 && j == 0))
//				continue;
//			if (*pmin > *(p + N * i + j))
//				pmin = p + N * i + j;
//		}
//	}
//	t = *pmin; // 右下
//	*pmin = *(p + N * N - 1);
//	*(p + N * N - 1) = t;
//}
//
//int main()
//{
//	int arr[N][N];
//	int i, j;
//	printf("请输入一个%dx%d矩阵：", N, N);
//	for (i = 0; i < N; i++)
//	{
//		for (j = 0; j < N; j++)
//			scanf_s("%d", &arr[i][j]);
//	}
//	int* p = &arr[0][0];
//	Change(p);
//	printf("交换后矩阵为：\n");
//	for (i = 0; i < N; i++)
//	{
//		for (j = 0; j < N; j++)
//			printf("%d ", arr[i][j]);
//		printf("\n");
//	}
//	return 0;
//}

// 11 输入10个等长的字符串。用函数排序。
//#define N 6
//#define M 5
//void Sort(char a[M][N])
//{
//	char* p;
//	char t[N];
//	p = t;
//	int i, j;
//	for (i = 0; i < M - 1; i++)
//	{
//		for (j = 0; j < M - i - 1; j++)
//		{
//			if (strcmp(a[j], a[j + 1]) > 0)
//			{
//				strcpy_s(p, N, a[j]);
//				strcpy_s(a[j], N, a[j + 1]);
//				strcpy_s(a[j + 1], N, p);
//			}
//		}
//	}
//}
//int main()
//{
//	char arr[M][N] = {};
//	char* p = arr[0];
//	printf("请输入%d个等长字符串：",M);
//	for (; p < arr[0] + M; p++)
//		scanf_s("%s", p, N);
//	Sort(arr);
//	printf("排序结果为：\n");
//	for (p = arr[0]; p < arr[0] + M; p++)
//		printf("%s\n", *p);
//	return 0;
//}

// 12 指针数组处理上一题
//#define N 10
//#define M 20
//void Sort(char* s[])
//{
//	int i, j;
//	char* t;
//	for (i = 0; i < N - 1; i++)
//	{
//		for (j = 0; j < N - i - 1; j++)
//		{
//			if (strcmp(*(s + j), *(s + j + 1)) > 0)
//			{
//				t = *(s + j);
//				*(s + j) = *(s + j + 1);
//				*(s + j + 1) = t;
//			}
//		}
//	}
//}
//int main()
//{
//	char* p[N], str[N][M];
//	int i;
//	for (i = 0; i < N; i++)
//		p[i] = str[i];
//	printf("请输入%d个字符串：", N);
//	for (i = 0; i < N; i++)
//		scanf_s("%s", p[i], M);
//	Sort(p);
//	printf("排序后结果为：\n");
//	for (i = 0; i < N; i++)
//		printf("%s\n", p[i]);
//	return 0;
//}

// 13 矩形法求定积分的通用函数。
//float Fsin(float x)
//{
//	return sin(x);
//}
//float Fcos(float x)
//{
//	return cos(x);
//}
//float Fexp(float x)
//{
//	return exp(x);
//}
//float Integral(float(*p)(float), float a, float b, int n)
//{
//	int i;
//	float x, h, s;
//	h = (b - a) / n;  // 微元宽度
//	x = a;            // 从积分下限开始，到积分上限为止
//	s = 0;            // 求和累加器
//	for (i = 1; i <= n; i++)
//	{
//		x = x + h;
//		s = s + (*p)(x) * h;  // (*p)(x) 返回每段微元开始处的微元高度。 
//	}
//	return s;
//}
//int main()
//{
//	float a1, b1, a2, b2, a3, b3, c, (*p)(float);
//	int n;
//	printf("请输入微分矩形个数：");
//	scanf_s("%d", &n);
//	printf("请输入a1,b1：");
//	scanf_s("%f,%f", &a1, &b1);
//	printf("请输入a2,b2：");
//	scanf_s("%f,%f", &a2, &b2);
//	printf("请输入a3,b3：");
//	scanf_s("%f,%f", &a3, &b3);
//	p = Fsin;
//	c = Integral(p, a1, b1, n);
//	printf("sin积分结果为：%f\n", c);
//	p = Fcos;
//	c = Integral(p, a2, b2, n);
//	printf("cos积分结果为：%f\n", c);
//	p = Fexp;
//	c = Integral(p, a3, b3, n);
//	printf("exp积分结果为：%f\n", c);
//	return 0;
//}

// 14 n个数按输入顺序的逆序输出。
//#define N 30
//void Reverse(int * p, int n)
//{
//	int t, i;
//	for (i = 0; i < n / 2; i++)
//	{
//		t = *(p + i);
//		*(p + i) = *(p + n - i - 1);
//		*(p + n - i - 1) = t;
//	}
//}
//int main()
//{
//	int num[N];
//	int* p;
//	int n;
//	printf("请输入一共多少个数：");
//	scanf_s("%d", &n);
//	for (p = num; p < num + n; p++)
//	{
//		scanf_s("%d", p);
//	}
//	printf("原数组为：");
//	for (p = num; p < num + n; p++)
//	{
//		printf("%d ", *p);
//	}
//	printf("\n");
//	p = num;
//	Reverse(p, n);
//	printf("逆序后数组为：");
//	for (p = num; p < num + n; p++)
//	{
//		printf("%d ", *p);
//	}
//	printf("\n");
//	return 0;
//}

// 15 成绩
void Avsco(float* pscore, float* paver)
{
	int i, j;
	float sum, average;
	for (i = 0; i < 4; i++)
	{
		sum = 0.0;
		for (j = 0; i < 5; j++)
		{
			sum = sum + (*(pscore + 5 * i + j));
		}
		average = sum / 5;
		*(paver + i) = average;
	}
}
void Avcourl(char(*pcourse)[10], float* pscore)
{
	int i;
	float sum, averagel;
	sum = 0.0;
	for (i = 0; i < 4; i++)
	{
		sum = sum + (*(pscore + 5 * i));
	}
	averagel = sum / 4;
	printf("课程1:%s 平均分数：%7.2f\n", *pcourse, averagel);
}
void Fali2(char course[5][10], int num[], float* pscore, float aver[4])
{
	int i, j, k, label;
	printf(" ==================两门及以上的挂科的学生======================\n");
	printf("NO.");
	for (i = 0; i < 5; i++)
	{
		printf("%11s", course[i]);
	}
	printf("    average\n");
	for (i = 0; i < 4; i++)
	{
		label = 0;
		for (j = 0; j < 5; j++)
		{
			if (*(pscore + 5 * i + j) < 60.0)
				label++;
		}
		if (label >= 2)
		{
			printf("%d", num[i]);
			for (k = 0; k < 5; k++)
				printf("%11.2f", *(pscore + 5 * i + k));
			printf("%11.2f\n", aver[i]);
		}
	}
}
void Good(char course[5][10], int num[4], float* pscore, float aver[4])
{
	int i, j, k, n;
	printf(" ==================成绩好的学生======================\n");
	printf("NO.");
	for (i = 0; i < 5; i++)
		printf("%11s", course[i]);
	printf("    average\n");
	for (i = 0; i < 4; i++)
	{
		n = 0;
		for (j = 0; j < 5; j++)
		{
			if (*(pscore + 5 * i + j) > 85.0)
				n++;
			if ((n == 5) || (aver[i] >= 90))
			{
				printf("%d", num[i]);
				for (k = 0; k < 5; k++)
					printf("%11.2f", *(pscore + 5 * i + k));
				printf("%11.2f\n", aver[i]);
			}
		}
	}
}
int main()
{
	int i, j, * pnum, num[4];
	char course[5][10], (*pcourse)[10];
	float score[4][5], aver[4], * pscore, * paver;
	printf("请输入课程：\n");
	printf("NO.");
	for (i = 0; i < 5; i++)
		printf(",%s", course[i]);
	printf("\n");
	pscore = &score[0][0];
	pnum = &num[0];
	for (i = 0; i < 4; i++)
	{
		scanf_s("%d", pnum + i);
		for (j = 0; j < 5; j++)
			scanf_s("%f", pscore + 5 * i + j);
	}
	paver = &aver[0];
	printf("\n\n");
	Avsco(pscore, paver);
	Avcourl(pcourse, pscore);
	printf("\n\n");
	Fali2(pcourse, pnum, pscore, paver);
	printf("\n\n");
	Good(pcourse, pnum, pscore, paver);
	return 0;
}

// 16 将字符串中连续整数作为一个数存入数组a中，统计共有多少个整数并输出。
#define N 50
void Find_num(char str[N], int a[N])
{
	int sum = 0, lab = 0, dig;
	char* ps = str;
	int* pa = a;
	int i = 0, k, e10, m;
	while(*(ps + i) != '\0')
	{
		if ((*(ps + i) >= '0') && (*(ps + i) <= '9'))
			lab++;
		else
		{
			if (lab > 0)
			{
				dig = *(ps + i - 1) - 48;
				k = 1;
				while (k < lab)
				{
					e10 = 1;
					for (m = 1; m <= k; m++)
					{
						e10 = e10 * 10;
					}
					dig = dig + (*(ps + i - 1 - k) - 48) * e10;
					k++;
				}
				*pa = dig;
				sum++;
				pa++;
				lab = 0;
			}
		}
		i++;
	}
	if (lab > 0)
	{
		dig = *(ps + i - 1) - 48;
		k = 1;
		while (k < lab)
		{
			e10 = 1;
			for (m = 1; m <= k; m++)
				e10 = e10 * 10;
			dig = dig + (*(ps + i - 1 - k) - 48) * e10;
			k++;
		}
		*pa = dig;
		sum++;
		lab = 0;
	}
	printf("字符串中有%d个数字，分别是：\n", sum);
	for (pa = a; pa < a + sum; pa++)
		printf("%d ", *pa);
	printf("\n");
}
int main()
{
	char str[N];
	int a[N];
	char* ps = str;
	printf("请输入字符串：");
	scanf_s("%s", ps, N);
	Find_num(str, a);
	return 0;
}

// 17 字符串比较
//int Strcmp(char* p1, char* p2)
//{
//	int i = 0;
//	while (*(p1 + i) == *(p2 + i))
//	{
//		if (*(p1 + i++) == '\0')
//			return 0;
//	}
//	return (*(p1 + i) - *(p2 + i));
//}
//int main()
//{
//	int m;
//	char s1[20], s2[20], * p1, * p2;
//	p1 = s1, p2 = s2;
//	printf("请输入两个字符串：\n");
//	scanf_s("%s", p1, 20);
//	scanf_s("%s", p2, 20);
//	m = Strcmp(p1, p2);
//	printf("结果为：%d\n", m);
//	return 0;
//}

// 18 输入月份，输出对应英文，指针数组处理
//int main()
//{
//	const char* mouth[13] = { "illegal mouth","January","February","March","April","May","June","July","August","September","October","November","December" };
//	int n;
//	printf("请输入月份：");
//	scanf_s("%d", &n);
//	if ((n <= 12) && (n >= 1))
//		printf("结果为：%s\n", *(mouth + n));
//	else
//		printf("输入错误！");
//	return 0;
//}

// 19 开辟动态内存空间、和释放函数
//#define SIZE 1000
//char newbuf[SIZE];
//char* pnew = newbuf;
//char* New(int n)
//{
//	if (pnew + n <= newbuf + SIZE) // 开辟空间未超过newbuf数组大小
//	{
//		pnew += n;
//		return (pnew - n);
//	}
//	else
//		return NULL;
//}
//void Free(char* p)
//{
//	if (p >= newbuf && p < newbuf + SIZE)
//		pnew = p;
//}
//int main()
//{
//	char* p;
//	int n = 20;
//	p = New(n);
//	Free(p);
//	return 0;
//}

// 20 指向指针的指针对5个字符串排序
//#define LINEMAX 20
//void Sort(char** p)
//{
//	int i, j;
//	char* t;
//	for (i = 0; i < 5; i++)
//	{
//		for (j = i + 1; j < 5; j++)
//		{
//			if (strcmp(*(p + i), *(p + j)) > 0)
//			{
//				t = *(p + i);
//				*(p + i) = *(p + j);
//				*(p + j) = t;
//			}
//		}
//	}
//}
//int main()
//{
//	int i;
//	char** p, * pstr[5], str[5][LINEMAX];
//	for (i = 0; i < 5; i++)
//	{
//		pstr[i] = str[i];
//	}
//	printf("请输入5个字符串：");
//	for (i = 0; i < 5; i++)
//		scanf_s("%s", pstr[i],LINEMAX);
//	p = pstr;
//	Sort(p);
//	printf("结果为：\n");
//	for (i = 0; i < 5; i++)
//		printf("%s\n", pstr[i]);
//	return 0;
//}

// 21 用指向指针的指针对n个整数排序并输出
//#define N 10
//void Sort(int** p,int n)
//{
//	int i, j, * t;
//	for (i = 0; i < n; i++)
//	{
//		for (j = i + 1; j < n; j++)
//		{
//			if (**(p + i) > **(p + j))
//			{
//				t = *(p + i);
//				*(p + i) = *(p + j);
//				*(p + j) = t;
//			}
//		}
//	}
//}
//int main()
//{
//	int arr[N];
//	int* p[N];
//	int i, n;
//	printf("请输入数组元素个数：");
//	scanf_s("%d", &n);
//	for (i = 0; i < n; i++)
//		p[i] = &arr[i];
//	int** pp = p;
//	printf("请输入数组元素：");
//	for (i = 0; i < n; i++)
//		scanf_s("%d", &arr[i]);
//	Sort(pp, n);
//	printf("排序后数组为：");
//	for (i = 0; i < n; i++)
//		printf("%d ", *p[i]);
//	printf("\n");
//	return 0;
//}

// 9.1.3 结构体变量的初始化和引用
// 例
//int main()
//{
//	struct Student
//	{
//		long int num;
//		char name[20];
//		char sex;
//		char addr[20];
//	}a={10101,"Li LIN",'M',"123 Beijing Road"};
//	printf("NO, :%ld\nname:%s\nsex:%c\naddress:%s\n", a.num, a.name, a.sex, a.addr);
//}
//   1 定义结构体变量时可以对它的成员初始化。 注意：是对结构体变量初始化，而不是对结构体类型初始化。
//   2 可以引用结构体变量中的成员的值，引用方式为： 结构体变量名.成员名
//   3 入股成员本身是一个结构体类型，则需要使用若干个成员运算符. 一级一级直到基础类型。
//   4 对结构体变量的成员可以像普通变量一样进行运算。
//   5 同类的结构体变量可以相互赋值。
//   6 可以引用结构体变量成员地址，也可以引用结构体变量的地址。
// 例
//struct Student
//{
//	int num;
//	char name[20];
//	float score;
//};
//int main()
//{
//	Student a, b;
//	printf("请输入两个学生的成绩：");
//	scanf_s("%d%s%f", &a.num, &a.name, 20, &a.score);
//	scanf_s("%d%s%f", &b.num, &b.name, 20, &b.score);
//	if (a.score > b.score)
//		printf("成绩较高的学生为：%s ,他的学号为：%d，成绩为：%6.2f\n", a.name, a.num, a.score);
//	else
//		printf("成绩较高的学生为：%s ,他的学号为：%d，成绩为：%6.2f\n", b.name, b.num, b.score);
//	return 0;
//}


// 9.2 使用结构体数据
// 9.2.1 定义结构体数组
// 例
//struct Person
//{
//	char name[20];
//	int count;
//}leader[3]={"Li",0,"Zhang",0,"Sun",0};
//int main()
//{
//	int i, j;
//	char leader_name[20];
//	for (i = 0; i <= 10; i++)
//	{
//		scanf_s("%s", leader_name, 20);
//		for (j = 0; j < 3; j++)
//		{
//			if (strcmp(leader_name, leader[j].name) == 0)
//				leader[j].count++;
//		}
//	}
//	printf("\n结果为：\n");
//	for (i = 0; i < 3; i++)
//		printf("%5s:%d\n", leader[i].name, leader[i].count);
//	return 0;
//}
//   1 定义结构体数组一般形式：
//     struct 结构体名
//     { 成员列表
//     }数组名[长度];
//   2 初始化：  结构体类型 数组名[长度]={初值列表};

// 9.2.2 结构体数组应用举例
//struct Student
//{
//	int num;
//	char name[20];
//	float score;
//};
//int main()
//{
//	struct Student stu[5] = { {10101,"Zhang",78},{10103,"Wang",98.5},{10106,"Li",86},{10108,"Ling",73.5},{10110,"Sun",100} };
//	struct Student t;
//	const int n = 5;
//	int i, j, k;
//	printf("顺序为：\n");
//	for (i = 0; i < n - 1; i++)
//	{
//		k = i;
//		for (j = i + 1; j < n; j++)
//		{
//			if (stu[j].score > stu[k].score)
//				k = j;
//		}
//		t = stu[k];
//		stu[k] = stu[i];
//		stu[i] = t;
//	}
//	for (i = 0; i < n; i++)
//		printf("%6d %8s %6.2f\n", stu[i].num, stu[i].name, stu[i].score);
//	printf("\n");
//	return 0;
//}


// 9.3 结构体指针
// 9.3.1 指向结构体变量的指针
//   既可以指向结构体变量，也可以指向结构体数组中的元素。
//   指针变量的基类型必须与结构体变量类型相同。
// 例
//int main()
//{
//	struct Student
//	{
//		long num;
//		char name[20];
//		char sex;
//		float score;
//	};
//	struct Student stu_1;
//	struct Student* p;
//	p = &stu_1;
//	stu_1.num = 10101;
//	strcpy_s(stu_1.name, 7, "Lin Li");
//	//strcpy(stu_1.name, "Lin Li");
//	stu_1. sex = 'M';
//	stu_1.score = 89.5;
//	printf("NO. :%ld\nname:%s\nsex:%c\nscore:%5.1f\n", stu_1.num, stu_1.name, stu_1.sex, stu_1.score);
//	printf("NO. :%ld\nname:%s\nsex:%c\nscore:%5.1f\n", (*p).num, (*p).name, (*p).sex, (*p).score);
//	printf("NO. :%ld\nname:%s\nsex:%c\nscore:%5.1f\n", p->num, p->name, p->sex, p->score); // 允许->替换上面的写法。
//	return 0;
//}

// 9.3.2 指向结构体数组的指针
// 例
//struct Student
//{
//	int num;
//	char name[20];
//	char sex;
//	int age;
//};
//struct Student stu[3] = { {10101,"Li Lin",'M',18},{10102,"Zhang Fang",'M',19},{10104,"Wang Min",'F',20} };
//int main()
//{
//	struct Student* p;
//	printf("NO.     Name               sex  age\n ");
//	for (p = stu; p < stu + 3; p++)
//		printf("%5d %-20s %2c %4d\n", p->num, p->name, p->sex, p->age);
//	return 0;
//}

// 9.3.3 用结构体变量和其指针作函数参数
//   一般不用结构体变量作函数参数（传递数据太大），一般用结构体成员或结构体指针。
// 例
//#define N 3
//struct Student     // 结构体类型
//{
//	int num;        // 学号
//	char name[20];  // 姓名
//	float score[3]; // 数组，三门课成绩
//	float aver;     // 平均分
//};
//void Input(struct Student stu[])
//{
//	int i;
//	printf("请输入各学生信息：学号、姓名、3门课程成绩：\n");
//	for (i = 0; i < N; i++)
//	{
//		scanf_s(" %d %s %f %f %f", &stu[i].num, stu[i].name, &stu[i].score[0], &stu[i].score[1], &stu[i].score[2]);
//		stu[i].aver = (stu[i].score[0] + stu[i].score[1] + stu[i].score[2]) / 3.0;
//	}
//}
//struct Student max(struct Student stu[])
//{
//	int i, m = 0;
//	for (i = 0; i < N; i++)
//	{
//		if (stu[i].aver > stu[m].aver)
//			m++;
//	}
//	return stu[m];
//}
//void Print(struct Student stud)
//{
//	printf("\n成绩最高的学生是：\n");
//	printf("学号：%d\n姓名：%s\n三门课成绩：%5.1f,%5.1f,%5.1f\n平均成绩：%6.2f\n",
//		stud.num, stud.name, stud.score[0], stud.score[1], stud.score[2]);
//}
//int main()
//{
//	struct Student stu[N];   // 创建结构体变量
//	struct Student* p = stu; // 创建结构体指针
//	Input(p);  // 传递指针，初始化
//	Print(max(p)); // 传递指针给max函数，函数返回结构体变量给Print函数，输出结果
//	return 0;
//}

// 9.4 用指针处理链表
// 9.4.1 链表
//   一种动态分配存储空间的数据结构。
//   有一种头指针变量，指向一个元素。
//   链表中每一个元素称为结点，包含：实际数据，下一个结点的地址。
//   最后一个元素称为表尾，地址部分放空指针。
//   结构体变量最适合建立链表，因为内部可以有不同类型的成员。

// 9.4.2 建立简单静态链表
// 例：
//struct Student
//{
//	int num;
//	float score;
//	struct Student* next;
//};
//int main()
//{
//	struct Student a, b, c, * head, * p;
//	a.num = 10101; a.score = 89.5;
//	b.num = 10103; b.score = 90;
//	c.num = 10107; c.score = 85;
//	head = &a;
//	a.next = &b;
//	b.next = &c;
//	c.next = NULL;
//	p = head;
//	do
//	{
//		printf(" % ld % 5.1f\n", p->num, p->score);
//		p = p->next;
//	} while (p != NULL);
//	return 0;
//}

// 9.4.3 建立动态链表
//   是指在程序执行过程中从无到有地建立起一个链表（一个个开辟结点和输入数据）
// 例
//#define LEN sizeof(struct Student)
//struct Student
//{
//	long num;
//	float score;
//	struct Student* next;
//};
//int n;
//struct Student* creat(void)
//{
//	struct Student* head;
//	struct Student* p1, * p2;
//	n = 0;
//	p1 = p2 = (struct Student*)malloc(LEN);
//	scanf_s("%ld, %f", &p1->num, &p1->score);
//	head = NULL;
//	while (p1->num != 0)
//	{
//		n = n + 1;
//		if (n == 1)
//			head = p1;
//		else
//			p2->next = p1;
//		p2 = p1;
//		p1 = (struct Student*)malloc(LEN);
//		scanf_s("%lf,%f", &p1->num, &p1->score);
//	}p2->next = NULL;
//	return head;
//}
//int main()
//{
//	struct Student* pt;
//	pt = creat();
//	printf("\nnum:%lf\nscore:%5.1f\n", pt->num, pt->score);  // 输出第一个结点成员值
//	return 0;
//}

// 9.4.4 输出链表
//#define LEN sizeof(struct Student)
//struct Student
//{
//	long num;
//	float score;
//	struct Student* next;
//};
//int n;
//void Print(struct Student* head)
//{
//	struct Student* p;
//	printf("\n%d个结点的内容为：\n", n);
//	p = head;
//	if (head != NULL)
//	{
//		do
//		{
//			printf("%ld %5.1f\n", p->num, p->score);
//			p = p->next;
//		} while (p != NULL);
//	}
//}

// 9.4.5 链表删除结点
//   从动态链表中删除一个结点，不是真正从内存中抹除它，而是让它脱离链表。
//   判断链表是否是空表，寻找结点，是否找不到需要删除的结点。
//#define LEN sizeof(struct Student)
//struct Student
//{
//	long num;
//	float score;
//	struct Student* next;
//};
//int n;
//struct Student* Del(struct Student* head, long num)
//{
//	struct Student* p1, * p2;
//	if (head == NULL)          // 先判断是不是空表
//	{
//		printf("\n是空表\n");  // 是的话，返回信息
//		return head;
//	}
//	p1 = head; // p1指向表头
//	while (num != p1->num && p1->next != NULL)  // 一个一个往后寻找寻找结点。判断p1是不是结点，且后面还有结点。
//	{
//		p2 = p1;         // p2指向上一个结点的地址
//		p1 = p1->next;   // p1指向下一个结点的地址
//	}
//	if (num == p1->num)  // 如果找到了结点
//	{
//		if (p1 == head)  // p1是删除的结点的地址
//			head = p1->next;  // 如果是原表头地址，则新的表头是下一个结点的地址
//		else
//			p2->next = p1->next; // 如果不是表头，则将上一个结点内的下一结点地址改为当前结点的下一结点地址。
//		printf("删除：%ld\n", num);
//		n = n - 1;  // 结点数减一
//	}
//	else         // 找不到要删除的结点
//		printf("%ld结点未找到\n");
//	return head;
//}

// 9.4.6 链表插入结点
//   依据某一标准，找到要插入的位置。
//   将要插入结点内下一结点地址改成上一个结点内的下一节点地址。
//   将上一个结点内的下一节点地址改成要插入结点的位置。
//#define LEN sizeof(struct Student)
//struct Student
//{
//	long num;
//	float score;
//	struct Student* next;
//};
//int n;
//struct Student* Insert(struct Student* head, struct Student* stud)  // *stud是要插入结点的地址
//{
//	struct Student* p0, * p1, * p2;
//	p1 = head;  
//	p0 = stud;
//	if (head == NULL)  // 如果是空表
//	{
//		head = p0;     // 则要插入结点是唯一结点 表头地址是stud
//		p0->next = NULL;  // 下一结点地址为空
//	}
//	else               // 如果不是空表
//	{
//		while ((p0->num > p1->num) && (p1->next != NULL)) // stud内的num比上一结点的num大
//		{
//			p2 = p1;       // p2指向上一结点地址
//			p1 = p1->next; // p1指向下一结点地址
//		}
//		if (p0->num <= p1->num) // stud内的num比下一结点的num小或相等 则找到要插入的位置
//		{
//			if (head == p1)     // 如果该位置是表头
//				head = p0;      // 首地址为插入结点的地址
//			else  // 不是表头
//			{
//				p2->next = p0;  // 上一结点内的下一结点地址为插入结点的地址
//				p0->next = p1;  //  插入结点内下一结点的地址，为原下一结点的地址
//			}
//		}
//		else  // 否则 插入位置为表尾
//		{
//			p1->next = p0;
//			p0->next = NULL;
//		}
//	}
//	n = n + 1; // 结点数加一
//	return head;
//}
