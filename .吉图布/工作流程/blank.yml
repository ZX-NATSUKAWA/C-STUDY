# This is a basic workflow to help you get started with Actions

name: CI

# Controls when the workflow will run
on:
  # Triggers the workflow on push or pull request events but only for the main branch
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

  # Allows you to run this workflow manually from the Actions tab
  workflow_dispatch:

# A workflow run is made up of one or more jobs that can run sequentially or in parallel
jobs:
  # This workflow contains a single job called "build"
  build:
    # The type of runner that the job will run on
    runs-on: ubuntu-latest

    # Steps represent a sequence of tasks that will be executed as part of the job
    steps:
      # Checks-out your repository under $GITHUB_WORKSPACE, so your job can access it
      - uses: actions/checkout@v2

      # Runs a single command using the runners shell
      - name: Run a one-line script
        run: echo Hello, world!

      # Runs a set of commands using the runners shell
      - name: Run a multi-line script
        run: |
          echo Add other actions to build,
          echo test, and deploy your project.


struct Book
{
  char name[20];
  short price; // 55
};
int main()
{
  sreuct Book bl ={"C语言真难",55};
  printf("书名:%s\n",bl,name);
  printf("价格:%d\n",bl,price);
  return 0;
}

//分支语句和循环语句
//C语言是一门结构化的程序设计语言（顺序结构、选择结构、循环结构）
// 选择结构——分支语句
int main()
{
	int a = 0; // ;表示一条语句结束了
	; // 空语句
	return 0;
}
int main()
{
	int age = 10;
	if (age < 18)
		printf("未成年\n");  //到这一步是单分支
	else
		printf("成年\n");    //双分支
	return 0;
}
int main()
{
	int age = 21;
	if (age < 18)
	{
  printf("未成年\n");
  }
  else
  {
  if (age >= 18 && age < 28)
		printf("青年\n");
	else if (age >= 28 && age < 50)
		printf("壮年\n");
	else if (age >= 50 && age < 90)
		printf("老年\n");
	else
		printf("仙人\n");
   }
	return 0;
}
int main()
{
	int a = 0;
	int b = 2;
	if (a == 1)
	{
		if (b == 2)
			printf("hehe\n");
	}
	else
		    printf("haha\n");
	return 0;
}
//比较奇数
int main()
{
	int a = 4;
	if (a % 2 == 0)
		printf("偶数\n");
	else
		printf("奇数\n");
	return 0;
}
int main()
{
	int i = 1;
	while (i <= 100)
	{
		if (i % 2 == 1)
			printf(" % d", i);
		i++;
	}
	return 0;
}
int main()
{
	int i = 1;
	while (i <= 100)
	{
		if (i % 2 != 0)
			printf("%d", i);
		i+=2;
	}
	return 0;
}
int main()
{
	int day = 0;
	scanf("%d", &day);
	switch (day)
	{
		case 1:
			if (1 == day)
				printf("周末综合征\n");
		case 2:
		case 3:
		case 4:
		case 5:
			printf("工作日\n");
			break;
		case 6:
		case 7:
			printf("休息日\n");
			break; //最后一句加上break防止后续加代码，case7执行时把后面的也执行了。
		case 8:
			break;
		default:
			printf("输入错误\n");
			break;
	}
	return 0;
}
int main()
{
	int n = 1;
	int m = 2;
	switch (n)
	{ 
	case 1:m++;
	case 2:n++;
	case 3:
		switch(n) //switch允许嵌套使用
		{
	    case 1:n++;
		case 2:m++; n++;
			break;//用于跳出case3内的分支，进入原来的分支。
		}
	case 4:m++;
		break;
	default:
		break;
	}
	printf("m=%d,n=%d\n", m, n); // m=5 n=3
	return 0;
} 
 循环结构——循环语句
int main()
{
	while (1)
		printf("hehe\n"); //无限循环打印hehe
	return 0;
}
int main()
{
	int i = 1;
	while (i <= 10)
	{
		if (5 == i)
			break; //打破循环
		printf(" %d",i);
		i++;
	}
	return 0;
}
int main()
{
	int i = 0;
	while (i <= 10)
	{
		//if (5 == i)
		//	continue; // continue后的不执行，返回while的判断。此处进入死循环
		i++;
		if (5 == i)
			continue;
		printf(" %d", i);
	}
	return 0;
}

int main()
{
	int ch = getchar();
	putchar(ch); //相当于printf("%c\n",ch);
	printf("%c\n", ch);
	return 0;
}
#define _CRT_SECURE_NO_WARNING 1
int main()
{
	int ch = 0;
	//输入ctrl+z此时getchar获取EOF结束循环
	while ((ch = getchar()) != EOF)  //EOF=end of file文件结束标志
	{
		putchar(ch);
	}
	return 0;
}
int main()
{
	int ret = 0;
	int ch =0;
	char password[20] = { 0 };
	printf("请输入密码：>");
	scanf("%s", password);  //输入缓冲区123456\n→输入函数123456
	printf("请确认（Y/N):>");
	while((ch = getchar()) != '\n')
	{
	  ;
	}
	ret = getchar();
	if (ret == 'Y')
	{
		printf("确认成功\n");
	}
	else
	{
		printf("放弃确认\n");
	}
	return 0;
}
int main()
{
	int i = 0;
	for (i = 1; i <= 10; i++) //将三个步骤放在了一起
	{
		printf("%d ", i);
	}
	return 0;
 }
int main()                      //计算阶乘求和
{
	int i = 0;
	int n = 0;
	int ret = 1;
	int sum = 0;
	int k = 0;
	scanf("%d", &k);
	for (n = 1; n <= k; n++)
	{
		ret = 1;
		for(i=1;i<=n;i++)
		{
			ret = ret * i;
		}
		sum = sum + ret;
	}
	printf("sum=%d\n", sum);
	return 0;
}
5
int main()
{
	int i = 0;
	char password[20] = { 0 };
	for (i = 0; i < 3; i++)
	{

		printf("请输入密码:>");
		scanf("%s", password);
		if (strcmp(password, "1210") == 0)  //等号不能用来比较两个字符串是否相等，应该使用一个库函数-strcmp
		{
			printf("登录成功\n");
			break;
		}
		else
			printf("密码错误\n");
	}
	if (3 == i)
		printf("三次密码均错误，退出程序\n");
	return 0;
}
6     //输入三个值排序，按从大到小输出
int main()                           
{
	int a = 0;
	int b = 0;
	int c = 0;
	scanf("%d%d%d", &a, &b, &c);
	if (a < b)
	{
		int tmp = a;
		a = b;
		b = tmp;
	}
	if (a < c)
	{
		int tmp = a;
		a = c;
		c = tmp;
	}
	if (b < c)
	{
		int tmp = b;
		b = c;
		c = tmp;
	}
	printf("%d %d %d\n", a, b, c);
	return 0;
}
7     //打印1-100之间的所有3的倍数
int main()
{
	int i = 0;
	for(i = 1;i < 100; i++)
	{
		if (i % 3 == 0)
			printf("%d ", i);
	}
	return 0;
}
8      //给两个数，求最大公约数
int main()
{
	int a = 0;
	int b = 0;
	scanf("%d%d", &a, &b);
	int r = 0;
	while (a % b)  //辗转相除法
	{
		r = a % b;
		a = b;
		b = r;
	}
	printf("%d\n", b);
	return 0l;
}
8          //打印闰年
int main()
{
	int year = 0;
	int count = 0;
	for (year = 1000; year <= 2000; year++)
	{
		if (year % 4 == 0 && year % 100 != 0)
		{
			printf("%d ", year);
			count++;
		}
		else if (year % 400 == 0)
		{
			printf("%d ", year);
			count++;
		}
	}
	printf("\ncount =%d\n", count);
	return 0;
}
int main()
{
	int year = 0;
	int count = 0;
	for (year = 1000; year <= 2000; year++)
	{
		if (((year % 4 == 0) && (year % 100 != 0)) || (year % 400 == 0))
		{
			printf("%d ", year);
			count++;
		}
	}
	printf("\ncount =%d\n", count);
	return 0;
}
9     //打印素数
int main()
{
	int i = 0;
	int count = 0;
	for (i = 100; i <= 200; i++)  //试除法
	{
		int j = 0;
		for (j = 2; j < i; j++)
		{
			if (i % j == 0)
			{
				break;
			}
		}
		if (j == i)
		{
			count++;
			printf("%d ", i);
		}
	}
	printf("\ncount =%d\n", count);
	return 0;
}
1  //数9的个数
int main()
{
	int i = 0;
	int count = 0;
	for (i = 1; i <= 100; i++)
	{
		if (i % 10 == 9)
			count++;
		if (i / 10 == 9)
			count++;
	}
	printf("count = %d\n", count);
	return 0;
}
2    //分数求和
int main()
{
	int i = 0;
	double sum = 0.0;
	int flag = 1;
	for (i = 1; i <= 100; i++)
	{
		sum += flag*1.0 / i;
		flag = -flag;
	}
	printf("%lf\n", sum);
	return 0;
}
3       //十个数找最大值
int main()
{
	int arr[] = { 1,2,3,4,5,6,7,8,9,10 };
	int max = arr[0];
	int i = 0;
	int sz = sizeof(arr) / sizeof(arr[0]);
	for (i = 0; i < sz; i++)
	{
		if (arr[i] > max)
		{
			max = arr[i];
		}
	}
	printf("max =%d\n", max);
	return 0;
}
4     //屏幕上输出99乘法表
int main()
{
	int i = 0;
	for (i = 1; i <= 9; i++)
	{
		int j = 1;
		for (j = 1; j <= i; j++)
		{
			printf("%d*%d=%-2d ", i, j, i * j);  //%2d表示打印两位，不够自动右对齐；%-2d自动左对齐
		}
		printf("\n");
	}
	return 0;
}
void menu()
{
	printf("猜数字\n");
	printf("***  1.play  0.exit  ***\n");
}
void game()
{
	
	int ret = 0;   
	int guess = 0;
	ret = rand()%100+1;   // 伪随机函数rand 生成0到7FFFH之间的一个任意整数。可以通过取模限定范围
	//printf("%d\n", ret);
	while (1)
	{
		printf("请猜数字：>");
		scanf("%d", &guess);
		if (guess > ret)
		{
			printf("猜大了\n");
		}
		else if (guess < ret)
		{
			printf("猜小了\n");
		}
		else
		{
			printf("猜对了\n");
			break;
		}
	}
}
int main()
{
	int input = 0;
	srand((unsigned int)time(NULL)); // 时间戳 当前时间和计算机起始时间（1970.01.01 00：00）的差值——一直在变化
	do
	{

		menu();
		printf("请选择>:");
		scanf("%d", &input);
		switch (input)
		{
		case 1:
			game();
			break;
		case 0:
			printf("退出游戏\n");
			break;
		default:
			printf("选择错误\n");
			break;
		}
	} while (input);
	return 0;
}
函数
  函数是什么：大型程序的部分代码，解决特定问题，相对独立。 分为库函数和自定义函数
int Add(int x, int y)
{
	int z = 0;
	z = x + y;
	return z;
}
int main()
{
	int a = 20;
	int b = 10;
	int sum = Add(a, b);
	printf("%d\n", sum);
	return 0;
}
  库函数：现成函数，引用头文件就能使用
具体有：IO函数、字符串操作函数、字符操作函数、内存操作函数、时间/日期函数、数学函数、其他库函数。
int main()
{
	char arr1[] = "bit";
	char arr2[20] = "#####";
	strcpy(arr2, arr1);
	printf("%s\n", arr2);
	return 0;
}
int main()
{
	char arr[] = "hehe haha";
	memset(arr, '*', 5);        //memset 内存设置
	printf("%s\n", arr);
	return 0;
}

  自定义函数：自己设计函数
ret_type fun_name(para1, *)  //类型 函数名+格式
{
	statement; //语句项，交代函数如何实现
}
int get_max(int x, int y)
{
	int z = 0;
    if (x > y)
       return x;
    else
       return y;
}
int main()
{
	int a = 10;
	int b = 20;
	int max = get_max (a, b);
	printf("max=%d\n", max);
	return 0;
}
void Swap(int* pa, int* pb)  // void代表没有返回值
{
	int tmp = 0;
	tmp = *pa;
	*pa = *pb;
	*pb = tmp;
}
int main()
{
	int a = 10;
	int* pa = &a;  //pa指针变量，用来存放a的地址
	*pa;//解引用操作，通过pa找到里面存的内容
	int b = 30;
	printf("a=%d b=%d\n", a, b);
	Swap(&a, &b);
	printf("a=%d b=%d\n", a, b);
	return 0;
}
  函数参数：形参、实参
  函数调用:函数与函数间有机组合。
  函数的嵌套调用和链式访问
 嵌套：函数里面套函数。
  链式访问：将一个函数的返回值作为下一函数的参数
int main()
{
	int len = 0;
	len = strlen("abc");
	printf("%d\n", len);
	printf("%d\n", strlen("abc")); // 链式访问
	return 0;
}
int main()
{
	printf("%d", printf("%d", printf("%d", 43))); //printf的返回值是打印在屏幕上字符的个数
	return 0;
}
  函数的声明和定义
 #include"函数.h"  //函数声明
int main()
{
	int a = 10;
	int b = 20;
	int sum = 0;
	sum = Add(a, b);
	printf("%d\n", sum);
	return 0;
}
  函数递归:程序调用自身的编程技巧。将一个大型复杂问题转化为一个与原问题相似的规模较小的问题来求解。
  必要条件：存在限制条件，达到限制条件后停止递归。  每次递归越来越逼近限制条件。
int main()
{
	printf("hrhr\n");
	main();              // main函数套main函数
	return 0;            //递归常见错误：栈溢出
}
void print(int n)
{
	if (n > 9)
	{
		print(n / 10);
	}
	printf("%d ", n % 10);
}
int main()
{
	unsigned int num = 0;
	scanf("%d", &num);
	print(num);
	return 0;
}
int my_strlen(char* str)    //利用循环模拟strlen函数
{
	int count = 0;            // 创建了临时变量count
	while (*str != '\0')
	{
		count++;
		str++;
	}
	return count;
}
int main()
{
	char arr[] = "bit";
	/*int len = strlen(arr);*/
	int len = my_strlen(arr);  //数组传参，传的是首元素地址
	printf("%d\n", len);
	return 0;
}
int my_strlen(char* str)     //利用递归模拟strlen函数
{
	if (*str != '\0')        //无临时变量
		return 1 + my_strlen(str + 1);
	else
		return 0;
}
int main()
{
	char arr[] = "bit";
	int len = my_strlen(arr);
	printf("%d\n", len);
	return 0;
}
递归与迭代
int FAC1(int n)
{
	/*int i = 0;                //循环方式
	int ret = 1;
	for (i = 1; i <= n; i++)
	{
		ret *= i;
	}
	return ret;*/
	if (n <= 1)                 //递归方式
		return 1;
	else
		return n * FAC1(n - 1);
}
int main()  //求n的阶乘
{
	int n = 0;
	int ret = 0;
	scanf("%d", &n);
	ret = FAC1(n);
	printf("%d\n", ret);
	return 0;
}
//数组
// 一维数组的创建和初始化
// 数组是一组相同元素的集合。创建方式：type_t是指数组的元素类型，const_n是一个常量表达式，用来指定数组的大小。
int main()
{
	int arr[10] = { 1，2，3 };  //不完全初始化，剩下的元素初始化默认0
	char arr2[5] = { 'a','b' };
	char arr3[5] = "ab";
	/*int n = 5;*/
	/*char ch[n]; */   //报错，[]中只能使用常量，不能变量。
	return 0;
}
 一维数组的使用
int main()
{
	char arr[] = "asdfg";
	int i = 0;
	for (i = 0; i < strlen(arr); i++)
	{
		printf("%c ", arr[i]);
	}
	return 0;
}
int main()
{
	int arr[] = { 1,2,3,4,5,6,7,8,9,0 };
	int sz = sizeof(arr) / sizeof(arr[0]);
	int i = 0;
	for (i = 0; i < sz; i++)
	{
		printf("%d ", arr[i]);              //利用下标访问数组
	}
	return 0;
}

 一维数组在内存中的存储
int main()
{
	int arr[] = { 1,2,3,4,5,6,7 };
	int sz = sizeof(arr) / sizeof(arr[0]);
	int i = 0;
	for (i = 0; i < sz; i++)
	{
		printf("&arr[%d]=%p\n", i, &arr[i]);
	}
	return 0;
}
 二维数组的创建和初始化
int main()
{
	int arr[3][4] = { 1,2,3,4,5 };
	int arr1[3][4] = { {1,2,3},{4,5} };
	int arr2[][] = { 1,2,3,4,5,6,7,8 };     //报错
	int arr3[][] = { {1,2,3,4},{5,6,7,8} }; //也不行
	int arr4[3][]= { {1,2,3,4},{5,6,7,8} }; //列不能省略
	int arr4[][4] = { {1,2,3,4},{5,6,7,8} };//可以省略行
	return 0;
}
 二维数组的使用
int main()
{
	int arr[3][4] = { {1,2,3},{4,5,6} };
	int i = 0;
	for (i = 0; i < 3; i++)
	{
		int j = 0;
		for (j = 0; j < 4; j++)
		{
			printf("%d ", arr[i][j]);
		}
		printf("\n");
	}
	return 0;
}
 二维数组在内存中的存储
int main()
{
	int arr[3][4] = { {1,2,3},{4,5,6} };
	int i = 0;
	for (i = 0; i < 3; i++)
	{
		int j = 0;
		for (j = 0; j < 4; j++)
		{
			printf("&arr[%d][%d]=%p\n",i,j,&arr[i][j]);
		}
		printf("\n");
	}
	return 0;
}
 数组作为函数参数
void bubble_sort(int arr[],int sz)
{
	int i = 0;
	for (i = 0; i < sz - 1; i++)
	{
		int j = 0;
		for (j = 0; j < sz-1-i; j++)
		{
			if (arr[j] > arr[j + 1]);
			{
				int tmp = arr[j];
				arr[j] = arr[j + 1];
				arr[j + 1] = tmp;
			}
		}
	}
}
void bubble_sort1(int arr[], int sz)    //优化版
{
	int i = 0;
	for (i = 0; i < sz - 1; i++)
	{
		int flag = 1;                   //假设已经有序
		int j = 0;
		for (j = 0; j < sz - 1 - i; j++)
		{
			if (arr[j] > arr[j + 1]);
			{
				int tmp = arr[j];
				arr[j] = arr[j + 1];
				arr[j + 1] = tmp;
				flag = 0;                //本次数组不完全有序
			}
		}
		if (flag == 1)                   //利用flag判断是否已经排序完成
		{
			break;
		}
	}
}
int main()
{
	int arr[] = { 9,8,7,6,5,4,3,2,1,0 }; //将arr排成升序
	int i = 0;
	int sz = sizeof(arr) / sizeof(arr[0]);
	bubble_sort(arr,sz); //冒泡排序函数
	for (i = 0; i < sz; i++)
	{
		printf("%d ", arr[i]);
	}
	return 0;
}
int main()                             //数组名
{
	int arr[] = { 1,2,3,4,5,6,7,8,9 };
	printf("%p\n", arr);
	printf("%p\n", &arr[0]);
	printf("%d\n", *arr);                   //数组名通常就是首元素地址
	int sz = sizeof(arr) / sizeof(arr[0]);  //例外1 sizeof(数组名)，计算的是整个数组的大小，单位是字节。
	printf("%p\n", arr);                    //例外2 取地址 &数组名，代表的是整个数组的地址。
	printf("%p\n", arr+1);                  // 加一后是数组中第二个元素的地址
	printf("%p\n", &arr[0]);
	printf("%p\n", &arr[0]+1);
	printf("%p\n", &arr);                   //看似一样，实际是整个数组地址。加一后的地址是整个数组之后的地址
	printf("%p\n", &arr+1);
	return 0;

//测试 三子棋 游戏
#pragma once
#include<stdlib.h>
#include<time.h>
#include <stdio.h>
#define ROW 3
#define COL 3

void InitBoard(char board[ROW][COL], int row, int col);//函数声明
void DisplayBoard(char board[ROW][COL], int row, int col);
void Playermove(char board[ROW][COL],int row,int col);
void Computermove(char board[ROW][COL], int row, int col);
char Iswin(char board[ROW][COL], int row, int col);


#include "game.h"
#define _CRT_SECURE_NO_WARNINGS 1

void InitBoard(char board[ROW][COL], int row, int col) 
{
	int i = 0;
	int j = 0;
	for (i = 0; i < row; i++)
	{
		for (j = 0; j < col; j++)
		{
			board[i][j] = ' ';
		}
	}
}

void DisplayBoard(char board[ROW][COL], int row, int col)
{
	printf("\n");
	int i = 0;
	for (i = 0; i < row; i++)
	{
		int j = 0;
		for (j = 0; j < col; j++)
		{
			printf(" %c ", board[i][j]);
			if (j < col - 1)
				printf("|");
		}
		printf("\n");
		if (i < row - 1)
		{
			int j = 0;
			for (j = 0; j < col; j++)
			{
				printf("---");
				if (j < col - 1)
					printf("|");
			}
			printf("\n");
		}
	}
}

void Playermove(char board[ROW][COL], int row, int col)
{
	int x = 0;
	int y = 0;
	printf("玩家下：>\n");
	while (1)
	{
		printf("请输入要下的坐标：>");
		scanf_s("%d%d", &x, &y);
		if (x >= 1 && x <= row && y >= 1 && y <= col)
		{
			if (board[x - 1][y - 1] == ' ')
			{
				board[x - 1][y - 1] = '*';
				break;
			}
			else
				printf("该坐标被占用\n");
		}
		else
		{
			printf("坐标非法，请重新输入！\n");
		}
	}
}

void Computermove(char board[ROW][COL], int row, int col)
{
	int x = 0;
	int y = 0;
	printf("电脑下：>");
	while (1)
	{
		x = rand() % row;
		y = rand() % col;
		if (board[x][y] == ' ')
		{
			board[x][y] = '#';
			break;
		}
	}
}

int IsFull(char board[ROW][COL], int row, int col)
{
	int i = 0;
	int j = 0;
	for (i = 0; i < row; i++)
	{
		for (j = 0; j < col; j++)
		{
			if (board[i][j] == ' ')
			{
				return 0;
			}
		}
	}
}
 
char Iswin(char board[ROW][COL], int row, int col) //判断输赢
{
	int i = 0;
	for (i = 0; i < row; i++)  //横三行判断
	{
		if (board[i][0] == board[i][1] && board[i][1] == board[i][2] && board[i][1] != ' ')
		{
			return board[i][0];
		}
	}
	for (i = 0; i < col; i++) //竖三列判断
	{
		if (board[0][i] == board[1][i] && board[1][i] == board[2][i] && board[2][i] != ' ')
		{
			return board[0][i];
		}
	}
	if (board[0][0] == board[1][1] && board[1][1] == board[2][2] && board[1][1] != ' ')  //对角线判断
		return board[1][1];
	if (board[2][0] == board[1][1] && board[1][1] == board[0][2] && board[1][1] != ' ')
		return board[1][1];
	if (1 == IsFull(board, ROW, COL))
	{
		return 'Q';
	}
	return 'c';
}


#define _CRT_SECURE_NO_WARNINGS 1
#include <stdio.h>
#include "game.h"

void menu()
{
	printf("**** 1.play  0.exit ****\n");
}

void game()
{
	char ret = 0;
	char board[ROW][COL] = {0};
	InitBoard(board, ROW, COL);
	DisplayBoard(board,ROW,COL);
	while (1)
	{
		Playermove(board,ROW,COL);     //玩家下棋
		DisplayBoard(board, ROW, COL); //显示棋盘
		ret = Iswin(board,ROW,COL);             //判断输赢
		if(ret != 'c')
		{
			break;
		}
		Computermove(board, ROW, COL);
		DisplayBoard(board, ROW, COL);
		ret = Iswin(board, ROW, COL);
		if (ret != 'c')
		{
			break;
		}
	}
	if (ret == '*')
	{
		printf("玩家赢\n");
	}
	else if (ret == '#')
	{
		printf("电脑赢\n");
	}
	else
	{
		printf("平局\n");
	}
}

void test()
{
	int input = 0;
	srand( (unsigned int) time(NULL) );
	do
	{
		menu();
		printf("请选择：");
		scanf("%d", &input);
		switch (input)
		{
		case 1:
			game();
			break;
		case 0:
			printf("退出游戏\n");
			break;
		default:
			printf("选择错误，重新选择：");
			break;
		}
	} while (input);
}




find· fish·
#pragma once
#include<stdio.h>
#define ROW 9
#define COL 9

#define ROWS ROW+2
#define COLS COL+2

#define EASY_COUNT 10

#include<stdlib.h>
#include<time.h>

void Initboard(char board[ROWS][COLS], int rows, int cols, char set);
void DisplayBoard(char board[ROWS][COLS], int row,int col);
void Setmine(char board[ROWS][COLS], int row, int col);
void Findmine(char mine[ROWS][COLS], char show[ROWS][COLS], int row, int col);
#define _CRT_SECURE_NO_WARNINGS 1
#include "game.h"


#define _CRT_SECURE_NO_WARNINGS 1
#include "game.h"

//初始化
void Initboard(char board[ROWS][COLS], int rows, int cols, char set)
{
	int i = 0;
	int j = 0;
	for (i = 0; i < rows; i++)
	{
		for (j = 0; j < cols; j++)
		{
			board[i][j] = set;
		}
	}
}

//打印棋盘
void DisplayBoard(char board[ROWS][COLS], int row, int col)
{
	int i = 0;
	int j = 0;
	for (i = 0; i <= col; i++) //打印列号
	{
		printf("%d ", i);
	}
	printf("\n");              //打印换行
	for (i = 1; i <= col; i++) //打印分割线
	{
		printf("~~");
	}
	printf("\n");
	for (i = 1; i <= row; i++)
	{
		printf("%d ", i);
		printf("|");
		for (j = 1; j <= col; j++)
		{
			printf("%c ", board[i][j]);
		}
		printf("\n");
	}
}

//放鱼(王老师）入塘
void Setmine(char board[ROWS][COLS], int row, int col)
{
	int count = EASY_COUNT;
	while (count)
	{
		int x = rand() % row + 1;
		int y = rand() % col + 1;
		if (board[x][y] == '0')
		{
			board[x][y] = '1';
			count--;
		}
	}
}

int get_mine_count(char mine[ROWS][COLS], int x, int y)
{
	//''里面是ASCII码，有'1'-'0'=1.利用该方法把字符1转换为数字1.
	return  mine[x - 1][y] +
			mine[x - 1][y - 1] +
			mine[x][y - 1] +
			mine[x + 1][y - 1] +
			mine[x + 1][y] +
			mine[x + 1][y + 1] +
			mine[x][y + 1] +
			mine[x - 1][y + 1] - 8 * '0';
}
void Findmine(char mine[ROWS][COLS], char show[ROWS][COLS], int row, int col)
{
	int x = 0;
	int y = 0;
	int win = 0;
	while (win<row*col - EASY_COUNT)
	{
		printf("请输入找鱼的坐标：（如1 1）");
		scanf_s("%d%d", &x, &y);
		if (x >= 1 && x <= 9 && y >= 1 && y <= 9)
		{
			//坐标合法
			if (mine[x][y] == '1')                  //只掉到一条
			{
				printf("很遗憾，其他鱼被吓跑了\n");
				DisplayBoard(mine, row, col);
				break;
			}
			else                                    //统计周围几条鱼,继续钓
			{
				int count = get_mine_count(mine, x, y);
				show[x][y] = count + '0';
				DisplayBoard(show, row, col);
				win++;
			}
		}
		else
		{
			printf("输入坐标错误，请重新输入！\n");
		}
	}
	if (win == row * col - EASY_COUNT)
	{
		printf("姜太公大获全胜！\n");
	}
}
void menu()
{
	printf("      find fish     \n");
	printf("找到鱼的位置并钓起它\n");
	printf("你是贪婪的姜太公，想要一次性钓走整个鱼塘的鱼\n");
	printf("拥有特殊技能的你，可以放下鱼竿并感知周围鱼的尾数\n");
	printf("如果鱼竿直接钓到鱼会吓跑其他鱼\n");
	printf("********************\n");
	printf("*****   1.play    **\n");
	printf("*****   0.exit    **\n");
	printf("********************\n");
}

void game()
{
	char mine[ROWS][COLS] = { 0 }; //11*11
	char show[ROWS][COLS] = { 0 };
	Initboard(mine, ROWS, COLS,'0');
	Initboard(show, ROWS, COLS,'*');
	DisplayBoard(show, ROW, COL);
	Setmine(mine, ROW, COL);
	//DisplayBoard(mine, ROW, COL);
	Findmine(mine, show, ROW, COL);
	printf("\n");
}

void test()
{
	int input = 0;
	srand((unsigned)time(NULL));
	do
	{
		menu();
		printf("请选择：");
		scanf_s("%d", &input);
		switch (input)
		{
		case 1:
			game();
			break;
		case 0:
			printf("退出游戏\n");
			break;
		default:
			printf("选择错误，重新选择\n");
			break;
		}
	} while (input);
}
int main()
{
	test();
	return 0;
}


操作符
算术操作符
int main()
{
	int a = 5 / 2; // 商二余一
	printf(" a = %d\n", a);
	return 0;
}

移位操作符
int main()
{
	int a = 16;
	a >> 1;           //算术右移操作符 0000000000010000(16位二进制数） 变成0000000000001000 右丢左补原符号位
	int b = a >> 1;   //逻辑右移。右丢左补0
	printf("%d\n", b);
	return 0;
}
int main()
{
	int a = -1;
	int b = a >> 2;
	printf("%d\n", b);  //整数存到内存中的是补码
	printf("%d\n", &a); //移位操作符不能移负数
	return 0;
}

位操作符
int main()
{
	int a = 3; //00000000000000000000000000000011
	int b = 5; //00000000000000000000000000000101
	int c = a & b; //00000000000000000000000000000001 按位与
	printf("%d\n", c);
	int d = 3;
	int f = 5;
	int e = d | f; //00000000000000000000000000000111 按位或
	printf("%d\n", e);
	int g = 3;
	int h = 5;
	int q = a ^ b; //00000000000000000000000000000110 按位异或
	printf("%d\n", q);
	return 0;
}

变态面试题：交换两个变量值不使用第三个变量。
int main()
{
	int a = 3;  //00000000000000000000000000000011
	int b = -4; //10000000000000000000000000000100
	//加减法（有缺陷，int范围内可能还行，遇到大数会溢出）
	a = a + b;  //a=-1
	b = a - b;  //b=3
	a = a - b;  //a=-4  实现交换   
	//异或法（不溢出）
	a = a ^ b;  //10000000000000000000000000000111
	b = a ^ b;  //00000000000000000000000000000011
	a = a ^ b;  //10000000000000000000000000000100 (a^b)^a=(a'b+ab')a'+(a'b+ab')'a=a'b+ab=b 实现交换
	return 0;
}

求一个整数存储在内存中的二进制中的二进制数中的个数
int main()                 //只能算正数
{
	int num = 0;
	int count = 0;
	scanf("%d", &num);
	while (num)
	{
		if (num % 2 == 1)
			count++;
		num = num / 2;
	}
	printf("%d\n", count);
	return 0;
}
int main()
{
	int num = 0;
	int count = 0;
	scanf_s("%d", &num);
	int i = 0;
	for (i = 0; i < 32; i++)
	{
		if (1 == ((num >> i) & 1))
			count++;
	}
	printf("%d\n", count);
	return 0;
}

赋值操作符
 = 赋值 可连续赋值但不推荐   ==是判断相等
复合赋值符
int main()
{
	int a = 10;
	a = a + 2;
	a += 2;

	a = a >> 1;
	a >>= 1;

	a = a & 1;
	a &= 1;
	return 0;
}

单目操作符
int main()
{
	int a = 10;
	if (a)
	{
		printf("哈哈\n");
	}
	if (!a)
	{
		printf("呵呵\n");
	}
	printf("%d\n", !a);    // !逻辑取反
	return 0;
}
int main()
{
	int a = 10;
	int*p=&a; //取地址操作符
	*p = 20;  //解引用操作符，指向地址内容
	return 0;
}
int main()
{
	int a = 10;
	char c = 'r';
	char* p = &c;
	int arr[10] = { 0 };
	printf("%d\n", sizeof(a));    //4
	printf("%d\n", sizeof(int));  //4
	printf("%d\n", sizeof(c));    //1
	printf("%d\n", sizeof(char)); //1
	printf("%d\n", sizeof(p));    //4
	printf("%d\n", sizeof(char*));//4
	printf("%d\n", sizeof(arr));  //40
	printf("%d\n", sizeof(int[10]));//40
	return 0;
}
int main()
{
	short s = 0;
	int a = 10;
	printf("%d\n", sizeof(s = a + 5));  //2
	printf("%d\n", s);                  //0
	return 0;
//}
int main()
{
	int a = 0;
	printf("%d\n",~a); //pirntf打印原码，按二进制位取反得到补码存在内存
	int b = 11;
	b = b | (1 << 2);  //按位或
	printf("%d\n", b);
	int c = 1;
	c = c & (~(1 << 2));
	printf("%d\n", a);
	return 0;
}
void test1(int arr[])
{
	printf("%d\n", sizeof(arr));
}
void test2(char ch[])
{
	printf("%d\n", sizeof(ch));
}
int main()
{
	int arr[10] = { 0 };
	char ch[10] = { 0 };
	printf("%d\n", sizeof(arr)); //40
	printf("%d\n", sizeof(ch)); //10
	test1(arr); //4
	test2(ch); //4  传的是指针，所以是数组首元素指针地址大小
	return 0;
}

逻辑操作符
int main()
{
	int i = 0, a = 0, b = 2, c = 3, d = 4;
	//i = a++ && ++b && d++;   // 逻辑短路，一旦第一个为假，后面都不执行。
	i = a++ || ++b || d++;     // 逻辑短路，第一个一旦为真，后面都不执行。
	printf("a=%d\n b=%d\n c=%d\n d=%d\n", a, b, c, d);
	return 0;
}

条件操作符
int main()
{
	int a = 0;
	int b = 0;
	if (a > 5)
		b = 3;
	else
		b = -3;
	b = (a > 5 ? 3 : -3); //三目操作符
	return 0;
}
int main()
{
	int a = 10;
	int b = 20;
	int max = 0;
	max = (a > b ? a : b); //选最大值
	return 0;
}

逗号表达式
int main()
{
	int a = 1;
	int b = 2;
	int c = (a > b, a = b + 10, a, b = a + 1); //从左向右依次执行,最后一个逗号表达式结果是整个的结果
	printf("%d\n", c);
	return 0;
}

下标引用操作符
int main()
{
	int a[10] = { 0 };
	a[4] = 10;
	1 + 2;
	return 0;
}

函数调用操作符()
int get_max(int x, int y)
{
	return (x > y ? x : y);
}
int main()
{
	int a = 0;
	int b = 20;
	int max = get_max(a, b); //操作数： 函数名+（参数）
	printf("max=%d\n", max);
	return 0;
}

结构体操作符
struct Stu
{
	char name[20];
	int age;
	char id[20];
};
int main()
{
	int a = 20;
	struct Stu s1 = { "张夏",20,"20211116" }; //用这个类型创建了一个学生对象，并初始化
	struct Stu* ps = &s1;
	printf("%s\n", (*ps).name);
	printf("%d\n", (*ps).age);
	printf("%s\n", s1.name);
	printf("%d\n", s1.age);
	printf("%s\n", s1.id);    //结构体变量.成员名
	printf("%s\n", ps->name); //结构体指针->成员名
	return 0;
}

表达式求值
隐式类型转换：C的整型算术运算总是以缺省整型类型的精度来进行。为了获得该精度，表达式中的字符和短整型操作数在使用之前被转换为普通整型（整型提升）
int main()
{
	char a = 3;         //00000000000000000000000000000011 a=00000011
	char b = 127;       //00000000000000000000000001111111 b=01111111
	char c = a + b;     //00000000000000000000000010000010 整型提升：按照变量数据类型的符号位提升，再相加。 
	printf("%d\n", c);  //截断后c=100000010 c的符号位变成1（负数） 补成11111111111111111111111110000010(补码） 输出原码10000000000000000000000001111110 -126
	return 0;
}
int main()
{
	char a = 0xb6;      //只能放一个字节，但是里面10110110
	short b = 0xb600;   //b理由类上
	int c = 0xb6000000;
	if (a == 0xb6)      //a整型提升，首位是1，提升后数与原值不符
		printf("a");
	if (b == 0xb600)
		printf("b");
	if (c == 0xb6000000)
		printf("c");
	return 0;
}
int main()
{
	char c = 1;
	printf("u\n", sizeof(c));   //1
	printf("%u\n", sizeof(+c)); //4 进行运算了，计算的是整型大小
	printf("%u\n", sizeof(!c)); //1
	return 0;
}

算术转换：操作符的各操作数属于不同类型，将占空间小的类型转换成大的进行运算。
操作符属性：优先级、结合性、是否控制求值顺序
int main()
{
	int a = 10;
	int b = 20;
	int c = b + a + 3;  //加号从左向右计算
	return 0;
}
逻辑与、逻辑或、逗号表达式、条件操作符会控制求值顺序！
歧义表达式：c + --c 导致左操作数的获取在右操作数之后，结果无法确定
非法表达式
int main()
{
	int i = 10;
	i = i-- - --i * (i = -3) * i++ + ++i; //不同编译器计算路径不同，结果不确定
	printf("i=%d\n", i);
	return 0;
int fun()
{
	static int count = 1;
	return ++count;
}
int main()
{
	int answer;
	answer = fun() - fun() * fun(); //先调用哪个fun函数不确定，调用顺序不同fun值不同
	printf("%d\n", answer);
	return 0;
}
int main()
{
	int i = 1;
	int a = (++i) + (++i) + (++i);
	printf("a = %d\n", a);
	return 0;
}
